{
  "advanced-usage.html": {
    "href": "advanced-usage.html",
    "title": "Advanced Usage Patterns | Unsplasharp Documentation",
    "summary": "Advanced Usage Patterns This guide covers advanced usage patterns, performance optimization techniques, and sophisticated integration strategies for Unsplasharp. Table of Contents Advanced Pagination Strategies Filtering and Search Optimization Custom Parameters and URL Manipulation Performance Optimization Batch Operations Advanced Error Handling Patterns Custom HTTP Client Configuration Monitoring and Metrics Advanced Pagination Strategies Infinite Scroll Implementation public class InfiniteScrollPhotoService { private readonly UnsplasharpClient _client; private readonly ILogger<InfiniteScrollPhotoService> _logger; public InfiniteScrollPhotoService(UnsplasharpClient client, ILogger<InfiniteScrollPhotoService> logger) { _client = client; _logger = logger; } public async IAsyncEnumerable<Photo> GetPhotosAsync( string query, int batchSize = 20, [EnumeratorCancellation] CancellationToken cancellationToken = default) { int currentPage = 1; bool hasMoreResults = true; while (hasMoreResults && !cancellationToken.IsCancellationRequested) { try { var photos = await _client.SearchPhotosAsync( query, page: currentPage, perPage: batchSize, cancellationToken: cancellationToken); if (photos.Count == 0) { hasMoreResults = false; yield break; } foreach (var photo in photos) { yield return photo; } // Check if we've reached the end hasMoreResults = photos.Count == batchSize && currentPage < _client.LastPhotosSearchTotalPages; currentPage++; // Rate limiting courtesy delay await Task.Delay(100, cancellationToken); } catch (UnsplasharpRateLimitException ex) { _logger.LogWarning(\"Rate limit hit during pagination, waiting {Delay}ms\", ex.TimeUntilReset?.TotalMilliseconds ?? 60000); await Task.Delay(ex.TimeUntilReset ?? TimeSpan.FromMinutes(1), cancellationToken); } catch (Exception ex) { _logger.LogError(ex, \"Error during pagination at page {Page}\", currentPage); hasMoreResults = false; } } } } // Usage example public async Task UseInfiniteScroll() { var service = new InfiniteScrollPhotoService(_client, _logger); var photoCount = 0; await foreach (var photo in service.GetPhotosAsync(\"nature\", batchSize: 30)) { Console.WriteLine($\"{++photoCount}: {photo.Description} by {photo.User.Name}\"); // Process photo (e.g., add to UI, cache, etc.) if (photoCount >= 100) // Limit for demo break; } } Parallel Pagination public class ParallelPaginationService { private readonly UnsplasharpClient _client; private readonly SemaphoreSlim _semaphore; public ParallelPaginationService(UnsplasharpClient client, int maxConcurrency = 3) { _client = client; _semaphore = new SemaphoreSlim(maxConcurrency, maxConcurrency); } public async Task<List<Photo>> GetPhotosParallelAsync( string query, int totalPages = 5, int perPage = 30) { var tasks = new List<Task<List<Photo>>>(); for (int page = 1; page <= totalPages; page++) { tasks.Add(GetPageAsync(query, page, perPage)); } var results = await Task.WhenAll(tasks); return results.SelectMany(photos => photos).ToList(); } private async Task<List<Photo>> GetPageAsync(string query, int page, int perPage) { await _semaphore.WaitAsync(); try { // Add jitter to avoid thundering herd await Task.Delay(Random.Shared.Next(0, 500)); return await _client.SearchPhotosAsync(query, page: page, perPage: perPage); } catch (UnsplasharpRateLimitException) { // If rate limited, return empty list and let caller handle return new List<Photo>(); } finally { _semaphore.Release(); } } } Filtering and Search Optimization Advanced Search Builder public class UnsplashSearchBuilder { private string _query = string.Empty; private int _page = 1; private int _perPage = 10; private OrderBy _orderBy = OrderBy.Relevant; private string? _color; private Orientation _orientation = Orientation.All; private string? _contentFilter; private List<string> _collectionIds = new(); public UnsplashSearchBuilder Query(string query) { _query = query; return this; } public UnsplashSearchBuilder Page(int page) { _page = Math.Max(1, page); return this; } public UnsplashSearchBuilder PerPage(int perPage) { _perPage = Math.Clamp(perPage, 1, 30); return this; } public UnsplashSearchBuilder OrderBy(OrderBy orderBy) { _orderBy = orderBy; return this; } public UnsplashSearchBuilder Color(string color) { var validColors = new[] { \"black_and_white\", \"black\", \"white\", \"yellow\", \"orange\", \"red\", \"purple\", \"magenta\", \"green\", \"teal\", \"blue\" }; if (validColors.Contains(color.ToLowerInvariant())) { _color = color; } return this; } public UnsplashSearchBuilder Orientation(Orientation orientation) { _orientation = orientation; return this; } public UnsplashSearchBuilder ContentFilter(string filter) { if (filter == \"low\" || filter == \"high\") { _contentFilter = filter; } return this; } public UnsplashSearchBuilder InCollections(params string[] collectionIds) { _collectionIds.AddRange(collectionIds); return this; } public async Task<List<Photo>> ExecuteAsync(UnsplasharpClient client) { var collectionIdsString = _collectionIds.Count > 0 ? string.Join(\",\", _collectionIds) : null; return await client.SearchPhotosAsync( _query, _page, _perPage, _orderBy, collectionIdsString, _contentFilter, _color, _orientation ); } } // Usage example public async Task AdvancedSearchExample() { var photos = await new UnsplashSearchBuilder() .Query(\"mountain landscape\") .Color(\"blue\") .Orientation(Orientation.Landscape) .OrderBy(OrderBy.Popular) .PerPage(20) .ContentFilter(\"high\") .InCollections(\"499830\", \"194162\") .ExecuteAsync(_client); Console.WriteLine($\"Found {photos.Count} photos matching criteria\"); } Smart Search with Fallbacks public class SmartSearchService { private readonly UnsplasharpClient _client; private readonly ILogger<SmartSearchService> _logger; public SmartSearchService(UnsplasharpClient client, ILogger<SmartSearchService> logger) { _client = client; _logger = logger; } public async Task<List<Photo>> SmartSearchAsync(string query, int desiredCount = 20) { var searchStrategies = new List<Func<Task<List<Photo>>>> { // Primary search - exact query () => _client.SearchPhotosAsync(query, perPage: desiredCount), // Fallback 1 - broader search with popular ordering () => _client.SearchPhotosAsync(query, orderBy: OrderBy.Popular, perPage: desiredCount), // Fallback 2 - search individual words () => SearchIndividualWords(query, desiredCount), // Fallback 3 - random photos if all else fails () => GetRandomPhotosAsync(desiredCount) }; foreach (var strategy in searchStrategies) { try { var results = await strategy(); if (results.Count > 0) { _logger.LogInformation(\"Search strategy succeeded, found {Count} photos\", results.Count); return results; } } catch (Exception ex) { _logger.LogWarning(ex, \"Search strategy failed, trying next approach\"); } } _logger.LogWarning(\"All search strategies failed for query: {Query}\", query); return new List<Photo>(); } private async Task<List<Photo>> SearchIndividualWords(string query, int desiredCount) { var words = query.Split(' ', StringSplitOptions.RemoveEmptyEntries); var allPhotos = new List<Photo>(); foreach (var word in words.Take(3)) // Limit to first 3 words { try { var photos = await _client.SearchPhotosAsync(word, perPage: desiredCount / words.Length + 5); allPhotos.AddRange(photos); } catch (Exception ex) { _logger.LogDebug(ex, \"Failed to search for word: {Word}\", word); } } return allPhotos.DistinctBy(p => p.Id).Take(desiredCount).ToList(); } private async Task<List<Photo>> GetRandomPhotosAsync(int count) { var photos = new List<Photo>(); var batchSize = Math.Min(count, 30); for (int i = 0; i < Math.Ceiling((double)count / batchSize); i++) { try { var randomPhotos = await _client.GetRandomPhotosAsync(batchSize); photos.AddRange(randomPhotos); if (photos.Count >= count) break; } catch (Exception ex) { _logger.LogDebug(ex, \"Failed to get random photos batch {Batch}\", i); } } return photos.Take(count).ToList(); } } Custom Parameters and URL Manipulation Custom Photo Sizing public class CustomPhotoService { private readonly UnsplasharpClient _client; public CustomPhotoService(UnsplasharpClient client) { _client = client; } public async Task<Photo?> GetPhotoWithCustomSize(string photoId, int width, int height, bool crop = false) { if (crop) { // Get original photo first to calculate crop parameters var originalPhoto = await _client.GetPhotoAsync(photoId); // Calculate center crop var cropX = Math.Max(0, (originalPhoto.Width - width) / 2); var cropY = Math.Max(0, (originalPhoto.Height - height) / 2); return await _client.GetPhoto(photoId, width, height, cropX, cropY, width, height); } else { return await _client.GetPhoto(photoId, width, height); } } public async Task<Dictionary<string, string>> GetMultipleSizes(string photoId) { var sizes = new Dictionary<string, (int width, int height)> { [\"thumbnail\"] = (200, 200), [\"small\"] = (400, 300), [\"medium\"] = (800, 600), [\"large\"] = (1200, 900), [\"hero\"] = (1920, 1080) }; var results = new Dictionary<string, string>(); foreach (var (sizeName, (width, height)) in sizes) { try { var photo = await _client.GetPhoto(photoId, width, height); if (photo?.Urls.Custom != null) { results[sizeName] = photo.Urls.Custom; } } catch (Exception ex) { Console.WriteLine($\"Failed to get {sizeName} size: {ex.Message}\"); } } return results; } } URL Parameter Optimization public static class UnsplashUrlHelper { public static string OptimizePhotoUrl(string originalUrl, int? width = null, int? height = null, int? quality = null, string? format = null, bool? fit = null) { if (string.IsNullOrEmpty(originalUrl)) return originalUrl; var uriBuilder = new UriBuilder(originalUrl); var query = HttpUtility.ParseQueryString(uriBuilder.Query); if (width.HasValue) query[\"w\"] = width.Value.ToString(); if (height.HasValue) query[\"h\"] = height.Value.ToString(); if (quality.HasValue && quality.Value >= 1 && quality.Value <= 100) query[\"q\"] = quality.Value.ToString(); if (!string.IsNullOrEmpty(format) && new[] { \"jpg\", \"png\", \"webp\" }.Contains(format.ToLower())) query[\"fm\"] = format.ToLower(); if (fit.HasValue) query[\"fit\"] = fit.Value ? \"crop\" : \"max\"; uriBuilder.Query = query.ToString(); return uriBuilder.ToString(); } public static string AddWatermark(string photoUrl, string text, string position = \"bottom-right\") { var uriBuilder = new UriBuilder(photoUrl); var query = HttpUtility.ParseQueryString(uriBuilder.Query); query[\"txt\"] = text; query[\"txt-pos\"] = position; query[\"txt-size\"] = \"24\"; query[\"txt-color\"] = \"ffffff\"; uriBuilder.Query = query.ToString(); return uriBuilder.ToString(); } } // Usage example public async Task CustomUrlExample() { var photo = await _client.GetPhotoAsync(\"qcs09SwNPHY\"); // Optimize for web display var webOptimized = UnsplashUrlHelper.OptimizePhotoUrl( photo.Urls.Regular, width: 800, height: 600, quality: 80, format: \"webp\" ); // Add watermark var watermarked = UnsplashUrlHelper.AddWatermark( photo.Urls.Regular, \"© My App\", \"bottom-right\" ); Console.WriteLine($\"Original: {photo.Urls.Regular}\"); Console.WriteLine($\"Optimized: {webOptimized}\"); Console.WriteLine($\"Watermarked: {watermarked}\"); } Performance Optimization Intelligent Caching Strategy public class IntelligentCacheService { private readonly UnsplasharpClient _client; private readonly IMemoryCache _memoryCache; private readonly IDistributedCache _distributedCache; private readonly ILogger<IntelligentCacheService> _logger; public IntelligentCacheService( UnsplasharpClient client, IMemoryCache memoryCache, IDistributedCache distributedCache, ILogger<IntelligentCacheService> logger) { _client = client; _memoryCache = memoryCache; _distributedCache = distributedCache; _logger = logger; } public async Task<Photo?> GetPhotoAsync(string photoId, CacheStrategy strategy = CacheStrategy.Intelligent) { var cacheKey = $\"photo:{photoId}\"; // Try memory cache first (fastest) if (_memoryCache.TryGetValue(cacheKey, out Photo cachedPhoto)) { _logger.LogDebug(\"Photo {PhotoId} found in memory cache\", photoId); return cachedPhoto; } // Try distributed cache (Redis, etc.) if (strategy >= CacheStrategy.Distributed) { var distributedData = await _distributedCache.GetStringAsync(cacheKey); if (distributedData != null) { try { var photo = JsonSerializer.Deserialize<Photo>(distributedData); // Store in memory cache for faster future access _memoryCache.Set(cacheKey, photo, TimeSpan.FromMinutes(15)); _logger.LogDebug(\"Photo {PhotoId} found in distributed cache\", photoId); return photo; } catch (JsonException ex) { _logger.LogWarning(ex, \"Failed to deserialize cached photo {PhotoId}\", photoId); } } } // Fetch from API try { var photo = await _client.GetPhotoAsync(photoId); // Cache with intelligent TTL based on photo popularity var memoryCacheDuration = CalculateMemoryCacheDuration(photo); var distributedCacheDuration = CalculateDistributedCacheDuration(photo); _memoryCache.Set(cacheKey, photo, memoryCacheDuration); if (strategy >= CacheStrategy.Distributed) { var serializedPhoto = JsonSerializer.Serialize(photo); await _distributedCache.SetStringAsync(cacheKey, serializedPhoto, new DistributedCacheEntryOptions { AbsoluteExpirationRelativeToNow = distributedCacheDuration }); } _logger.LogDebug(\"Photo {PhotoId} fetched from API and cached\", photoId); return photo; } catch (UnsplasharpNotFoundException) { // Cache negative results to avoid repeated API calls _memoryCache.Set(cacheKey, (Photo?)null, TimeSpan.FromMinutes(5)); return null; } } private TimeSpan CalculateMemoryCacheDuration(Photo photo) { // Popular photos (high likes/downloads) cached longer var popularity = photo.Likes + (photo.Downloads / 10); return popularity switch { > 10000 => TimeSpan.FromHours(2), > 1000 => TimeSpan.FromHours(1), > 100 => TimeSpan.FromMinutes(30), _ => TimeSpan.FromMinutes(15) }; } private TimeSpan CalculateDistributedCacheDuration(Photo photo) { // Longer cache for distributed storage return CalculateMemoryCacheDuration(photo).Multiply(4); } } public enum CacheStrategy { None, Memory, Distributed, Intelligent } Connection Pooling and HTTP Optimization public static class UnsplashHttpClientConfiguration { public static void ConfigureOptimizedHttpClient(this IServiceCollection services, UnsplashConfiguration config) { services.AddHttpClient(\"unsplash\", client => { client.BaseAddress = new Uri(\"https://api.unsplash.com/\"); client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Client-ID\", config.ApplicationId); // Optimize headers client.DefaultRequestHeaders.Accept.Clear(); client.DefaultRequestHeaders.Accept.Add( new MediaTypeWithQualityHeaderValue(\"application/json\")); client.DefaultRequestHeaders.UserAgent.ParseAdd( $\"UnsplasharpApp/1.0 (+{config.ApplicationUrl})\"); // Connection optimization client.Timeout = config.DefaultTimeout; }) .ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler { // Connection pooling settings PooledConnectionLifetime = TimeSpan.FromMinutes(15), PooledConnectionIdleTimeout = TimeSpan.FromMinutes(5), MaxConnectionsPerServer = 10, // Performance settings EnableMultipleHttp2Connections = true, UseCookies = false, // Unsplash API doesn't use cookies // Compression AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate }) .AddPolicyHandler(GetRetryPolicy()) .AddPolicyHandler(GetCircuitBreakerPolicy()); } private static IAsyncPolicy<HttpResponseMessage> GetRetryPolicy() { return Policy .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode && r.StatusCode != HttpStatusCode.NotFound) .Or<HttpRequestException>() .Or<TaskCanceledException>() .WaitAndRetryAsync( retryCount: 3, sleepDurationProvider: retryAttempt => TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)) + TimeSpan.FromMilliseconds(Random.Shared.Next(0, 1000)), onRetry: (outcome, timespan, retryCount, context) => { var logger = context.GetLogger(); logger?.LogWarning(\"Retry {RetryCount} after {Delay}ms for {Url}\", retryCount, timespan.TotalMilliseconds, context.OperationKey); }); } private static IAsyncPolicy<HttpResponseMessage> GetCircuitBreakerPolicy() { return Policy .HandleResult<HttpResponseMessage>(r => !r.IsSuccessStatusCode) .CircuitBreakerAsync( handledEventsAllowedBeforeBreaking: 5, durationOfBreak: TimeSpan.FromSeconds(30), onBreak: (result, timespan) => { // Log circuit breaker opening }, onReset: () => { // Log circuit breaker closing }); } } Batch Operations Efficient Bulk Photo Processing public class BulkPhotoProcessor { private readonly UnsplasharpClient _client; private readonly SemaphoreSlim _semaphore; private readonly ILogger<BulkPhotoProcessor> _logger; public BulkPhotoProcessor(UnsplasharpClient client, ILogger<BulkPhotoProcessor> logger, int maxConcurrency = 5) { _client = client; _logger = logger; _semaphore = new SemaphoreSlim(maxConcurrency, maxConcurrency); } public async Task<BulkProcessResult<Photo>> ProcessPhotosAsync( IEnumerable<string> photoIds, CancellationToken cancellationToken = default) { var result = new BulkProcessResult<Photo>(); var tasks = photoIds.Select(id => ProcessSinglePhotoAsync(id, result, cancellationToken)); await Task.WhenAll(tasks); _logger.LogInformation(\"Bulk processing completed: {Success} successful, {Failed} failed\", result.Successful.Count, result.Failed.Count); return result; } private async Task ProcessSinglePhotoAsync( string photoId, BulkProcessResult<Photo> result, CancellationToken cancellationToken) { await _semaphore.WaitAsync(cancellationToken); try { // Add jitter to prevent thundering herd await Task.Delay(Random.Shared.Next(0, 200), cancellationToken); var photo = await _client.GetPhotoAsync(photoId, cancellationToken); lock (result) { result.Successful.Add(photo); } _logger.LogDebug(\"Successfully processed photo {PhotoId}\", photoId); } catch (UnsplasharpNotFoundException) { lock (result) { result.Failed.Add(new BulkProcessError(photoId, \"Photo not found\")); } _logger.LogWarning(\"Photo {PhotoId} not found\", photoId); } catch (UnsplasharpRateLimitException ex) { lock (result) { result.Failed.Add(new BulkProcessError(photoId, \"Rate limit exceeded\")); } _logger.LogWarning(\"Rate limit exceeded for photo {PhotoId}\", photoId); // Wait for rate limit reset if (ex.TimeUntilReset.HasValue) { await Task.Delay(ex.TimeUntilReset.Value, cancellationToken); } } catch (Exception ex) { lock (result) { result.Failed.Add(new BulkProcessError(photoId, ex.Message)); } _logger.LogError(ex, \"Error processing photo {PhotoId}\", photoId); } finally { _semaphore.Release(); } } } public class BulkProcessResult<T> { public List<T> Successful { get; } = new(); public List<BulkProcessError> Failed { get; } = new(); public int TotalProcessed => Successful.Count + Failed.Count; public double SuccessRate => TotalProcessed > 0 ? (double)Successful.Count / TotalProcessed : 0; } public record BulkProcessError(string Id, string Error); Batch Download Manager public class BatchDownloadManager { private readonly UnsplasharpClient _client; private readonly HttpClient _httpClient; private readonly ILogger<BatchDownloadManager> _logger; private readonly SemaphoreSlim _downloadSemaphore; public BatchDownloadManager( UnsplasharpClient client, HttpClient httpClient, ILogger<BatchDownloadManager> logger, int maxConcurrentDownloads = 3) { _client = client; _httpClient = httpClient; _logger = logger; _downloadSemaphore = new SemaphoreSlim(maxConcurrentDownloads, maxConcurrentDownloads); } public async Task<BatchDownloadResult> DownloadPhotosAsync( IEnumerable<string> photoIds, string downloadDirectory, PhotoSize size = PhotoSize.Regular, IProgress<DownloadProgress>? progress = null, CancellationToken cancellationToken = default) { Directory.CreateDirectory(downloadDirectory); var result = new BatchDownloadResult(); var photoIdsList = photoIds.ToList(); var totalPhotos = photoIdsList.Count; var processedCount = 0; var downloadTasks = photoIdsList.Select(async photoId => { try { var downloadPath = await DownloadSinglePhotoAsync(photoId, downloadDirectory, size, cancellationToken); lock (result) { result.SuccessfulDownloads.Add(new DownloadResult(photoId, downloadPath)); processedCount++; } progress?.Report(new DownloadProgress(processedCount, totalPhotos, photoId, true)); } catch (Exception ex) { lock (result) { result.FailedDownloads.Add(new DownloadError(photoId, ex.Message)); processedCount++; } progress?.Report(new DownloadProgress(processedCount, totalPhotos, photoId, false)); _logger.LogError(ex, \"Failed to download photo {PhotoId}\", photoId); } }); await Task.WhenAll(downloadTasks); _logger.LogInformation(\"Batch download completed: {Success}/{Total} successful\", result.SuccessfulDownloads.Count, totalPhotos); return result; } private async Task<string> DownloadSinglePhotoAsync( string photoId, string downloadDirectory, PhotoSize size, CancellationToken cancellationToken) { await _downloadSemaphore.WaitAsync(cancellationToken); try { // Get photo metadata var photo = await _client.GetPhotoAsync(photoId, cancellationToken); // Select appropriate URL based on size var imageUrl = size switch { PhotoSize.Thumbnail => photo.Urls.Thumbnail, PhotoSize.Small => photo.Urls.Small, PhotoSize.Regular => photo.Urls.Regular, PhotoSize.Full => photo.Urls.Full, PhotoSize.Raw => photo.Urls.Raw, _ => photo.Urls.Regular }; // Download image var imageBytes = await _httpClient.GetByteArrayAsync(imageUrl, cancellationToken); // Generate filename var fileName = $\"{photo.Id}_{size.ToString().ToLower()}.jpg\"; var filePath = Path.Combine(downloadDirectory, fileName); // Save to disk await File.WriteAllBytesAsync(filePath, imageBytes, cancellationToken); _logger.LogDebug(\"Downloaded photo {PhotoId} to {FilePath} ({Size} bytes)\", photoId, filePath, imageBytes.Length); return filePath; } finally { _downloadSemaphore.Release(); } } } public enum PhotoSize { Thumbnail, Small, Regular, Full, Raw } public class BatchDownloadResult { public List<DownloadResult> SuccessfulDownloads { get; } = new(); public List<DownloadError> FailedDownloads { get; } = new(); public int TotalAttempted => SuccessfulDownloads.Count + FailedDownloads.Count; public double SuccessRate => TotalAttempted > 0 ? (double)SuccessfulDownloads.Count / TotalAttempted : 0; } public record DownloadResult(string PhotoId, string FilePath); public record DownloadError(string PhotoId, string Error); public record DownloadProgress(int Processed, int Total, string CurrentPhotoId, bool Success); Monitoring and Metrics Performance Metrics Collection public class UnsplashMetricsCollector { private readonly ILogger<UnsplashMetricsCollector> _logger; private readonly ConcurrentDictionary<string, ApiMetrics> _metrics = new(); public UnsplashMetricsCollector(ILogger<UnsplashMetricsCollector> logger) { _logger = logger; } public void RecordApiCall(string endpoint, TimeSpan duration, bool success, int? statusCode = null) { var metrics = _metrics.GetOrAdd(endpoint, _ => new ApiMetrics()); lock (metrics) { metrics.TotalCalls++; metrics.TotalDuration += duration; if (success) { metrics.SuccessfulCalls++; } else { metrics.FailedCalls++; } if (statusCode.HasValue) { metrics.StatusCodes.AddOrUpdate(statusCode.Value, 1, (_, count) => count + 1); } metrics.LastCallTime = DateTimeOffset.UtcNow; // Update min/max duration if (duration < metrics.MinDuration || metrics.MinDuration == TimeSpan.Zero) metrics.MinDuration = duration; if (duration > metrics.MaxDuration) metrics.MaxDuration = duration; } } public void RecordRateLimit(int remaining, int limit, DateTimeOffset? resetTime) { var rateLimitMetrics = _metrics.GetOrAdd(\"_rate_limit\", _ => new ApiMetrics()); lock (rateLimitMetrics) { rateLimitMetrics.RateLimitRemaining = remaining; rateLimitMetrics.RateLimitTotal = limit; rateLimitMetrics.RateLimitResetTime = resetTime; } } public MetricsSummary GetSummary() { var summary = new MetricsSummary { GeneratedAt = DateTimeOffset.UtcNow, EndpointMetrics = new Dictionary<string, EndpointSummary>() }; foreach (var (endpoint, metrics) in _metrics) { if (endpoint == \"_rate_limit\") { summary.RateLimitRemaining = metrics.RateLimitRemaining; summary.RateLimitTotal = metrics.RateLimitTotal; summary.RateLimitResetTime = metrics.RateLimitResetTime; continue; } lock (metrics) { summary.EndpointMetrics[endpoint] = new EndpointSummary { TotalCalls = metrics.TotalCalls, SuccessfulCalls = metrics.SuccessfulCalls, FailedCalls = metrics.FailedCalls, SuccessRate = metrics.TotalCalls > 0 ? (double)metrics.SuccessfulCalls / metrics.TotalCalls : 0, AverageDuration = metrics.TotalCalls > 0 ? metrics.TotalDuration.TotalMilliseconds / metrics.TotalCalls : 0, MinDuration = metrics.MinDuration.TotalMilliseconds, MaxDuration = metrics.MaxDuration.TotalMilliseconds, LastCallTime = metrics.LastCallTime, StatusCodeDistribution = new Dictionary<int, int>(metrics.StatusCodes) }; } } return summary; } public void LogMetricsSummary() { var summary = GetSummary(); _logger.LogInformation(\"=== Unsplash API Metrics Summary ===\"); _logger.LogInformation(\"Rate Limit: {Remaining}/{Total} (Reset: {ResetTime})\", summary.RateLimitRemaining, summary.RateLimitTotal, summary.RateLimitResetTime); foreach (var (endpoint, metrics) in summary.EndpointMetrics) { _logger.LogInformation(\"Endpoint: {Endpoint}\", endpoint); _logger.LogInformation(\" Calls: {Total} (Success: {Success}, Failed: {Failed}, Rate: {Rate:P2})\", metrics.TotalCalls, metrics.SuccessfulCalls, metrics.FailedCalls, metrics.SuccessRate); _logger.LogInformation(\" Duration: Avg {Avg:F1}ms, Min {Min:F1}ms, Max {Max:F1}ms\", metrics.AverageDuration, metrics.MinDuration, metrics.MaxDuration); _logger.LogInformation(\" Last Call: {LastCall}\", metrics.LastCallTime); } } } public class ApiMetrics { public int TotalCalls { get; set; } public int SuccessfulCalls { get; set; } public int FailedCalls { get; set; } public TimeSpan TotalDuration { get; set; } public TimeSpan MinDuration { get; set; } public TimeSpan MaxDuration { get; set; } public DateTimeOffset LastCallTime { get; set; } public ConcurrentDictionary<int, int> StatusCodes { get; } = new(); // Rate limit tracking public int RateLimitRemaining { get; set; } public int RateLimitTotal { get; set; } public DateTimeOffset? RateLimitResetTime { get; set; } } public class MetricsSummary { public DateTimeOffset GeneratedAt { get; set; } public Dictionary<string, EndpointSummary> EndpointMetrics { get; set; } = new(); public int RateLimitRemaining { get; set; } public int RateLimitTotal { get; set; } public DateTimeOffset? RateLimitResetTime { get; set; } } public class EndpointSummary { public int TotalCalls { get; set; } public int SuccessfulCalls { get; set; } public int FailedCalls { get; set; } public double SuccessRate { get; set; } public double AverageDuration { get; set; } public double MinDuration { get; set; } public double MaxDuration { get; set; } public DateTimeOffset LastCallTime { get; set; } public Dictionary<int, int> StatusCodeDistribution { get; set; } = new(); }"
  },
  "api-reference.html": {
    "href": "api-reference.html",
    "title": "API Reference Guide | Unsplasharp Documentation",
    "summary": "API Reference Guide This comprehensive guide covers all available methods in the Unsplasharp library with detailed examples and use cases. Table of Contents Client Initialization Photo Methods Search Methods Collection Methods User Methods Statistics Methods Method Parameters Return Types Client Initialization Basic Initialization using Unsplasharp; // Basic client with Application ID only var client = new UnsplasharpClient(\"YOUR_APPLICATION_ID\"); // With optional secret for authenticated requests var client = new UnsplasharpClient(\"YOUR_APPLICATION_ID\", \"YOUR_SECRET\"); // With logging support var logger = loggerFactory.CreateLogger<UnsplasharpClient>(); var client = new UnsplasharpClient(\"YOUR_APPLICATION_ID\", logger: logger); // With IHttpClientFactory (recommended for production) var client = new UnsplasharpClient(\"YOUR_APPLICATION_ID\", logger: logger, httpClientFactory: httpClientFactory); Dependency Injection Setup // In Program.cs or Startup.cs services.AddUnsplasharp(\"YOUR_APPLICATION_ID\"); // Or with configuration services.AddUnsplasharp(options => { options.ApplicationId = \"YOUR_APPLICATION_ID\"; options.Secret = \"YOUR_SECRET\"; options.ConfigureHttpClient = client => { client.Timeout = TimeSpan.FromSeconds(60); }; }); Photo Methods GetPhoto / GetPhotoAsync Retrieve a specific photo by ID with optional custom sizing. Signatures: Task<Photo?> GetPhoto(string id, CancellationToken cancellationToken = default) Task<Photo?> GetPhoto(string id, int? width = null, int? height = null, CancellationToken cancellationToken = default) Task<Photo?> GetPhoto(string id, int? width, int? height, int? cropX, int? cropY, int? cropWidth, int? cropHeight, CancellationToken cancellationToken = default) Task<Photo> GetPhotoAsync(string id, CancellationToken cancellationToken = default) // Throws exceptions Examples: // Basic photo retrieval var photo = await client.GetPhoto(\"qcs09SwNPHY\"); if (photo != null) { Console.WriteLine($\"Photo by {photo.User.Name}: {photo.Description}\"); Console.WriteLine($\"Regular size: {photo.Urls.Regular}\"); } // Custom sizing var resizedPhoto = await client.GetPhoto(\"qcs09SwNPHY\", width: 800, height: 600); Console.WriteLine($\"Custom URL: {resizedPhoto?.Urls.Custom}\"); // Cropped version var croppedPhoto = await client.GetPhoto(\"qcs09SwNPHY\", width: 400, height: 400, cropX: 100, cropY: 100, cropWidth: 200, cropHeight: 200); // Exception-throwing version (recommended for new code) try { var photo = await client.GetPhotoAsync(\"qcs09SwNPHY\"); Console.WriteLine($\"Photo dimensions: {photo.Width}x{photo.Height}\"); } catch (UnsplasharpNotFoundException) { Console.WriteLine(\"Photo not found\"); } catch (UnsplasharpException ex) { Console.WriteLine($\"API error: {ex.Message}\"); } GetRandomPhoto / GetRandomPhotoAsync Get one or more random photos with optional filtering. Signatures: Task<Photo?> GetRandomPhoto(CancellationToken cancellationToken = default) Task<Photo?> GetRandomPhoto(string collectionId, CancellationToken cancellationToken = default) Task<Photo?> GetRandomPhoto(string[] collectionIds, CancellationToken cancellationToken = default) Task<Photo?> GetRandomPhoto(int count, string? query = null, string? username = null, bool featured = false, string? collectionId = null, Orientation orientation = Orientation.All, CancellationToken cancellationToken = default) Task<Photo> GetRandomPhotoAsync(...) // Exception-throwing versions Examples: // Simple random photo var randomPhoto = await client.GetRandomPhoto(); // Random photo from specific collection var collectionPhoto = await client.GetRandomPhoto(\"499830\"); // Random photo from multiple collections var multiCollectionPhoto = await client.GetRandomPhoto(new[] { \"499830\", \"194162\" }); // Multiple random photos with filters var naturePhotos = await client.GetRandomPhoto( count: 5, query: \"nature\", featured: true, orientation: Orientation.Landscape ); // Random photo from specific user var userPhoto = await client.GetRandomPhoto(1, username: \"chrisjoelcampbell\"); ListPhotos / ListPhotosAsync Get a paginated list of all photos. Signatures: Task<List<Photo>> ListPhotos(int page = 1, int perPage = 10, OrderBy orderBy = OrderBy.Latest, CancellationToken cancellationToken = default) Task<List<Photo>> ListPhotosAsync(...) // Exception-throwing version Examples: // Get latest photos (default) var latestPhotos = await client.ListPhotos(page: 1, perPage: 20); // Get oldest photos first var oldestPhotos = await client.ListPhotos( page: 1, perPage: 10, orderBy: OrderBy.Oldest ); // Get popular photos var popularPhotos = await client.ListPhotos(orderBy: OrderBy.Popular); // Pagination example for (int page = 1; page <= 5; page++) { var photos = await client.ListPhotos(page: page, perPage: 30); Console.WriteLine($\"Page {page}: {photos.Count} photos\"); foreach (var photo in photos) { Console.WriteLine($\" - {photo.Id}: {photo.Description}\"); } } Search Methods SearchPhotos / SearchPhotosAsync Search for photos by query with advanced filtering options. Signatures: Task<List<Photo>> SearchPhotos(string query, int page = 1, int perPage = 10, CancellationToken cancellationToken = default) Task<List<Photo>> SearchPhotos(string query, int page, int perPage, OrderBy orderBy, string? collectionIds = null, string? contentFilter = null, string? color = null, Orientation orientation = Orientation.All, CancellationToken cancellationToken = default) Examples: // Basic search var naturePhotos = await client.SearchPhotos(\"nature\"); // Advanced search with filters var filteredPhotos = await client.SearchPhotos( query: \"mountain landscape\", page: 1, perPage: 20, orderBy: OrderBy.Relevant, color: \"blue\", orientation: Orientation.Landscape ); // Search with content filtering var safePhotos = await client.SearchPhotos( query: \"beach\", page: 1, perPage: 15, contentFilter: \"high\" ); // Check search metadata Console.WriteLine($\"Search query: {client.LastPhotosSearchQuery}\"); Console.WriteLine($\"Total results: {client.LastPhotosSearchTotalResults}\"); Console.WriteLine($\"Total pages: {client.LastPhotosSearchTotalPages}\"); Collection Methods GetCollection / GetCollectionAsync Retrieve a specific collection by ID. Signatures: Task<Collection?> GetCollection(string id, CancellationToken cancellationToken = default) Task<Collection> GetCollectionAsync(string id, CancellationToken cancellationToken = default) Examples: // Get collection details var collection = await client.GetCollection(\"499830\"); if (collection != null) { Console.WriteLine($\"Collection: {collection.Title}\"); Console.WriteLine($\"Description: {collection.Description}\"); Console.WriteLine($\"Total photos: {collection.TotalPhotos}\"); Console.WriteLine($\"Created by: {collection.User.Name}\"); } // Exception-throwing version try { var collection = await client.GetCollectionAsync(\"499830\"); Console.WriteLine($\"Collection cover: {collection.CoverPhoto.Urls.Regular}\"); } catch (UnsplasharpNotFoundException) { Console.WriteLine(\"Collection not found\"); } ListCollections / ListCollectionsAsync Get a paginated list of all collections. Signatures: Task<List<Collection>> ListCollections(int page = 1, int perPage = 10, CancellationToken cancellationToken = default) Task<List<Collection>> ListCollectionsAsync(...) // Exception-throwing version Examples: // Get featured collections var collections = await client.ListCollections(page: 1, perPage: 20); foreach (var collection in collections) { Console.WriteLine($\"{collection.Title} - {collection.TotalPhotos} photos\"); Console.WriteLine($\" By: {collection.User.Name}\"); Console.WriteLine($\" Cover: {collection.CoverPhoto.Urls.Small}\"); } // Pagination through collections var allCollections = new List<Collection>(); int page = 1; List<Collection> pageResults; do { pageResults = await client.ListCollections(page: page, perPage: 30); allCollections.AddRange(pageResults); page++; } while (pageResults.Count == 30); // Continue while getting full pages GetCollectionPhotos / GetCollectionPhotosAsync Get photos from a specific collection. Signatures: Task<List<Photo>> GetCollectionPhotos(string collectionId, int page = 1, int perPage = 10, CancellationToken cancellationToken = default) Task<List<Photo>> GetCollectionPhotosAsync(...) // Exception-throwing version Examples: // Get photos from a collection var collectionPhotos = await client.GetCollectionPhotos(\"499830\", page: 1, perPage: 25); Console.WriteLine($\"Found {collectionPhotos.Count} photos in collection\"); foreach (var photo in collectionPhotos) { Console.WriteLine($\" {photo.Id}: {photo.Description ?? \"No description\"}\"); Console.WriteLine($\" By: {photo.User.Name}\"); Console.WriteLine($\" Likes: {photo.Likes}, Downloads: {photo.Downloads}\"); } SearchCollections / SearchCollectionsAsync Search for collections by query. Signatures: Task<List<Collection>> SearchCollections(string query, int page = 1, int perPage = 10, CancellationToken cancellationToken = default) Task<List<Collection>> SearchCollectionsAsync(...) // Exception-throwing version Examples: // Search for collections var travelCollections = await client.SearchCollections(\"travel\", page: 1, perPage: 15); Console.WriteLine($\"Found {travelCollections.Count} travel collections\"); foreach (var collection in travelCollections) { Console.WriteLine($\"{collection.Title} ({collection.TotalPhotos} photos)\"); Console.WriteLine($\" {collection.Description}\"); } // Check search metadata Console.WriteLine($\"Search query: {client.LastCollectionsSearchQuery}\"); Console.WriteLine($\"Total results: {client.LastCollectionsSearchTotalResults}\"); Console.WriteLine($\"Total pages: {client.LastCollectionsSearchTotalPages}\"); User Methods GetUser / GetUserAsync Retrieve a user's profile information. Signatures: Task<User?> GetUser(string username, CancellationToken cancellationToken = default) Task<User> GetUserAsync(string username, CancellationToken cancellationToken = default) Examples: // Get user profile var user = await client.GetUser(\"chrisjoelcampbell\"); if (user != null) { Console.WriteLine($\"Name: {user.Name}\"); Console.WriteLine($\"Username: {user.Username}\"); Console.WriteLine($\"Bio: {user.Bio}\"); Console.WriteLine($\"Location: {user.Location}\"); Console.WriteLine($\"Portfolio: {user.PortfolioUrl}\"); Console.WriteLine($\"Total photos: {user.TotalPhotos}\"); Console.WriteLine($\"Total likes: {user.TotalLikes}\"); Console.WriteLine($\"Total collections: {user.TotalCollections}\"); Console.WriteLine($\"Profile image: {user.ProfileImage.Large}\"); } // Exception-throwing version try { var user = await client.GetUserAsync(\"nonexistentuser\"); Console.WriteLine($\"User found: {user.Name}\"); } catch (UnsplasharpNotFoundException) { Console.WriteLine(\"User not found\"); } GetUserPhotos / GetUserPhotosAsync Get photos uploaded by a specific user. Signatures: Task<List<Photo>> GetUserPhotos(string username, int page = 1, int perPage = 10, OrderBy orderBy = OrderBy.Latest, bool stats = false, Resolution resolution = Resolution.All, int quantity = 30, Orientation orientation = Orientation.All, CancellationToken cancellationToken = default) Examples: // Get user's photos var userPhotos = await client.GetUserPhotos(\"chrisjoelcampbell\", page: 1, perPage: 20); Console.WriteLine($\"Photos by user: {userPhotos.Count}\"); foreach (var photo in userPhotos) { Console.WriteLine($\" {photo.Id}: {photo.Description ?? \"Untitled\"}\"); Console.WriteLine($\" Dimensions: {photo.Width}x{photo.Height}\"); Console.WriteLine($\" Likes: {photo.Likes}\"); } // Get user's popular photos var popularPhotos = await client.GetUserPhotos( username: \"chrisjoelcampbell\", orderBy: OrderBy.Popular, perPage: 10 ); // Get user's landscape photos only var landscapePhotos = await client.GetUserPhotos( username: \"chrisjoelcampbell\", orientation: Orientation.Landscape, perPage: 15 ); GetUserLikes / GetUserLikesAsync Get photos liked by a specific user. Signatures: Task<List<Photo>> GetUserLikes(string username, int page = 1, int perPage = 10, OrderBy orderBy = OrderBy.Latest, Orientation orientation = Orientation.All, CancellationToken cancellationToken = default) Examples: // Get user's liked photos var likedPhotos = await client.GetUserLikes(\"chrisjoelcampbell\", page: 1, perPage: 20); Console.WriteLine($\"Photos liked by user: {likedPhotos.Count}\"); foreach (var photo in likedPhotos) { Console.WriteLine($\" {photo.Id} by {photo.User.Name}\"); Console.WriteLine($\" {photo.Description ?? \"No description\"}\"); } GetUserCollections / GetUserCollectionsAsync Get collections created by a specific user. Signatures: Task<List<Collection>> GetUserCollections(string username, int page = 1, int perPage = 10, CancellationToken cancellationToken = default) Examples: // Get user's collections var userCollections = await client.GetUserCollections(\"chrisjoelcampbell\"); Console.WriteLine($\"Collections by user: {userCollections.Count}\"); foreach (var collection in userCollections) { Console.WriteLine($\" {collection.Title} ({collection.TotalPhotos} photos)\"); Console.WriteLine($\" {collection.Description}\"); } Statistics Methods GetTotalStats / GetTotalStatsAsync Get overall Unsplash statistics. Signatures: Task<UnplashTotalStats?> GetTotalStats(CancellationToken cancellationToken = default) Task<UnplashTotalStats> GetTotalStatsAsync(CancellationToken cancellationToken = default) Examples: // Get total platform statistics var totalStats = await client.GetTotalStats(); if (totalStats != null) { Console.WriteLine($\"Total photos: {totalStats.Photos:N0}\"); Console.WriteLine($\"Total downloads: {totalStats.Downloads:N0}\"); Console.WriteLine($\"Total views: {totalStats.Views:N0}\"); Console.WriteLine($\"Total likes: {totalStats.Likes:N0}\"); Console.WriteLine($\"Total photographers: {totalStats.Photographers:N0}\"); Console.WriteLine($\"Total pixels served: {totalStats.PixelsServed:N0}\"); Console.WriteLine($\"Total views this month: {totalStats.ViewsThisMonth:N0}\"); Console.WriteLine($\"Total new photos this month: {totalStats.NewPhotosThisMonth:N0}\"); } GetMonthlyStats / GetMonthlyStatsAsync Get Unsplash statistics for the past 30 days. Signatures: Task<UnplashMonthlyStats?> GetMonthlyStats(CancellationToken cancellationToken = default) Task<UnplashMonthlyStats> GetMonthlyStatsAsync(CancellationToken cancellationToken = default) Examples: // Get monthly statistics var monthlyStats = await client.GetMonthlyStats(); if (monthlyStats != null) { Console.WriteLine($\"Downloads this month: {monthlyStats.Downloads:N0}\"); Console.WriteLine($\"Views this month: {monthlyStats.Views:N0}\"); Console.WriteLine($\"Likes this month: {monthlyStats.Likes:N0}\"); Console.WriteLine($\"New photos this month: {monthlyStats.NewPhotos:N0}\"); Console.WriteLine($\"New photographers this month: {monthlyStats.NewPhotographers:N0}\"); Console.WriteLine($\"New pixels this month: {monthlyStats.NewPixels:N0}\"); Console.WriteLine($\"New developers this month: {monthlyStats.NewDevelopers:N0}\"); Console.WriteLine($\"New applications this month: {monthlyStats.NewApplications:N0}\"); Console.WriteLine($\"New requests this month: {monthlyStats.NewRequests:N0}\"); } Method Parameters Common Parameters Pagination Parameters page (int): Page number to retrieve (1-based indexing). Default: 1 perPage (int): Number of items per page. Default: 10, Maximum: 30 Ordering Parameters orderBy (OrderBy enum): OrderBy.Latest - Most recent first (default) OrderBy.Oldest - Oldest first OrderBy.Popular - Most popular first OrderBy.Relevant - Most relevant (for search queries) Orientation Parameters orientation (Orientation enum): Orientation.All - All orientations (default) Orientation.Landscape - Landscape photos only Orientation.Portrait - Portrait photos only Orientation.Squarish - Square-ish photos only Resolution Parameters resolution (Resolution enum): Resolution.All - All resolutions (default) Resolution.Regular - Regular resolution Resolution.Small - Small resolution Photo-Specific Parameters Custom Sizing Parameters width (int?): Custom width in pixels height (int?): Custom height in pixels cropX (int?): X coordinate for cropping cropY (int?): Y coordinate for cropping cropWidth (int?): Width of crop area cropHeight (int?): Height of crop area Search Filters query (string): Search query string color (string?): Filter by color (\"black_and_white\", \"black\", \"white\", \"yellow\", \"orange\", \"red\", \"purple\", \"magenta\", \"green\", \"teal\", \"blue\") contentFilter (string?): Content safety filter (\"low\", \"high\") collectionIds (string?): Comma-separated collection IDs to search within Random Photo Parameters count (int): Number of random photos to return (1-30) featured (bool): Only featured photos username (string?): Photos from specific user only collectionId (string?): Photos from specific collection only collectionIds (string[]): Photos from multiple collections Return Types Photo Model The Photo class contains comprehensive information about an Unsplash photo: public class Photo { public string Id { get; set; } // Unique photo identifier public string Description { get; set; } // Photo description public string CreatedAt { get; set; } // Creation timestamp public string UpdatedAt { get; set; } // Last update timestamp public int Width { get; set; } // Photo width in pixels public int Height { get; set; } // Photo height in pixels public string Color { get; set; } // Dominant color public string BlurHash { get; set; } // BlurHash placeholder public int Downloads { get; set; } // Download count public int Likes { get; set; } // Like count public bool IsLikedByUser { get; set; } // User like status // Complex properties public Urls Urls { get; set; } // Photo URLs public User User { get; set; } // Photo author public Exif Exif { get; set; } // Camera EXIF data public Location Location { get; set; } // Photo location public PhotoLinks Links { get; set; } // Related links public List<Category> Categories { get; set; } // Photo categories public List<Collection> CurrentUserCollection { get; set; } // User collections } Collection Model The Collection class represents a curated collection of photos: public class Collection { public string Id { get; set; } // Unique collection identifier public string Title { get; set; } // Collection title public string Description { get; set; } // Collection description public string PublishedAt { get; set; } // Publication timestamp public string UpdatedAt { get; set; } // Last update timestamp public int TotalPhotos { get; set; } // Number of photos public bool IsPrivate { get; set; } // Privacy status public string ShareKey { get; set; } // Share key for private collections // Complex properties public Photo CoverPhoto { get; set; } // Collection cover photo public User User { get; set; } // Collection creator public CollectionLinks Links { get; set; } // Related links } User Model The User class contains user profile information: public class User { public string Id { get; set; } // Unique user identifier public string Username { get; set; } // Username public string Name { get; set; } // Display name public string FirstName { get; set; } // First name public string LastName { get; set; } // Last name public string TwitterUsername { get; set; } // Twitter handle public string PortfolioUrl { get; set; } // Portfolio URL public string Bio { get; set; } // User biography public string Location { get; set; } // User location public int TotalLikes { get; set; } // Total likes received public int TotalPhotos { get; set; } // Total photos uploaded public int TotalCollections { get; set; } // Total collections created public bool ForHire { get; set; } // Available for hire // Complex properties public ProfileImage ProfileImage { get; set; } // Profile image URLs public Badge Badge { get; set; } // User badge info public UserLinks Links { get; set; } // Related links } URL Types Different photo sizes are available through the Urls class: public class Urls { public string Raw { get; set; } // Full resolution, uncompressed public string Full { get; set; } // Large size (max 2048px) public string Regular { get; set; } // Medium size (max 1080px) public string Small { get; set; } // Small size (max 400px) public string Thumbnail { get; set; } // Thumbnail (max 200px) public string Custom { get; set; } // Custom size (when specified) } Rate Limiting Rate Limit Information The client automatically tracks rate limit information: var client = new UnsplasharpClient(\"YOUR_APP_ID\"); // Make a request var photo = await client.GetRandomPhoto(); // Check rate limit status Console.WriteLine($\"Rate limit: {client.RateLimitRemaining}/{client.MaxRateLimit}\"); Rate Limit Headers Unsplash provides rate limit information in response headers: X-Ratelimit-Limit: Maximum requests per hour X-Ratelimit-Remaining: Remaining requests in current hour Handling Rate Limits Use the exception-throwing methods for better rate limit handling: try { var photos = await client.SearchPhotosAsync(\"nature\"); } catch (UnsplasharpRateLimitException ex) { Console.WriteLine($\"Rate limit exceeded: {ex.RateLimitRemaining}/{ex.RateLimit}\"); Console.WriteLine($\"Reset time: {ex.RateLimitReset}\"); // Wait until reset or implement exponential backoff if (ex.RateLimitReset.HasValue) { var waitTime = ex.RateLimitReset.Value - DateTimeOffset.UtcNow; await Task.Delay(waitTime); } } Best Practices 1. Use Exception-Throwing Methods For new code, prefer the *Async methods that throw exceptions: // Preferred approach try { var photo = await client.GetPhotoAsync(\"photo-id\"); // Handle success } catch (UnsplasharpNotFoundException) { // Handle not found } catch (UnsplasharpException ex) { // Handle other errors } 2. Implement Proper Error Handling Always handle potential exceptions appropriately: public async Task<Photo?> GetPhotoSafely(string photoId) { try { return await client.GetPhotoAsync(photoId); } catch (UnsplasharpNotFoundException) { logger.LogWarning(\"Photo {PhotoId} not found\", photoId); return null; } catch (UnsplasharpRateLimitException ex) { logger.LogWarning(\"Rate limit exceeded, retry after {ResetTime}\", ex.RateLimitReset); throw; // Re-throw to handle at higher level } catch (UnsplasharpException ex) { logger.LogError(ex, \"Unsplash API error for photo {PhotoId}\", photoId); throw; } } 3. Use Cancellation Tokens Always pass cancellation tokens for better responsiveness: public async Task<List<Photo>> SearchWithTimeout(string query, TimeSpan timeout) { using var cts = new CancellationTokenSource(timeout); try { return await client.SearchPhotosAsync(query, cancellationToken: cts.Token); } catch (OperationCanceledException) { logger.LogWarning(\"Search for '{Query}' timed out after {Timeout}\", query, timeout); return new List<Photo>(); } } 4. Respect Rate Limits Monitor and respect API rate limits: public async Task<List<Photo>> GetPhotosWithRateLimit(List<string> photoIds) { var photos = new List<Photo>(); foreach (var photoId in photoIds) { // Check rate limit before making request if (client.RateLimitRemaining < 10) { logger.LogWarning(\"Rate limit running low, pausing requests\"); await Task.Delay(TimeSpan.FromMinutes(1)); } try { var photo = await client.GetPhotoAsync(photoId); photos.Add(photo); } catch (UnsplasharpRateLimitException) { logger.LogWarning(\"Rate limit exceeded, stopping batch operation\"); break; } } return photos; }"
  },
  "api/Unsplasharp.Exceptions.ErrorContext.html": {
    "href": "api/Unsplasharp.Exceptions.ErrorContext.html",
    "title": "Class ErrorContext | Unsplasharp Documentation",
    "summary": "Class ErrorContext Namespace Unsplasharp.Exceptions Assembly Unsplasharp.dll Contains contextual information about an error for debugging and logging purposes public class ErrorContext Inheritance object ErrorContext Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors ErrorContext(string?, string?) Initializes a new instance of the ErrorContext class public ErrorContext(string? applicationId = null, string? correlationId = null) Parameters applicationId string The application ID correlationId string The correlation ID Properties ApplicationId The application ID used for the request public string? ApplicationId { get; } Property Value string CorrelationId The correlation ID for tracking requests across logs public string? CorrelationId { get; } Property Value string ElapsedTime The total time elapsed for the request (including retries) public TimeSpan? ElapsedTime { get; } Property Value TimeSpan? Properties Additional custom properties for context public Dictionary<string, object> Properties { get; } Property Value Dictionary<string, object> RateLimitInfo The current rate limit information public RateLimitInfo? RateLimitInfo { get; set; } Property Value RateLimitInfo RequestHeaders Request headers sent with the HTTP request public Dictionary<string, string> RequestHeaders { get; } Property Value Dictionary<string, string> ResponseHeaders Response headers received from the HTTP response public Dictionary<string, string> ResponseHeaders { get; } Property Value Dictionary<string, string> RetryAttempts The number of retry attempts made public int RetryAttempts { get; } Property Value int Timestamp The timestamp when the error occurred public DateTimeOffset Timestamp { get; } Property Value DateTimeOffset Methods FromRequest(HttpRequestMessage, string?, string?) Creates an ErrorContext from an HTTP request message public static ErrorContext FromRequest(HttpRequestMessage request, string? applicationId = null, string? correlationId = null) Parameters request HttpRequestMessage The HTTP request message applicationId string The application ID correlationId string The correlation ID Returns ErrorContext A new ErrorContext instance FromResponse(HttpResponseMessage, string?, string?) Creates an ErrorContext from an HTTP response message public static ErrorContext FromResponse(HttpResponseMessage response, string? applicationId = null, string? correlationId = null) Parameters response HttpResponseMessage The HTTP response message applicationId string The application ID correlationId string The correlation ID Returns ErrorContext A new ErrorContext instance GetProperty<T>(string) Gets a property value by key public T? GetProperty<T>(string key) Parameters key string The property key Returns T The property value, or default(T) if not found Type Parameters T The expected type of the property ToSummary() Creates a summary string of the error context for logging public string ToSummary() Returns string A formatted summary string WithElapsedTime(TimeSpan) Sets the elapsed time public ErrorContext WithElapsedTime(TimeSpan elapsed) Parameters elapsed TimeSpan The elapsed time Returns ErrorContext This ErrorContext instance for method chaining WithProperty(string, object) Adds a custom property to the context public ErrorContext WithProperty(string key, object value) Parameters key string The property key value object The property value Returns ErrorContext This ErrorContext instance for method chaining WithRetryAttempts(int) Sets the retry attempts count public ErrorContext WithRetryAttempts(int attempts) Parameters attempts int The number of retry attempts Returns ErrorContext This ErrorContext instance for method chaining"
  },
  "api/Unsplasharp.Exceptions.RateLimitInfo.html": {
    "href": "api/Unsplasharp.Exceptions.RateLimitInfo.html",
    "title": "Class RateLimitInfo | Unsplasharp Documentation",
    "summary": "Class RateLimitInfo Namespace Unsplasharp.Exceptions Assembly Unsplasharp.dll Contains rate limit information extracted from HTTP headers public class RateLimitInfo Inheritance object RateLimitInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors RateLimitInfo(int?, int?, DateTimeOffset?) Initializes a new instance of the RateLimitInfo class public RateLimitInfo(int? limit, int? remaining, DateTimeOffset? reset) Parameters limit int? The rate limit remaining int? The remaining requests reset DateTimeOffset? When the rate limit resets Properties IsExceeded Indicates whether the rate limit has been exceeded public bool IsExceeded { get; } Property Value bool Limit The maximum number of requests allowed per hour public int? Limit { get; } Property Value int? Remaining The number of requests remaining in the current hour public int? Remaining { get; } Property Value int? Reset When the rate limit resets public DateTimeOffset? Reset { get; } Property Value DateTimeOffset? TimeUntilReset Gets the time until the rate limit resets public TimeSpan? TimeUntilReset { get; } Property Value TimeSpan? Methods FromHeaders(HttpResponseHeaders) Extracts rate limit information from HTTP response headers public static RateLimitInfo? FromHeaders(HttpResponseHeaders headers) Parameters headers HttpResponseHeaders The HTTP response headers Returns RateLimitInfo A RateLimitInfo instance, or null if no rate limit headers found"
  },
  "api/Unsplasharp.Exceptions.UnsplasharpAuthenticationException.html": {
    "href": "api/Unsplasharp.Exceptions.UnsplasharpAuthenticationException.html",
    "title": "Class UnsplasharpAuthenticationException | Unsplasharp Documentation",
    "summary": "Class UnsplasharpAuthenticationException Namespace Unsplasharp.Exceptions Assembly Unsplasharp.dll Exception thrown when authentication fails public class UnsplasharpAuthenticationException : UnsplasharpHttpException, ISerializable Inheritance object Exception UnsplasharpException UnsplasharpHttpException UnsplasharpAuthenticationException Implements ISerializable Inherited Members UnsplasharpHttpException.StatusCode UnsplasharpHttpException.ResponseContent UnsplasharpHttpException.IsRetryable UnsplasharpException.FromHttpResponse(HttpResponseMessage, string, string, string) UnsplasharpException.FromHttpRequestException(HttpRequestException, string, string, string, string) UnsplasharpException.FromTaskCanceledException(TaskCanceledException, TimeSpan?, string, string, string, string) UnsplasharpException.FromJsonException(JsonException, string, string, string, string, string, string) UnsplasharpException.RequestUrl UnsplasharpException.HttpMethod UnsplasharpException.Context Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors UnsplasharpAuthenticationException(string, string?, string?, ErrorContext?) Initializes a new instance of the UnsplasharpAuthenticationException class public UnsplasharpAuthenticationException(string message, string? requestUrl, string? httpMethod, ErrorContext? context = null) Parameters message string The error message requestUrl string The request URL httpMethod string The HTTP method context ErrorContext Additional error context"
  },
  "api/Unsplasharp.Exceptions.UnsplasharpException.html": {
    "href": "api/Unsplasharp.Exceptions.UnsplasharpException.html",
    "title": "Class UnsplasharpException | Unsplasharp Documentation",
    "summary": "Class UnsplasharpException Namespace Unsplasharp.Exceptions Assembly Unsplasharp.dll Base exception class for all Unsplasharp-related errors (partial class for factory methods) public abstract class UnsplasharpException : Exception, ISerializable Inheritance object Exception UnsplasharpException Implements ISerializable Derived UnsplasharpHttpException UnsplasharpNetworkException UnsplasharpParsingException Inherited Members Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors UnsplasharpException(string) Initializes a new instance of the UnsplasharpException class protected UnsplasharpException(string message) Parameters message string The error message UnsplasharpException(string, Exception) Initializes a new instance of the UnsplasharpException class protected UnsplasharpException(string message, Exception innerException) Parameters message string The error message innerException Exception The inner exception UnsplasharpException(string, Exception, string?, string?, ErrorContext?) Initializes a new instance of the UnsplasharpException class with context and inner exception protected UnsplasharpException(string message, Exception innerException, string? requestUrl, string? httpMethod, ErrorContext? context = null) Parameters message string The error message innerException Exception The inner exception requestUrl string The request URL httpMethod string The HTTP method context ErrorContext Additional error context UnsplasharpException(string, string?, string?, ErrorContext?) Initializes a new instance of the UnsplasharpException class with context protected UnsplasharpException(string message, string? requestUrl, string? httpMethod, ErrorContext? context = null) Parameters message string The error message requestUrl string The request URL httpMethod string The HTTP method context ErrorContext Additional error context Properties Context Additional context information about the error public ErrorContext? Context { get; } Property Value ErrorContext HttpMethod The HTTP method used for the request public string? HttpMethod { get; } Property Value string RequestUrl The request URL that caused the error public string? RequestUrl { get; } Property Value string Methods FromHttpRequestException(HttpRequestException, string?, string?, string?, string?) Creates an exception from an HttpRequestException public static UnsplasharpNetworkException FromHttpRequestException(HttpRequestException exception, string? requestUrl, string? httpMethod, string? applicationId = null, string? correlationId = null) Parameters exception HttpRequestException The HttpRequestException requestUrl string The request URL httpMethod string The HTTP method applicationId string The application ID correlationId string The correlation ID Returns UnsplasharpNetworkException An UnsplasharpNetworkException FromHttpResponse(HttpResponseMessage, string?, string?, string?) Creates an exception from an HTTP response public static UnsplasharpException FromHttpResponse(HttpResponseMessage response, string? responseContent, string? applicationId = null, string? correlationId = null) Parameters response HttpResponseMessage The HTTP response responseContent string The response content applicationId string The application ID correlationId string The correlation ID Returns UnsplasharpException An appropriate UnsplasharpException FromJsonException(JsonException, string?, string?, string?, string?, string?, string?) Creates an exception from a JsonException public static UnsplasharpParsingException FromJsonException(JsonException exception, string? rawContent, string? expectedType, string? requestUrl, string? httpMethod, string? applicationId = null, string? correlationId = null) Parameters exception JsonException The JsonException rawContent string The raw content that failed to parse expectedType string The expected data type requestUrl string The request URL httpMethod string The HTTP method applicationId string The application ID correlationId string The correlation ID Returns UnsplasharpParsingException An UnsplasharpParsingException FromTaskCanceledException(TaskCanceledException, TimeSpan?, string?, string?, string?, string?) Creates an exception from a TaskCanceledException public static UnsplasharpTimeoutException FromTaskCanceledException(TaskCanceledException exception, TimeSpan? timeout, string? requestUrl, string? httpMethod, string? applicationId = null, string? correlationId = null) Parameters exception TaskCanceledException The TaskCanceledException timeout TimeSpan? The timeout duration requestUrl string The request URL httpMethod string The HTTP method applicationId string The application ID correlationId string The correlation ID Returns UnsplasharpTimeoutException An UnsplasharpTimeoutException"
  },
  "api/Unsplasharp.Exceptions.UnsplasharpHttpException.html": {
    "href": "api/Unsplasharp.Exceptions.UnsplasharpHttpException.html",
    "title": "Class UnsplasharpHttpException | Unsplasharp Documentation",
    "summary": "Class UnsplasharpHttpException Namespace Unsplasharp.Exceptions Assembly Unsplasharp.dll Exception thrown when an HTTP request fails public class UnsplasharpHttpException : UnsplasharpException, ISerializable Inheritance object Exception UnsplasharpException UnsplasharpHttpException Implements ISerializable Derived UnsplasharpAuthenticationException UnsplasharpNotFoundException UnsplasharpRateLimitException Inherited Members UnsplasharpException.FromHttpResponse(HttpResponseMessage, string, string, string) UnsplasharpException.FromHttpRequestException(HttpRequestException, string, string, string, string) UnsplasharpException.FromTaskCanceledException(TaskCanceledException, TimeSpan?, string, string, string, string) UnsplasharpException.FromJsonException(JsonException, string, string, string, string, string, string) UnsplasharpException.RequestUrl UnsplasharpException.HttpMethod UnsplasharpException.Context Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors UnsplasharpHttpException(string, Exception, HttpStatusCode?, string?, string?, string?, bool, ErrorContext?) Initializes a new instance of the UnsplasharpHttpException class with inner exception public UnsplasharpHttpException(string message, Exception innerException, HttpStatusCode? statusCode, string? responseContent, string? requestUrl, string? httpMethod, bool isRetryable = false, ErrorContext? context = null) Parameters message string The error message innerException Exception The inner exception statusCode HttpStatusCode? The HTTP status code responseContent string The response content requestUrl string The request URL httpMethod string The HTTP method isRetryable bool Whether this error is retryable context ErrorContext Additional error context UnsplasharpHttpException(string, HttpStatusCode?, string?, string?, string?, bool, ErrorContext?) Initializes a new instance of the UnsplasharpHttpException class public UnsplasharpHttpException(string message, HttpStatusCode? statusCode, string? responseContent, string? requestUrl, string? httpMethod, bool isRetryable = false, ErrorContext? context = null) Parameters message string The error message statusCode HttpStatusCode? The HTTP status code responseContent string The response content requestUrl string The request URL httpMethod string The HTTP method isRetryable bool Whether this error is retryable context ErrorContext Additional error context Properties IsRetryable Indicates whether this error is retryable public bool IsRetryable { get; } Property Value bool ResponseContent The response content from the API public string? ResponseContent { get; } Property Value string StatusCode The HTTP status code returned by the API public HttpStatusCode? StatusCode { get; } Property Value HttpStatusCode?"
  },
  "api/Unsplasharp.Exceptions.UnsplasharpNetworkException.html": {
    "href": "api/Unsplasharp.Exceptions.UnsplasharpNetworkException.html",
    "title": "Class UnsplasharpNetworkException | Unsplasharp Documentation",
    "summary": "Class UnsplasharpNetworkException Namespace Unsplasharp.Exceptions Assembly Unsplasharp.dll Exception thrown when a network error occurs public class UnsplasharpNetworkException : UnsplasharpException, ISerializable Inheritance object Exception UnsplasharpException UnsplasharpNetworkException Implements ISerializable Derived UnsplasharpTimeoutException Inherited Members UnsplasharpException.FromHttpResponse(HttpResponseMessage, string, string, string) UnsplasharpException.FromHttpRequestException(HttpRequestException, string, string, string, string) UnsplasharpException.FromTaskCanceledException(TaskCanceledException, TimeSpan?, string, string, string, string) UnsplasharpException.FromJsonException(JsonException, string, string, string, string, string, string) UnsplasharpException.RequestUrl UnsplasharpException.HttpMethod UnsplasharpException.Context Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors UnsplasharpNetworkException(string, Exception, string?, string?, bool, ErrorContext?) Initializes a new instance of the UnsplasharpNetworkException class public UnsplasharpNetworkException(string message, Exception innerException, string? requestUrl, string? httpMethod, bool isRetryable = true, ErrorContext? context = null) Parameters message string The error message innerException Exception The inner exception requestUrl string The request URL httpMethod string The HTTP method isRetryable bool Whether this error is retryable context ErrorContext Additional error context Properties IsRetryable Indicates whether this error is retryable public bool IsRetryable { get; } Property Value bool"
  },
  "api/Unsplasharp.Exceptions.UnsplasharpNotFoundException.html": {
    "href": "api/Unsplasharp.Exceptions.UnsplasharpNotFoundException.html",
    "title": "Class UnsplasharpNotFoundException | Unsplasharp Documentation",
    "summary": "Class UnsplasharpNotFoundException Namespace Unsplasharp.Exceptions Assembly Unsplasharp.dll Exception thrown when a requested resource is not found public class UnsplasharpNotFoundException : UnsplasharpHttpException, ISerializable Inheritance object Exception UnsplasharpException UnsplasharpHttpException UnsplasharpNotFoundException Implements ISerializable Inherited Members UnsplasharpHttpException.StatusCode UnsplasharpHttpException.ResponseContent UnsplasharpHttpException.IsRetryable UnsplasharpException.FromHttpResponse(HttpResponseMessage, string, string, string) UnsplasharpException.FromHttpRequestException(HttpRequestException, string, string, string, string) UnsplasharpException.FromTaskCanceledException(TaskCanceledException, TimeSpan?, string, string, string, string) UnsplasharpException.FromJsonException(JsonException, string, string, string, string, string, string) UnsplasharpException.RequestUrl UnsplasharpException.HttpMethod UnsplasharpException.Context Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors UnsplasharpNotFoundException(string, string?, string?, string?, string?, ErrorContext?) Initializes a new instance of the UnsplasharpNotFoundException class public UnsplasharpNotFoundException(string message, string? resourceId, string? resourceType, string? requestUrl, string? httpMethod, ErrorContext? context = null) Parameters message string The error message resourceId string The resource identifier resourceType string The resource type requestUrl string The request URL httpMethod string The HTTP method context ErrorContext Additional error context Properties ResourceId The resource identifier that was not found public string? ResourceId { get; } Property Value string ResourceType The type of resource that was not found public string? ResourceType { get; } Property Value string"
  },
  "api/Unsplasharp.Exceptions.UnsplasharpParsingException.html": {
    "href": "api/Unsplasharp.Exceptions.UnsplasharpParsingException.html",
    "title": "Class UnsplasharpParsingException | Unsplasharp Documentation",
    "summary": "Class UnsplasharpParsingException Namespace Unsplasharp.Exceptions Assembly Unsplasharp.dll Exception thrown when JSON parsing fails public class UnsplasharpParsingException : UnsplasharpException, ISerializable Inheritance object Exception UnsplasharpException UnsplasharpParsingException Implements ISerializable Inherited Members UnsplasharpException.FromHttpResponse(HttpResponseMessage, string, string, string) UnsplasharpException.FromHttpRequestException(HttpRequestException, string, string, string, string) UnsplasharpException.FromTaskCanceledException(TaskCanceledException, TimeSpan?, string, string, string, string) UnsplasharpException.FromJsonException(JsonException, string, string, string, string, string, string) UnsplasharpException.RequestUrl UnsplasharpException.HttpMethod UnsplasharpException.Context Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors UnsplasharpParsingException(string, Exception, string?, string?, string?, string?, ErrorContext?) Initializes a new instance of the UnsplasharpParsingException class public UnsplasharpParsingException(string message, Exception innerException, string? rawContent, string? expectedType, string? requestUrl, string? httpMethod, ErrorContext? context = null) Parameters message string The error message innerException Exception The inner exception rawContent string The raw content that failed to parse expectedType string The expected data type requestUrl string The request URL httpMethod string The HTTP method context ErrorContext Additional error context Properties ExpectedType The expected data type public string? ExpectedType { get; } Property Value string RawContent The raw response content that failed to parse public string? RawContent { get; } Property Value string"
  },
  "api/Unsplasharp.Exceptions.UnsplasharpRateLimitException.html": {
    "href": "api/Unsplasharp.Exceptions.UnsplasharpRateLimitException.html",
    "title": "Class UnsplasharpRateLimitException | Unsplasharp Documentation",
    "summary": "Class UnsplasharpRateLimitException Namespace Unsplasharp.Exceptions Assembly Unsplasharp.dll Exception thrown when the API rate limit is exceeded public class UnsplasharpRateLimitException : UnsplasharpHttpException, ISerializable Inheritance object Exception UnsplasharpException UnsplasharpHttpException UnsplasharpRateLimitException Implements ISerializable Inherited Members UnsplasharpHttpException.StatusCode UnsplasharpHttpException.ResponseContent UnsplasharpHttpException.IsRetryable UnsplasharpException.FromHttpResponse(HttpResponseMessage, string, string, string) UnsplasharpException.FromHttpRequestException(HttpRequestException, string, string, string, string) UnsplasharpException.FromTaskCanceledException(TaskCanceledException, TimeSpan?, string, string, string, string) UnsplasharpException.FromJsonException(JsonException, string, string, string, string, string, string) UnsplasharpException.RequestUrl UnsplasharpException.HttpMethod UnsplasharpException.Context Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors UnsplasharpRateLimitException(string, int?, int?, DateTimeOffset?, string?, string?, ErrorContext?) Initializes a new instance of the UnsplasharpRateLimitException class public UnsplasharpRateLimitException(string message, int? rateLimit, int? rateLimitRemaining, DateTimeOffset? rateLimitReset, string? requestUrl, string? httpMethod, ErrorContext? context = null) Parameters message string The error message rateLimit int? The current rate limit rateLimitRemaining int? The remaining requests rateLimitReset DateTimeOffset? When the rate limit resets requestUrl string The request URL httpMethod string The HTTP method context ErrorContext Additional error context Properties RateLimit The current rate limit public int? RateLimit { get; } Property Value int? RateLimitRemaining The remaining requests in the current window public int? RateLimitRemaining { get; } Property Value int? RateLimitReset When the rate limit resets (Unix timestamp) public DateTimeOffset? RateLimitReset { get; } Property Value DateTimeOffset?"
  },
  "api/Unsplasharp.Exceptions.UnsplasharpTimeoutException.html": {
    "href": "api/Unsplasharp.Exceptions.UnsplasharpTimeoutException.html",
    "title": "Class UnsplasharpTimeoutException | Unsplasharp Documentation",
    "summary": "Class UnsplasharpTimeoutException Namespace Unsplasharp.Exceptions Assembly Unsplasharp.dll Exception thrown when a request times out public class UnsplasharpTimeoutException : UnsplasharpNetworkException, ISerializable Inheritance object Exception UnsplasharpException UnsplasharpNetworkException UnsplasharpTimeoutException Implements ISerializable Inherited Members UnsplasharpNetworkException.IsRetryable UnsplasharpException.FromHttpResponse(HttpResponseMessage, string, string, string) UnsplasharpException.FromHttpRequestException(HttpRequestException, string, string, string, string) UnsplasharpException.FromTaskCanceledException(TaskCanceledException, TimeSpan?, string, string, string, string) UnsplasharpException.FromJsonException(JsonException, string, string, string, string, string, string) UnsplasharpException.RequestUrl UnsplasharpException.HttpMethod UnsplasharpException.Context Exception.GetBaseException() Exception.GetObjectData(SerializationInfo, StreamingContext) Exception.GetType() Exception.ToString() Exception.Data Exception.HelpLink Exception.HResult Exception.InnerException Exception.Message Exception.Source Exception.StackTrace Exception.TargetSite Exception.SerializeObjectState object.Equals(object) object.Equals(object, object) object.GetHashCode() object.MemberwiseClone() object.ReferenceEquals(object, object) Constructors UnsplasharpTimeoutException(string, Exception, TimeSpan?, string?, string?, ErrorContext?) Initializes a new instance of the UnsplasharpTimeoutException class public UnsplasharpTimeoutException(string message, Exception innerException, TimeSpan? timeout, string? requestUrl, string? httpMethod, ErrorContext? context = null) Parameters message string The error message innerException Exception The inner exception timeout TimeSpan? The timeout duration requestUrl string The request URL httpMethod string The HTTP method context ErrorContext Additional error context Properties Timeout The timeout duration public TimeSpan? Timeout { get; } Property Value TimeSpan?"
  },
  "api/Unsplasharp.Exceptions.html": {
    "href": "api/Unsplasharp.Exceptions.html",
    "title": "Namespace Unsplasharp.Exceptions | Unsplasharp Documentation",
    "summary": "Namespace Unsplasharp.Exceptions Classes ErrorContext Contains contextual information about an error for debugging and logging purposes RateLimitInfo Contains rate limit information extracted from HTTP headers UnsplasharpAuthenticationException Exception thrown when authentication fails UnsplasharpException Base exception class for all Unsplasharp-related errors (partial class for factory methods) UnsplasharpHttpException Exception thrown when an HTTP request fails UnsplasharpNetworkException Exception thrown when a network error occurs UnsplasharpNotFoundException Exception thrown when a requested resource is not found UnsplasharpParsingException Exception thrown when JSON parsing fails UnsplasharpRateLimitException Exception thrown when the API rate limit is exceeded UnsplasharpTimeoutException Exception thrown when a request times out"
  },
  "api/Unsplasharp.Extensions.ServiceCollectionExtensions.html": {
    "href": "api/Unsplasharp.Extensions.ServiceCollectionExtensions.html",
    "title": "Class ServiceCollectionExtensions | Unsplasharp Documentation",
    "summary": "Class ServiceCollectionExtensions Namespace Unsplasharp.Extensions Assembly Unsplasharp.dll Extension methods for configuring Unsplasharp with IServiceCollection public static class ServiceCollectionExtensions Inheritance object ServiceCollectionExtensions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Methods AddUnsplasharp(IServiceCollection, Action<UnsplasharpOptions>) Adds Unsplasharp client to the service collection with custom configuration public static IServiceCollection AddUnsplasharp(this IServiceCollection services, Action<UnsplasharpOptions> configure) Parameters services IServiceCollection The service collection configure Action<UnsplasharpOptions> Configuration action Returns IServiceCollection The service collection for chaining AddUnsplasharp(IServiceCollection, string, string?, Action<HttpClient>?) Adds Unsplasharp client to the service collection with IHttpClientFactory support public static IServiceCollection AddUnsplasharp(this IServiceCollection services, string applicationId, string? secret = null, Action<HttpClient>? configureHttpClient = null) Parameters services IServiceCollection The service collection applicationId string Unsplash application ID secret string Optional secret for authenticated requests configureHttpClient Action<HttpClient> Optional action to configure the HttpClient Returns IServiceCollection The service collection for chaining"
  },
  "api/Unsplasharp.Extensions.UnsplasharpOptions.html": {
    "href": "api/Unsplasharp.Extensions.UnsplasharpOptions.html",
    "title": "Class UnsplasharpOptions | Unsplasharp Documentation",
    "summary": "Class UnsplasharpOptions Namespace Unsplasharp.Extensions Assembly Unsplasharp.dll Configuration options for Unsplasharp public class UnsplasharpOptions Inheritance object UnsplasharpOptions Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties ApplicationId Unsplash application ID (required) public string ApplicationId { get; set; } Property Value string ConfigureHttpClient Optional action to configure the HttpClient public Action<HttpClient>? ConfigureHttpClient { get; set; } Property Value Action<HttpClient> Secret Optional secret for authenticated requests public string? Secret { get; set; } Property Value string"
  },
  "api/Unsplasharp.Extensions.html": {
    "href": "api/Unsplasharp.Extensions.html",
    "title": "Namespace Unsplasharp.Extensions | Unsplasharp Documentation",
    "summary": "Namespace Unsplasharp.Extensions Classes ServiceCollectionExtensions Extension methods for configuring Unsplasharp with IServiceCollection UnsplasharpOptions Configuration options for Unsplasharp"
  },
  "api/Unsplasharp.Models.Badge.html": {
    "href": "api/Unsplasharp.Models.Badge.html",
    "title": "Class Badge | Unsplasharp Documentation",
    "summary": "Class Badge Namespace Unsplasharp.Models Assembly Unsplasharp.dll Badge (a user specific role). public class Badge Inheritance object Badge Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Link Badge's page's link. public string Link { get; set; } Property Value string Primary True if it's the primary badge. public bool Primary { get; set; } Property Value bool Slug Badge's description. public string Slug { get; set; } Property Value string Title Badge's title (e.g. book contributor). public string Title { get; set; } Property Value string"
  },
  "api/Unsplasharp.Models.Category.html": {
    "href": "api/Unsplasharp.Models.Category.html",
    "title": "Class Category | Unsplasharp Documentation",
    "summary": "Class Category Namespace Unsplasharp.Models Assembly Unsplasharp.dll Photo's category. public class Category Inheritance object Category Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Id Category's identifier. public string Id { get; set; } Property Value string Links Category's links. public CategoryLinks Links { get; set; } Property Value CategoryLinks PhotoCount Number of photos in this category. public int PhotoCount { get; set; } Property Value int Title Category's title. public string Title { get; set; } Property Value string"
  },
  "api/Unsplasharp.Models.CategoryLinks.html": {
    "href": "api/Unsplasharp.Models.CategoryLinks.html",
    "title": "Class CategoryLinks | Unsplasharp Documentation",
    "summary": "Class CategoryLinks Namespace Unsplasharp.Models Assembly Unsplasharp.dll Photo's link to its categories. public class CategoryLinks Inheritance object CategoryLinks Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Photos Link to all photos in this category. public string Photos { get; set; } Property Value string Self Link of this category. public string Self { get; set; } Property Value string"
  },
  "api/Unsplasharp.Models.Collection.html": {
    "href": "api/Unsplasharp.Models.Collection.html",
    "title": "Class Collection | Unsplasharp Documentation",
    "summary": "Class Collection Namespace Unsplasharp.Models Assembly Unsplasharp.dll Represents a collection of photos. public class Collection : INotifyPropertyChanged Inheritance object Collection Implements INotifyPropertyChanged Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties CoverPhoto Collection's cover photo. public Photo CoverPhoto { get; set; } Property Value Photo Description Collection description. public string Description { get; set; } Property Value string Id Collection identifier. public string Id { get; set; } Property Value string IsCurated True if the collection is curated. public bool IsCurated { get; set; } Property Value bool IsFeatured True if the collection is featured. public bool IsFeatured { get; set; } Property Value bool IsPrivate True if the collection is private (not publicly visible). public bool IsPrivate { get; set; } Property Value bool Links Collection links. public CollectionLinks Links { get; set; } Property Value CollectionLinks PublishedAt Collection publication's date. public string PublishedAt { get; set; } Property Value string ShareKey Collection's share key. public string ShareKey { get; set; } Property Value string Title Collection's title. public string Title { get; set; } Property Value string TotalPhotos Photos count in the collection. public int TotalPhotos { get; set; } Property Value int UpdatedAt Collection's last update's date. public string UpdatedAt { get; set; } Property Value string User Collection's user. public User User { get; set; } Property Value User Events PropertyChanged Event raised when a property is modified public event PropertyChangedEventHandler? PropertyChanged Event Type PropertyChangedEventHandler"
  },
  "api/Unsplasharp.Models.CollectionLinks.html": {
    "href": "api/Unsplasharp.Models.CollectionLinks.html",
    "title": "Class CollectionLinks | Unsplasharp Documentation",
    "summary": "Class CollectionLinks Namespace Unsplasharp.Models Assembly Unsplasharp.dll Collection's link. public class CollectionLinks Inheritance object CollectionLinks Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Html HTML location of this collection. public string Html { get; set; } Property Value string Photos Photo's link in this collection. public string Photos { get; set; } Property Value string Related Link of related collection's. public string Related { get; set; } Property Value string Self Link of this collection. public string Self { get; set; } Property Value string"
  },
  "api/Unsplasharp.Models.Exif.html": {
    "href": "api/Unsplasharp.Models.Exif.html",
    "title": "Class Exif | Unsplasharp Documentation",
    "summary": "Class Exif Namespace Unsplasharp.Models Assembly Unsplasharp.dll Camera specifications. public class Exif Inheritance object Exif Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Aperture Camera’s aperture value. public string Aperture { get; set; } Property Value string ExposureTime Camera’s exposure time. public string ExposureTime { get; set; } Property Value string FocalLength Camera’s focal length. public string FocalLength { get; set; } Property Value string Iso Camera’s iso. public int? Iso { get; set; } Property Value int? Make Camera’s brand. public string Make { get; set; } Property Value string Model Camera’s model. public string Model { get; set; } Property Value string"
  },
  "api/Unsplasharp.Models.Location.html": {
    "href": "api/Unsplasharp.Models.Location.html",
    "title": "Class Location | Unsplasharp Documentation",
    "summary": "Class Location Namespace Unsplasharp.Models Assembly Unsplasharp.dll The photo's location. public class Location Inheritance object Location Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties City Location’s city. public string City { get; set; } Property Value string Country Location’s country. public string Country { get; set; } Property Value string Name Location's name public string Name { get; set; } Property Value string Position Location’s position (latitude, longitude). public Position Position { get; set; } Property Value Position Title Full location's name (district + city + country (if available)) public string Title { get; set; } Property Value string"
  },
  "api/Unsplasharp.Models.Photo.html": {
    "href": "api/Unsplasharp.Models.Photo.html",
    "title": "Class Photo | Unsplasharp Documentation",
    "summary": "Class Photo Namespace Unsplasharp.Models Assembly Unsplasharp.dll Represents a photo class from Unsplash API. public class Photo : INotifyPropertyChanged Inheritance object Photo Implements INotifyPropertyChanged Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties BlurHash BlurHash Placeholders public string BlurHash { get; set; } Property Value string Categories Photo's matched categories. public List<Category> Categories { get; set; } Property Value List<Category> Color The main color composing the photo. public string Color { get; set; } Property Value string CreatedAt Date indicating when the photo has been created. [JsonPropertyName(\"created_at\")] public string CreatedAt { get; set; } Property Value string CurrentUserCollection The photo's collection where the photo is included, if any. public List<Collection> CurrentUserCollection { get; set; } Property Value List<Collection> Description Photo's description [JsonPropertyName(\"description\")] public string Description { get; set; } Property Value string Downloads Downloads count since the photo was created. public int Downloads { get; set; } Property Value int Exif Camera specifications. public Exif Exif { get; set; } Property Value Exif Height Photo's height in pixels. public int Height { get; set; } Property Value int Id Photo's unique identifier composed of Unicode characters. [JsonPropertyName(\"id\")] public string Id { get; set; } Property Value string IsLikedByUser Whether the photo has been liked by the current user if a user is logged. public bool IsLikedByUser { get; set; } Property Value bool Likes Likes count since the photo was created. public int Likes { get; set; } Property Value int Links Photo's link relations public PhotoLinks Links { get; set; } Property Value PhotoLinks Location Where the photo has been shot. public Location Location { get; set; } Property Value Location UpdatedAt Date indicating the last time the photo has been updated. public string UpdatedAt { get; set; } Property Value string Urls Absolute photo's URLs (for different photo's sizes). public Urls Urls { get; set; } Property Value Urls User Photo's owner (who's uploaded the content). public User User { get; set; } Property Value User Width Photo's width in pixels. public int Width { get; set; } Property Value int Events PropertyChanged Event raised when a property is modified public event PropertyChangedEventHandler? PropertyChanged Event Type PropertyChangedEventHandler"
  },
  "api/Unsplasharp.Models.PhotoLinks.html": {
    "href": "api/Unsplasharp.Models.PhotoLinks.html",
    "title": "Class PhotoLinks | Unsplasharp Documentation",
    "summary": "Class PhotoLinks Namespace Unsplasharp.Models Assembly Unsplasharp.dll Photo's link relations. public class PhotoLinks Inheritance object PhotoLinks Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Download Download location of this photo. public string Download { get; set; } Property Value string DownloadLocation API Download location of this photo (check if direct download). public string DownloadLocation { get; set; } Property Value string Html HTML location of this photo. public string Html { get; set; } Property Value string Self API location of this photo. public string Self { get; set; } Property Value string"
  },
  "api/Unsplasharp.Models.PhotoStats.html": {
    "href": "api/Unsplasharp.Models.PhotoStats.html",
    "title": "Class PhotoStats | Unsplasharp Documentation",
    "summary": "Class PhotoStats Namespace Unsplasharp.Models Assembly Unsplasharp.dll Photo's statistics. public class PhotoStats Inheritance object PhotoStats Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Downloads Photo's downloads statistics. public StatsData Downloads { get; set; } Property Value StatsData Id Photo's statistics id. public string Id { get; set; } Property Value string Likes Photo's likes statistics. public StatsData Likes { get; set; } Property Value StatsData Views Photo's views statistics. public StatsData Views { get; set; } Property Value StatsData"
  },
  "api/Unsplasharp.Models.Position.html": {
    "href": "api/Unsplasharp.Models.Position.html",
    "title": "Class Position | Unsplasharp Documentation",
    "summary": "Class Position Namespace Unsplasharp.Models Assembly Unsplasharp.dll Represents a geographical position (latitude, longitude). public class Position Inheritance object Position Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Latitude Geographical latitude. public int Latitude { get; set; } Property Value int Longitude Geographical longitude. public int Longitude { get; set; } Property Value int"
  },
  "api/Unsplasharp.Models.ProfileImage.html": {
    "href": "api/Unsplasharp.Models.ProfileImage.html",
    "title": "Class ProfileImage | Unsplasharp Documentation",
    "summary": "Class ProfileImage Namespace Unsplasharp.Models Assembly Unsplasharp.dll Profile image at different sizes. public class ProfileImage Inheritance object ProfileImage Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Large Large size profile image. public string Large { get; set; } Property Value string Medium Medium size profile image. public string Medium { get; set; } Property Value string Small Small size profile image. public string Small { get; set; } Property Value string"
  },
  "api/Unsplasharp.Models.StatsData.html": {
    "href": "api/Unsplasharp.Models.StatsData.html",
    "title": "Class StatsData | Unsplasharp Documentation",
    "summary": "Class StatsData Namespace Unsplasharp.Models Assembly Unsplasharp.dll Data statistics. public class StatsData Inheritance object StatsData Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Historical Stat's history. public StatsHistorical Historical { get; set; } Property Value StatsHistorical Total Total count of a specific stat. public int Total { get; set; } Property Value int"
  },
  "api/Unsplasharp.Models.StatsHistorical.html": {
    "href": "api/Unsplasharp.Models.StatsHistorical.html",
    "title": "Class StatsHistorical | Unsplasharp Documentation",
    "summary": "Class StatsHistorical Namespace Unsplasharp.Models Assembly Unsplasharp.dll Stat's history. public class StatsHistorical Inheritance object StatsHistorical Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Average Average number of stat for the past 'quantity' 'resolution' (eg. 30 days). public int Average { get; set; } Property Value int Change Total number of stat for the past 'quantity' 'resolution' (eg. 30 days). public double Change { get; set; } Property Value double Quantity The amount of for each stat. public int Quantity { get; set; } Property Value int Resolution The frequency of the stats. public string Resolution { get; set; } Property Value string Values List of data sets. public List<StatsValue> Values { get; set; } Property Value List<StatsValue>"
  },
  "api/Unsplasharp.Models.StatsValue.html": {
    "href": "api/Unsplasharp.Models.StatsValue.html",
    "title": "Class StatsValue | Unsplasharp Documentation",
    "summary": "Class StatsValue Namespace Unsplasharp.Models Assembly Unsplasharp.dll A data set. public class StatsValue Inheritance object StatsValue Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Date Stat's date. public string Date { get; set; } Property Value string Value Stat's value. public double Value { get; set; } Property Value double"
  },
  "api/Unsplasharp.Models.UnplashMonthlyStats.html": {
    "href": "api/Unsplasharp.Models.UnplashMonthlyStats.html",
    "title": "Class UnplashMonthlyStats | Unsplasharp Documentation",
    "summary": "Class UnplashMonthlyStats Namespace Unsplasharp.Models Assembly Unsplasharp.dll Unsplash statistics counts for the past 30 days. public class UnplashMonthlyStats Inheritance object UnplashMonthlyStats Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Downloads Past 30 days downloads count. public double Downloads { get; set; } Property Value double Likes Past 30 days likes count. public double Likes { get; set; } Property Value double NewApplications Past 30 days new applications count. public int NewApplications { get; set; } Property Value int NewDevelopers Past 30 days new developers count. public int NewDevelopers { get; set; } Property Value int NewPhotographers Past 30 days new photographers count. public double NewPhotographers { get; set; } Property Value double NewPhotos Past 30 days new photos count. public double NewPhotos { get; set; } Property Value double NewPixels Past 30 days new pixels count. public double NewPixels { get; set; } Property Value double NewRequests Past 30 days new requests count. public double NewRequests { get; set; } Property Value double Views Past 30 days views count. public double Views { get; set; } Property Value double"
  },
  "api/Unsplasharp.Models.UnplashTotalStats.html": {
    "href": "api/Unsplasharp.Models.UnplashTotalStats.html",
    "title": "Class UnplashTotalStats | Unsplasharp Documentation",
    "summary": "Class UnplashTotalStats Namespace Unsplasharp.Models Assembly Unsplasharp.dll Unsplash statistics counts. public class UnplashTotalStats Inheritance object UnplashTotalStats Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Applications All applications. public int Applications { get; set; } Property Value int Developers All developeres. public int Developers { get; set; } Property Value int Downloads All photos downloads. public double Downloads { get; set; } Property Value double DownloadsPerSecond Average number of downloads per second for the past 7 days. public double DownloadsPerSecond { get; set; } Property Value double Likes All photos likes. public double Likes { get; set; } Property Value double Photographers All photographers. public double Photographers { get; set; } Property Value double Photos All available photos. public double Photos { get; set; } Property Value double Pixels All pixels. public double Pixels { get; set; } Property Value double Requests All requests. public double Requests { get; set; } Property Value double Views All photos views. public double Views { get; set; } Property Value double ViewsPerSecond Average number of views per second for the past 7 days. public double ViewsPerSecond { get; set; } Property Value double"
  },
  "api/Unsplasharp.Models.Urls.html": {
    "href": "api/Unsplasharp.Models.Urls.html",
    "title": "Class Urls | Unsplasharp Documentation",
    "summary": "Class Urls Namespace Unsplasharp.Models Assembly Unsplasharp.dll Photo's URLs linking to the direct photo (full screen). public class Urls Inheritance object Urls Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Custom URL linking to the photo in a custom size if specified by the user. public string Custom { get; set; } Property Value string Full URL linking to the photo in a large size. public string Full { get; set; } Property Value string Raw URL linking to the photo in native resolution and uncompressed. public string Raw { get; set; } Property Value string Regular URL linking to the photo in a medium size. public string Regular { get; set; } Property Value string Small URL linking to the photo in a small size. public string Small { get; set; } Property Value string Thumbnail URL linking to the photo in a thumbnail size. public string Thumbnail { get; set; } Property Value string"
  },
  "api/Unsplasharp.Models.User.html": {
    "href": "api/Unsplasharp.Models.User.html",
    "title": "Class User | Unsplasharp Documentation",
    "summary": "Class User Namespace Unsplasharp.Models Assembly Unsplasharp.dll Represents an user class from Unplash API. public class User : INotifyPropertyChanged Inheritance object User Implements INotifyPropertyChanged Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Badge User's badge public Badge Badge { get; set; } Property Value Badge Bio About/bio. public string Bio { get; set; } Property Value string Downloads Downloads count public int Downloads { get; set; } Property Value int FirstName User's first name. public string FirstName { get; set; } Property Value string FollowedByUser True if the current authentified user follows this user public bool FollowedByUser { get; set; } Property Value bool FollowersCount User dollwers count public int FollowersCount { get; set; } Property Value int FollowingCount Users following count public int FollowingCount { get; set; } Property Value int Id Unique user's identifer public string Id { get; set; } Property Value string LastName User's last name. public string LastName { get; set; } Property Value string Links User's link relations public UserLinks Links { get; set; } Property Value UserLinks Location User's location public string Location { get; set; } Property Value string Name User's name public string Name { get; set; } Property Value string PortfolioUrl Portfolio/personal URL. public string PortfolioUrl { get; set; } Property Value string ProfileImage User's avatar public ProfileImage ProfileImage { get; set; } Property Value ProfileImage TotalCollections User's collections count public int TotalCollections { get; set; } Property Value int TotalLikes User's liked photos count public int TotalLikes { get; set; } Property Value int TotalPhotos User's photo count public int TotalPhotos { get; set; } Property Value int TwitterUsername User's twitter username public string TwitterUsername { get; set; } Property Value string UpdatedAt Last user profile update public string UpdatedAt { get; set; } Property Value string Username User's name public string Username { get; set; } Property Value string Events PropertyChanged Event raised when a property is modified public event PropertyChangedEventHandler? PropertyChanged Event Type PropertyChangedEventHandler"
  },
  "api/Unsplasharp.Models.UserLinks.html": {
    "href": "api/Unsplasharp.Models.UserLinks.html",
    "title": "Class UserLinks | Unsplasharp Documentation",
    "summary": "Class UserLinks Namespace Unsplasharp.Models Assembly Unsplasharp.dll User's link relations. public class UserLinks Inheritance object UserLinks Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Html HTML location of this user. public string Html { get; set; } Property Value string Likes API location of this user's liked photo. public string Likes { get; set; } Property Value string Photos API location of this user's photo. public string Photos { get; set; } Property Value string Portfolio API location of this user's portfolio. public string Portfolio { get; set; } Property Value string Self API location of this user. public string Self { get; set; } Property Value string"
  },
  "api/Unsplasharp.Models.UserStats.html": {
    "href": "api/Unsplasharp.Models.UserStats.html",
    "title": "Class UserStats | Unsplasharp Documentation",
    "summary": "Class UserStats Namespace Unsplasharp.Models Assembly Unsplasharp.dll User's statistics. public class UserStats Inheritance object UserStats Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Properties Downloads User's downloads statistics. public StatsData Downloads { get; set; } Property Value StatsData Likes User's likes statistics. public StatsData Likes { get; set; } Property Value StatsData Username User's username. public string Username { get; set; } Property Value string Views User's views statistics. public StatsData Views { get; set; } Property Value StatsData"
  },
  "api/Unsplasharp.Models.html": {
    "href": "api/Unsplasharp.Models.html",
    "title": "Namespace Unsplasharp.Models | Unsplasharp Documentation",
    "summary": "Namespace Unsplasharp.Models Classes Badge Badge (a user specific role). Category Photo's category. CategoryLinks Photo's link to its categories. Collection Represents a collection of photos. CollectionLinks Collection's link. Exif Camera specifications. Location The photo's location. Photo Represents a photo class from Unsplash API. PhotoLinks Photo's link relations. PhotoStats Photo's statistics. Position Represents a geographical position (latitude, longitude). ProfileImage Profile image at different sizes. StatsData Data statistics. StatsHistorical Stat's history. StatsValue A data set. UnplashMonthlyStats Unsplash statistics counts for the past 30 days. UnplashTotalStats Unsplash statistics counts. Urls Photo's URLs linking to the direct photo (full screen). User Represents an user class from Unplash API. UserLinks User's link relations. UserStats User's statistics."
  },
  "api/Unsplasharp.UnsplasharpClient.OrderBy.html": {
    "href": "api/Unsplasharp.UnsplasharpClient.OrderBy.html",
    "title": "Enum UnsplasharpClient.OrderBy | Unsplasharp Documentation",
    "summary": "Enum UnsplasharpClient.OrderBy Namespace Unsplasharp Assembly Unsplasharp.dll How to sort the data. public enum UnsplasharpClient.OrderBy Fields Latest = 0 Sort the data from the most recent to the oldest. Oldest = 1 Sort the data from the the oldest to the most recent. Popular = 2 Sort the data from the most popular to the least."
  },
  "api/Unsplasharp.UnsplasharpClient.Orientation.html": {
    "href": "api/Unsplasharp.UnsplasharpClient.Orientation.html",
    "title": "Enum UnsplasharpClient.Orientation | Unsplasharp Documentation",
    "summary": "Enum UnsplasharpClient.Orientation Namespace Unsplasharp Assembly Unsplasharp.dll Photo orientation. public enum UnsplasharpClient.Orientation Fields Landscape = 0 Landscape orientation. Portrait = 1 Portrait orientation. Squarish = 2 Squarish orientation."
  },
  "api/Unsplasharp.UnsplasharpClient.Resolution.html": {
    "href": "api/Unsplasharp.UnsplasharpClient.Resolution.html",
    "title": "Enum UnsplasharpClient.Resolution | Unsplasharp Documentation",
    "summary": "Enum UnsplasharpClient.Resolution Namespace Unsplasharp Assembly Unsplasharp.dll The frequency of the stats. public enum UnsplasharpClient.Resolution Fields Days = 0 Stats for each day."
  },
  "api/Unsplasharp.UnsplasharpClient.html": {
    "href": "api/Unsplasharp.UnsplasharpClient.html",
    "title": "Class UnsplasharpClient | Unsplasharp Documentation",
    "summary": "Class UnsplasharpClient Namespace Unsplasharp Assembly Unsplasharp.dll Represents a Unsplasharp class which can be used to communicate with Unplash APIs. public class UnsplasharpClient Inheritance object UnsplasharpClient Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors UnsplasharpClient(string, string?, ILogger<UnsplasharpClient>?, IHttpClientFactory?) Initialize a new instance of Unplasharp class. public UnsplasharpClient(string applicationId, string? secret = null, ILogger<UnsplasharpClient>? logger = null, IHttpClientFactory? httpClientFactory = null) Parameters applicationId string A string to identify the current application performing a request. secret string A string representing an API secret key to make HTTP authentified calls to Unplash services. logger ILogger<UnsplasharpClient> Optional logger for structured logging. httpClientFactory IHttpClientFactory Optional IHttpClientFactory for modern HTTP client management. If not provided, falls back to legacy HttpClient management. Properties ApplicationId Identify the application making API calls Must be created through Unplash developer page https://unsplash.com/developers public string ApplicationId { get; set; } Property Value string LastCollectionsSearchQuery Last collection search query public string? LastCollectionsSearchQuery { get; set; } Property Value string LastCollectionsSearchTotalPages Total pages of last search collections query public int LastCollectionsSearchTotalPages { get; set; } Property Value int LastCollectionsSearchTotalResults Total results of last search collections query public int LastCollectionsSearchTotalResults { get; set; } Property Value int LastPhotosSearchQuery Last photo search query public string? LastPhotosSearchQuery { get; set; } Property Value string LastPhotosSearchTotalPages Total pages of last search photos query public int LastPhotosSearchTotalPages { get; set; } Property Value int LastPhotosSearchTotalResults Total results of last search photos query public int LastPhotosSearchTotalResults { get; set; } Property Value int LastUsersSearchQuery Last collection search query public string? LastUsersSearchQuery { get; set; } Property Value string LastUsersSearchTotalPages Total pages of last search collections query public int LastUsersSearchTotalPages { get; set; } Property Value int LastUsersSearchTotalResults Total results of last search collections query public int LastUsersSearchTotalResults { get; set; } Property Value int MaxRateLimit Maximum number of request allowed per hour. public int MaxRateLimit { get; set; } Property Value int RateLimitRemaining Remaining allowed requests in the current hour. public int RateLimitRemaining { get; set; } Property Value int Secret API Key public string? Secret { get; set; } Property Value string Methods FetchCollectionsList(string) Returns a list of collections (of photos) from a specified URL public Task<List<Collection>> FetchCollectionsList(string url) Parameters url string API endpoint where to fetch the photos' list. Returns Task<List<Collection>> Collections list FetchCollectionsList(string, CancellationToken) Returns a list of collections (of photos) from a specified URL public Task<List<Collection>> FetchCollectionsList(string url, CancellationToken cancellationToken) Parameters url string API endpoint where to fetch the photos' list. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<List<Collection>> Collections list FetchPhoto(string) Fetch a photo from an Unplash specified URL public Task<Photo?> FetchPhoto(string url) Parameters url string URL to fetch photo from. Returns Task<Photo> A single photo instance. FetchPhoto(string, CancellationToken) Fetch a photo from an Unplash specified URL public Task<Photo?> FetchPhoto(string url, CancellationToken cancellationToken) Parameters url string URL to fetch photo from. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<Photo> A single photo instance. FetchPhotosList(string) Return a list of photos from the specified URL. public Task<List<Photo>> FetchPhotosList(string url) Parameters url string API endpoint to fetch the photos' list. Returns Task<List<Photo>> A list of photos. FetchPhotosList(string, CancellationToken) Return a list of photos from the specified URL. public Task<List<Photo>> FetchPhotosList(string url, CancellationToken cancellationToken) Parameters url string API endpoint to fetch the photos' list. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<List<Photo>> A list of photos. FetchSearcCollectionsList(string) Return a list of found collections from a search query. public Task<List<Collection>> FetchSearcCollectionsList(string url) Parameters url string API endpoint to fetch the collections' list. Must be a search url. Returns Task<List<Collection>> A list of collections found. FetchSearcCollectionsList(string, CancellationToken) Return a list of found collections from a search query. public Task<List<Collection>> FetchSearcCollectionsList(string url, CancellationToken cancellationToken) Parameters url string API endpoint to fetch the collections' list. Must be a search url. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<List<Collection>> A list of collections found. FetchSearcUsersList(string) Return a list of found users from a search query. public Task<List<User>> FetchSearcUsersList(string url) Parameters url string API endpoint to fetch the users' list. Must be a search url. Returns Task<List<User>> A list of users found. FetchSearchPhotosList(string) Return a list of found photos from a search query. public Task<List<Photo>> FetchSearchPhotosList(string url) Parameters url string API endpoint to fetch the photos' list. Must be a search url. Returns Task<List<Photo>> A list of photos found. FetchSearchPhotosList(string, CancellationToken) Return a list of found photos from a search query. public Task<List<Photo>> FetchSearchPhotosList(string url, CancellationToken cancellationToken) Parameters url string API endpoint to fetch the photos' list. Must be a search url. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<List<Photo>> A list of photos found. GetCollection(string) Returns the photos collection corresponding to the given id. public Task<Collection?> GetCollection(string id) Parameters id string Collection's id to find. Returns Task<Collection> A new collection instance. GetCollection(string, CancellationToken) Returns the photos collection corresponding to the given id. public Task<Collection?> GetCollection(string id, CancellationToken cancellationToken) Parameters id string Collection's id to find. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<Collection> A new collection instance. GetCollectionPhotos(string, int, int) Retrieve a collection’s photos. public Task<List<Photo>> GetCollectionPhotos(string id, int page = 1, int perPage = 10) Parameters id string The collection’s ID. page int Page number to retrieve. perPage int Number of items per page. (Max: 30) Returns Task<List<Photo>> A list of photos in the collection GetCollectionPhotos(string, int, int, CancellationToken) Retrieve a collection's photos. public Task<List<Photo>> GetCollectionPhotos(string id, int page, int perPage, CancellationToken cancellationToken) Parameters id string The collection's ID. page int Page number to retrieve. perPage int Number of items per page. (Max: 30) cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<List<Photo>> A list of photos in the collection GetMonthlyStats() Get the overall Unsplash stats for the past 30 days. public Task<UnplashMonthlyStats?> GetMonthlyStats() Returns Task<UnplashMonthlyStats> A list of Unplash's stats. GetPhoto(string, int, int) Returns the photo corresponding to the given id. public Task<Photo?> GetPhoto(string id, int width = 0, int height = 0) Parameters id string Photo's unique id to find. width int Desired width. height int Desired height. Returns Task<Photo> A new Photo class instance. GetPhoto(string, int, int, int, int, int, int) Returns the photo corresponding to the given id, in the specified width and height and cropped according to a specified rectangle. public Task<Photo?> GetPhoto(string id, int width, int height, int rectX, int rectY, int rectWidth, int rectHeight) Parameters id string Photo's unique id to find. width int Desired width. height int Desired height. rectX int X origin point of the cropped rectangle. rectY int Y origin point of the cropped rectangle. rectWidth int Width of the cropped rectangle. rectHeight int Height of the cropped rectangle. Returns Task<Photo> A new Photo class instance which has a custom URL. GetPhoto(string, int, int, int, int, int, int, CancellationToken) Returns the photo corresponding to the given id, in the specified width and height and cropped according to a specified rectangle. public Task<Photo?> GetPhoto(string id, int width, int height, int rectX, int rectY, int rectWidth, int rectHeight, CancellationToken cancellationToken) Parameters id string Photo's unique id to find. width int Desired width. height int Desired height. rectX int X origin point of the cropped rectangle. rectY int Y origin point of the cropped rectangle. rectWidth int Width of the cropped rectangle. rectHeight int Height of the cropped rectangle. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<Photo> A new Photo class instance which has a custom URL. GetPhoto(string, int, int, CancellationToken) Returns the photo corresponding to the given id. public Task<Photo?> GetPhoto(string id, int width, int height, CancellationToken cancellationToken) Parameters id string Photo's unique id to find. width int Desired width. height int Desired height. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<Photo> A new Photo class instance. GetPhotoAsync(string, int, int) Returns the photo corresponding to the given id with comprehensive error handling. This method throws specific exceptions for different error scenarios. public Task<Photo> GetPhotoAsync(string id, int width = 0, int height = 0) Parameters id string Photo's unique id to find. width int Desired width. height int Desired height. Returns Task<Photo> A new Photo class instance. Exceptions UnsplasharpException Thrown when the request fails UnsplasharpNotFoundException Thrown when the photo is not found GetPhotoAsync(string, int, int, CancellationToken) Returns the photo corresponding to the given id with comprehensive error handling. This method throws specific exceptions for different error scenarios. public Task<Photo> GetPhotoAsync(string id, int width, int height, CancellationToken cancellationToken) Parameters id string Photo's unique id to find. width int Desired width. height int Desired height. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<Photo> A new Photo class instance. Exceptions UnsplasharpException Thrown when the request fails UnsplasharpNotFoundException Thrown when the photo is not found GetPhotoDownloadLink(string) Retrieve a single photo’s download link. Preferably hit this endpoint if a photo is downloaded in your application for use (example: to be displayed on a blog article, to be shared on social media, to be remixed, etc.). public Task<string?> GetPhotoDownloadLink(string id) Parameters id string The photo’s ID. Returns Task<string> The photo's download link GetPhotoStats(string, Resolution, int) Retrieve total number of downloads, views and likes of a single photo, as well as the historical breakdown of these stats in a specific timeframe (default is 30 days). public Task<PhotoStats?> GetPhotoStats(string id, UnsplasharpClient.Resolution resolution = Resolution.Days, int quantity = 30) Parameters id string The public id of the photo. resolution UnsplasharpClient.Resolution The frequency of the stats. quantity int The amount of for each stat. Returns Task<PhotoStats> GetRandomPhoto() Retrieve a single random photo. public Task<Photo?> GetRandomPhoto() Returns Task<Photo> A new Photo class instance. GetRandomPhoto(bool, string, string, int, int, int) Retrieve a single random photo, given optional filters. public Task<List<Photo>> GetRandomPhoto(bool featured, string username = \"\", string query = \"\", int width = 0, int height = 0, int count = 1) Parameters featured bool Limit selection to featured photos. username string Limit selection to a single user. query string Limit selection to photos matching a search term. width int Image width in pixels. height int Image height in pixels. count int The number of photos to return. (Default: 1; max: 30) Returns Task<List<Photo>> A list of random photos. GetRandomPhoto(int, string, string, int, int) Retrieve a single random photo, given optional filters. public Task<List<Photo>> GetRandomPhoto(int count, string username = \"\", string query = \"\", int width = 0, int height = 0) Parameters count int The number of photos to return. (Default: 1; max: 30) username string Limit selection to a single user. query string Limit selection to photos matching a search term. width int Image width in pixels. height int Image height in pixels. Returns Task<List<Photo>> A list of random photos. GetRandomPhoto(string) Retrieve a single random photo from a specific collection. public Task<Photo?> GetRandomPhoto(string collectionId) Parameters collectionId string Public collection ID to filter selection. Returns Task<Photo> A new Photo class instance. GetRandomPhoto(string, CancellationToken) Retrieve a single random photo from a specific collection. public Task<Photo?> GetRandomPhoto(string collectionId, CancellationToken cancellationToken) Parameters collectionId string Public collection ID to filter selection. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<Photo> A new Photo class instance. GetRandomPhoto(string[]) Retrieve a single random photo from specific collections. public Task<Photo?> GetRandomPhoto(string[] collectionIds) Parameters collectionIds string[] Public collection ID('s) to filter selection. Returns Task<Photo> A new Photo class instance. GetRandomPhoto(string[], CancellationToken) Retrieve a single random photo from specific collections. public Task<Photo?> GetRandomPhoto(string[] collectionIds, CancellationToken cancellationToken) Parameters collectionIds string[] Public collection ID(‘s) to filter selection. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<Photo> A new Photo class instance. GetRandomPhoto(CancellationToken) Retrieve a single random photo. public Task<Photo?> GetRandomPhoto(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<Photo> A new Photo class instance. GetRandomPhoto(Orientation, bool, string, string, int, int, int) Retrieve a single random photo, given optional filters. public Task<List<Photo>> GetRandomPhoto(UnsplasharpClient.Orientation orientation, bool featured, string username = \"\", string query = \"\", int width = 0, int height = 0, int count = 1) Parameters orientation UnsplasharpClient.Orientation Filter search results by photo orientation. featured bool Limit selection to featured photos. username string Limit selection to a single user. query string Limit selection to photos matching a search term. width int Image width in pixels. height int Image height in pixels. count int The number of photos to return. (Default: 1; max: 30) Returns Task<List<Photo>> A list of random photos. GetRandomPhoto(Orientation, string, string, int, int, int) Retrieve a single random photo, given optional filters. public Task<List<Photo>> GetRandomPhoto(UnsplasharpClient.Orientation orientation, string username = \"\", string query = \"\", int width = 0, int height = 0, int count = 1) Parameters orientation UnsplasharpClient.Orientation Filter search results by photo orientation. username string Limit selection to a single user. query string Limit selection to photos matching a search term. width int Image width in pixels. height int Image height in pixels. count int The number of photos to return. (Default: 1; max: 30) Returns Task<List<Photo>> A list of random photos. GetRandomPhotoAsync() Retrieve a single random photo with comprehensive error handling. This method throws specific exceptions for different error scenarios. public Task<Photo> GetRandomPhotoAsync() Returns Task<Photo> A new Photo class instance. Exceptions UnsplasharpException Thrown when the request fails GetRandomPhotoAsync(CancellationToken) Retrieve a single random photo with comprehensive error handling. This method throws specific exceptions for different error scenarios. public Task<Photo> GetRandomPhotoAsync(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<Photo> A new Photo class instance. Exceptions UnsplasharpException Thrown when the request fails GetTotalStats() Get a list of counts for all of Unsplash. public Task<UnplashTotalStats?> GetTotalStats() Returns Task<UnplashTotalStats> A list of Unplash's stats. GetTotalStats(CancellationToken) Get a list of counts for all of Unsplash. public Task<UnplashTotalStats?> GetTotalStats(CancellationToken cancellationToken) Parameters cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<UnplashTotalStats> A list of Unplash's stats. GetUser(string, int, int) Return the User corresponding to the given username. public Task<User?> GetUser(string username, int width = 0, int height = 0) Parameters username string The user’s username to find. Required. width int Profile image width in pixels. height int Profile image height in pixels. Returns Task<User> User corresponding to the username if found. GetUser(string, int, int, CancellationToken) Return the User corresponding to the given username. public Task<User?> GetUser(string username, int width, int height, CancellationToken cancellationToken) Parameters username string The user's username to find. Required. width int Profile image width in pixels. height int Profile image height in pixels. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<User> User corresponding to the username if found. GetUserPorfolioLink(string) Retrieve a single user’s portfolio link. public Task<string?> GetUserPorfolioLink(string username) Parameters username string User's name to get portfolio link from. Returns Task<string> The user's porfolio link GetUserStats(string, Resolution, int) Retrieve the consolidated number of downloads, views and likes of all user’s photos, as well as the historical breakdown and average of these stats in a specific timeframe (default is 30 days). public Task<UserStats?> GetUserStats(string username, UnsplasharpClient.Resolution resolution = Resolution.Days, int quantity = 30) Parameters username string The user’s username. Required. resolution UnsplasharpClient.Resolution The frequency of the stats. (Optional; default: “days”). quantity int The amount of for each stat. (Optional; default: 30) Returns Task<UserStats> User's statistics ListCollections(int, int) Get a single page from the list of all collections. public Task<List<Collection>> ListCollections(int page = 1, int perPage = 10) Parameters page int Page number to retrieve. perPage int Number of items per page. (Max: 30) Returns Task<List<Collection>> List of recent collections ListCollections(int, int, CancellationToken) Get a single page from the list of all collections. public Task<List<Collection>> ListCollections(int page, int perPage, CancellationToken cancellationToken) Parameters page int Page number to retrieve. perPage int Number of items per page. (Max: 30) cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<List<Collection>> List of recent collections ListFeaturedCollections(int, int) Get a single page from the list of featured collections. public Task<List<Collection>> ListFeaturedCollections(int page = 1, int perPage = 10) Parameters page int Page number to retrieve. perPage int Number of items per page. (Max: 30) Returns Task<List<Collection>> A list of collections. ListFeaturedCollections(int, int, CancellationToken) Get a single page from the list of featured collections. public Task<List<Collection>> ListFeaturedCollections(int page, int perPage, CancellationToken cancellationToken) Parameters page int Page number to retrieve. perPage int Number of items per page. (Max: 30) cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<List<Collection>> A list of collections. ListPhotos(int, int, OrderBy) Returns a list of all photos. public Task<List<Photo>> ListPhotos(int page = 1, int perPage = 10, UnsplasharpClient.OrderBy orderBy = OrderBy.Latest) Parameters page int Page number to retrieve. perPage int Number of items per page. orderBy UnsplasharpClient.OrderBy How to sort the photos. Returns Task<List<Photo>> List of all photos. ListPhotos(int, int, OrderBy, CancellationToken) Returns a list of all photos. public Task<List<Photo>> ListPhotos(int page, int perPage, UnsplasharpClient.OrderBy orderBy, CancellationToken cancellationToken) Parameters page int Page number to retrieve. perPage int Number of items per page. orderBy UnsplasharpClient.OrderBy How to sort the photos. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<List<Photo>> List of all photos. ListRelatedCollections(string) Get a collection's related collections. public Task<List<Collection>> ListRelatedCollections(string id) Parameters id string The collection’s ID. Returns Task<List<Collection>> A list of collections. ListRelatedCollections(string, CancellationToken) Get a collection's related collections. public Task<List<Collection>> ListRelatedCollections(string id, CancellationToken cancellationToken) Parameters id string The collection's ID. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<List<Collection>> A list of collections. ListUserCollections(string, int, int) Get all photos collections of an user. public Task<List<Collection>> ListUserCollections(string username, int page = 1, int perPage = 10) Parameters username string Name of the user to get collections from page int Page number to retrieve. perPage int Number of items per page. Returns Task<List<Collection>> List of user's collections ListUserLikedPhotos(string, int, int, OrderBy) Get a list of photos liked by a user. public Task<List<Photo>> ListUserLikedPhotos(string username, int page = 1, int perPage = 10, UnsplasharpClient.OrderBy orderBy = OrderBy.Latest) Parameters username string Username to get photos from page int Page number to retrieve. perPage int Number of items per page. orderBy UnsplasharpClient.OrderBy How to sort the photos. Returns Task<List<Photo>> A list of user's liked photos. ListUserPhotos(string, int, int, OrderBy, bool, int) Get a list of photos uploaded by a user. public Task<List<Photo>> ListUserPhotos(string username, int page = 1, int perPage = 10, UnsplasharpClient.OrderBy orderBy = OrderBy.Latest, bool stats = false, int quantity = 30) Parameters username string Username to get photos from page int Page number to retrieve. perPage int Number of items per page. orderBy UnsplasharpClient.OrderBy How to sort the photos. stats bool Show the stats for each user’s photo. quantity int The amount of for each stat. Returns Task<List<Photo>> A list of user's photos. SearchCollections(string, int, int) Get a single page of collection results for a query. public Task<List<Collection>> SearchCollections(string query, int page = 1, int perPage = 10) Parameters query string Search terms. page int Page number to retrieve. perPage int Number of items per page. Returns Task<List<Collection>> A list of collections found. SearchCollections(string, int, int, CancellationToken) Get a single page of collection results for a query. public Task<List<Collection>> SearchCollections(string query, int page, int perPage, CancellationToken cancellationToken) Parameters query string Search terms. page int Page number to retrieve. perPage int Number of items per page. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<List<Collection>> A list of collections found. SearchPhotos(string, int, int) Get a single page of photo results for a query. public Task<List<Photo>> SearchPhotos(string query, int page = 1, int perPage = 10) Parameters query string Search terms. page int Page number to retrieve. perPage int Number of items per page. Returns Task<List<Photo>> A list of photos found. SearchPhotos(string, int, int, CancellationToken) Get a single page of photo results for a query. public Task<List<Photo>> SearchPhotos(string query, int page, int perPage, CancellationToken cancellationToken) Parameters query string Search terms. page int Page number to retrieve. perPage int Number of items per page. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<List<Photo>> A list of photos found. SearchPhotos(string, string, int, int) Get a single page of photo results for a query. public Task<List<Photo>> SearchPhotos(string query, string collectionId, int page = 1, int perPage = 10) Parameters query string Search terms. collectionId string Collection ID to narrow search. page int Page number to retrieve. perPage int Number of items per page. Returns Task<List<Photo>> A list of photos found. SearchPhotos(string, string, int, int, CancellationToken) Get a single page of photo results for a query. public Task<List<Photo>> SearchPhotos(string query, string collectionId, int page, int perPage, CancellationToken cancellationToken) Parameters query string Search terms. collectionId string Collection ID to narrow search. page int Page number to retrieve. perPage int Number of items per page. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<List<Photo>> A list of photos found. SearchPhotos(string, string[], int, int) Get a single page of photo results for a query. public Task<List<Photo>> SearchPhotos(string query, string[] collectionIds, int page = 1, int perPage = 10) Parameters query string Search terms. collectionIds string[] Collection ID's to narrow search. page int Page number to retrieve. perPage int Number of items per page. Returns Task<List<Photo>> A list of photos found. SearchPhotos(string, string[], int, int, CancellationToken) Get a single page of photo results for a query. public Task<List<Photo>> SearchPhotos(string query, string[] collectionIds, int page, int perPage, CancellationToken cancellationToken) Parameters query string Search terms. collectionIds string[] Collection ID's to narrow search. page int Page number to retrieve. perPage int Number of items per page. cancellationToken CancellationToken Cancellation token to cancel the request. Returns Task<List<Photo>> A list of photos found. SearchUsers(string, int, int) Get a single page of user results for a query. public Task<List<User>> SearchUsers(string query, int page = 1, int perPage = 10) Parameters query string Search terms. page int Page number to retrieve. perPage int Number of items per page. Returns Task<List<User>> A list of users found."
  },
  "api/Unsplasharp.html": {
    "href": "api/Unsplasharp.html",
    "title": "Namespace Unsplasharp | Unsplasharp Documentation",
    "summary": "Namespace Unsplasharp Classes UnsplasharpClient Represents a Unsplasharp class which can be used to communicate with Unplash APIs. Enums UnsplasharpClient.OrderBy How to sort the data. UnsplasharpClient.Orientation Photo orientation. UnsplasharpClient.Resolution The frequency of the stats."
  },
  "code-examples.html": {
    "href": "code-examples.html",
    "title": "Code Examples and Recipes | Unsplasharp Documentation",
    "summary": "Code Examples and Recipes This comprehensive collection provides practical code examples and recipes for common Unsplasharp use cases, from basic operations to advanced integration patterns. Table of Contents Basic Operations Search and Discovery User and Collection Management Image Processing and Download Web Application Integration Desktop Application Examples Background Services Testing Patterns Performance Optimization Basic Operations Simple Photo Retrieval // Get a random photo public async Task<string> GetRandomPhotoUrl() { var client = new UnsplasharpClient(\"YOUR_APP_ID\"); try { var photo = await client.GetRandomPhotoAsync(); return photo.Urls.Regular; } catch (UnsplasharpException ex) { Console.WriteLine($\"Error: {ex.Message}\"); return \"https://via.placeholder.com/800x600?text=Photo+Not+Available\"; } } // Get a specific photo with error handling public async Task<Photo?> GetPhotoSafely(string photoId) { var client = new UnsplasharpClient(\"YOUR_APP_ID\"); try { return await client.GetPhotoAsync(photoId); } catch (UnsplasharpNotFoundException) { Console.WriteLine($\"Photo {photoId} not found\"); return null; } catch (UnsplasharpRateLimitException ex) { Console.WriteLine($\"Rate limited. Try again at {ex.RateLimitReset}\"); return null; } catch (UnsplasharpException ex) { Console.WriteLine($\"API error: {ex.Message}\"); return null; } } Photo Information Display public static void DisplayPhotoInfo(Photo photo) { Console.WriteLine(\"=== PHOTO INFORMATION ===\"); Console.WriteLine($\"ID: {photo.Id}\"); Console.WriteLine($\"Description: {photo.Description ?? \"No description\"}\"); Console.WriteLine($\"Photographer: {photo.User.Name} (@{photo.User.Username})\"); Console.WriteLine($\"Dimensions: {photo.Width}x{photo.Height}\"); Console.WriteLine($\"Likes: {photo.Likes:N0} | Downloads: {photo.Downloads:N0}\"); Console.WriteLine($\"Color: {photo.Color}\"); Console.WriteLine($\"Created: {DateTime.Parse(photo.CreatedAt):yyyy-MM-dd}\"); // URLs Console.WriteLine(\"\\n=== AVAILABLE SIZES ===\"); Console.WriteLine($\"Thumbnail: {photo.Urls.Thumbnail}\"); Console.WriteLine($\"Small: {photo.Urls.Small}\"); Console.WriteLine($\"Regular: {photo.Urls.Regular}\"); Console.WriteLine($\"Full: {photo.Urls.Full}\"); Console.WriteLine($\"Raw: {photo.Urls.Raw}\"); // Location (if available) if (!string.IsNullOrEmpty(photo.Location.Name)) { Console.WriteLine($\"\\n=== LOCATION ===\"); Console.WriteLine($\"Location: {photo.Location.Name}\"); if (photo.Location.Position != null) { Console.WriteLine($\"Coordinates: {photo.Location.Position.Latitude}, {photo.Location.Position.Longitude}\"); } } // Camera info (if available) if (!string.IsNullOrEmpty(photo.Exif.Make)) { Console.WriteLine($\"\\n=== CAMERA INFO ===\"); Console.WriteLine($\"Camera: {photo.Exif.Make} {photo.Exif.Model}\"); Console.WriteLine($\"Settings: f/{photo.Exif.Aperture}, {photo.Exif.ExposureTime}s, ISO {photo.Exif.Iso}\"); Console.WriteLine($\"Focal Length: {photo.Exif.FocalLength}\"); } } Search and Discovery Smart Search with Fallbacks public class SmartPhotoSearch { private readonly UnsplasharpClient _client; private readonly ILogger<SmartPhotoSearch> _logger; public SmartPhotoSearch(UnsplasharpClient client, ILogger<SmartPhotoSearch> logger) { _client = client; _logger = logger; } public async Task<List<Photo>> SearchWithFallbacks(string query, int desiredCount = 20) { var strategies = new List<(string name, Func<Task<List<Photo>>> search)> { (\"Exact match\", () => _client.SearchPhotosAsync(query, perPage: desiredCount)), (\"Popular results\", () => _client.SearchPhotosAsync(query, orderBy: OrderBy.Popular, perPage: desiredCount)), (\"Broader search\", () => SearchBroaderTerms(query, desiredCount)), (\"Random fallback\", () => GetRandomPhotosForQuery(query, desiredCount)) }; foreach (var (name, search) in strategies) { try { var results = await search(); if (results.Count > 0) { _logger.LogInformation(\"Search strategy '{Strategy}' succeeded with {Count} results\", name, results.Count); return results; } } catch (Exception ex) { _logger.LogWarning(ex, \"Search strategy '{Strategy}' failed\", name); } } _logger.LogWarning(\"All search strategies failed for query: {Query}\", query); return new List<Photo>(); } private async Task<List<Photo>> SearchBroaderTerms(string query, int count) { var words = query.Split(' ', StringSplitOptions.RemoveEmptyEntries); var allPhotos = new List<Photo>(); foreach (var word in words.Take(3)) { try { var photos = await _client.SearchPhotosAsync(word, perPage: count / words.Length + 5); allPhotos.AddRange(photos); } catch (Exception ex) { _logger.LogDebug(ex, \"Failed to search for word: {Word}\", word); } } return allPhotos.DistinctBy(p => p.Id).Take(count).ToList(); } private async Task<List<Photo>> GetRandomPhotosForQuery(string query, int count) { try { return await _client.GetRandomPhotosAsync(count, query: query); } catch { // Final fallback - completely random photos return await _client.GetRandomPhotosAsync(count); } } } Advanced Search Filters public class AdvancedPhotoSearch { private readonly UnsplasharpClient _client; public AdvancedPhotoSearch(UnsplasharpClient client) { _client = client; } // Search for high-quality landscape photos public async Task<List<Photo>> GetHighQualityLandscapes(string query, int count = 20) { var photos = await _client.SearchPhotosAsync( query: $\"{query} landscape\", orderBy: OrderBy.Popular, orientation: Orientation.Landscape, perPage: count * 2 // Get more to filter ); return photos .Where(p => p.Width >= 1920 && p.Height >= 1080) // HD or better .Where(p => p.Likes >= 100) // Popular photos .Take(count) .ToList(); } // Search for photos by color theme public async Task<List<Photo>> GetPhotosByColor(string query, string color, int count = 20) { return await _client.SearchPhotosAsync( query: query, color: color, orderBy: OrderBy.Popular, perPage: count ); } // Search for portrait photos suitable for profiles public async Task<List<Photo>> GetPortraitPhotos(string query, int count = 20) { var photos = await _client.SearchPhotosAsync( query: $\"{query} portrait person face\", orientation: Orientation.Portrait, contentFilter: \"high\", // Safe content orderBy: OrderBy.Popular, perPage: count * 2 ); return photos .Where(p => p.Height > p.Width) // Ensure portrait orientation .Where(p => p.Likes >= 50) // Some popularity .Take(count) .ToList(); } // Search within specific collections public async Task<List<Photo>> SearchInCollections(string query, string[] collectionIds, int count = 20) { var collectionIdsString = string.Join(\",\", collectionIds); return await _client.SearchPhotosAsync( query: query, collectionIds: collectionIdsString, orderBy: OrderBy.Relevant, perPage: count ); } } Pagination Helper public class PaginatedSearch { private readonly UnsplasharpClient _client; public PaginatedSearch(UnsplasharpClient client) { _client = client; } public async IAsyncEnumerable<Photo> SearchAllPhotos( string query, int batchSize = 30, int maxPhotos = 1000, [EnumeratorCancellation] CancellationToken cancellationToken = default) { int currentPage = 1; int totalReturned = 0; bool hasMoreResults = true; while (hasMoreResults && totalReturned < maxPhotos && !cancellationToken.IsCancellationRequested) { try { var photos = await _client.SearchPhotosAsync( query, page: currentPage, perPage: Math.Min(batchSize, maxPhotos - totalReturned), cancellationToken: cancellationToken ); if (photos.Count == 0) { hasMoreResults = false; yield break; } foreach (var photo in photos) { if (totalReturned >= maxPhotos) yield break; yield return photo; totalReturned++; } hasMoreResults = photos.Count == batchSize && currentPage < _client.LastPhotosSearchTotalPages; currentPage++; // Rate limiting courtesy delay await Task.Delay(100, cancellationToken); } catch (UnsplasharpRateLimitException ex) { var delay = ex.TimeUntilReset ?? TimeSpan.FromMinutes(1); await Task.Delay(delay, cancellationToken); } catch (Exception) { hasMoreResults = false; } } } } // Usage example public async Task SearchExample() { var search = new PaginatedSearch(_client); var photoCount = 0; await foreach (var photo in search.SearchAllPhotos(\"nature\", maxPhotos: 100)) { Console.WriteLine($\"{++photoCount}: {photo.Description} by {photo.User.Name}\"); if (photoCount >= 50) // Process first 50 break; } } User and Collection Management User Profile Analysis public class UserAnalyzer { private readonly UnsplasharpClient _client; public UserAnalyzer(UnsplasharpClient client) { _client = client; } public async Task<UserProfile> AnalyzeUser(string username) { var user = await _client.GetUserAsync(username); var userPhotos = await _client.GetUserPhotosAsync(username, perPage: 30); var userLikes = await _client.GetUserLikesAsync(username, perPage: 30); return new UserProfile { User = user, RecentPhotos = userPhotos, RecentLikes = userLikes, EngagementRate = CalculateEngagementRate(user), AveragePhotoQuality = CalculateAverageQuality(userPhotos), PopularityScore = CalculatePopularityScore(user), ActivityLevel = DetermineActivityLevel(user, userPhotos) }; } private double CalculateEngagementRate(User user) { return user.TotalPhotos > 0 ? (double)user.TotalLikes / user.TotalPhotos : 0; } private double CalculateAverageQuality(List<Photo> photos) { if (!photos.Any()) return 0; return photos.Average(p => (p.Likes * 0.4) + (p.Downloads * 0.3) + (p.Width >= 1920 ? 20 : 0) + (p.Height >= 1080 ? 20 : 0) ); } private int CalculatePopularityScore(User user) { var score = 0; if (user.TotalLikes > 100000) score += 50; else if (user.TotalLikes > 10000) score += 30; else if (user.TotalLikes > 1000) score += 10; if (user.TotalPhotos > 1000) score += 30; else if (user.TotalPhotos > 100) score += 20; else if (user.TotalPhotos > 10) score += 10; if (user.FollowersCount > 10000) score += 20; else if (user.FollowersCount > 1000) score += 10; return score; } private ActivityLevel DetermineActivityLevel(User user, List<Photo> recentPhotos) { if (!recentPhotos.Any()) return ActivityLevel.Inactive; var recentPhotoCount = recentPhotos.Count(p => DateTime.Parse(p.CreatedAt) > DateTime.UtcNow.AddDays(-30)); return recentPhotoCount switch { >= 10 => ActivityLevel.VeryActive, >= 5 => ActivityLevel.Active, >= 1 => ActivityLevel.Moderate, _ => ActivityLevel.Low }; } } public class UserProfile { public User User { get; set; } public List<Photo> RecentPhotos { get; set; } = new(); public List<Photo> RecentLikes { get; set; } = new(); public double EngagementRate { get; set; } public double AveragePhotoQuality { get; set; } public int PopularityScore { get; set; } public ActivityLevel ActivityLevel { get; set; } } public enum ActivityLevel { Inactive, Low, Moderate, Active, VeryActive } Collection Explorer public class CollectionExplorer { private readonly UnsplasharpClient _client; public CollectionExplorer(UnsplasharpClient client) { _client = client; } public async Task<CollectionAnalysis> AnalyzeCollection(string collectionId) { var collection = await _client.GetCollectionAsync(collectionId); var photos = await _client.GetCollectionPhotosAsync(collectionId, perPage: 30); var analysis = new CollectionAnalysis { Collection = collection, SamplePhotos = photos, AveragePhotoQuality = photos.Any() ? photos.Average(p => p.Likes + p.Downloads) : 0, DominantColors = GetDominantColors(photos), CommonOrientations = GetOrientationDistribution(photos), TopPhotographers = GetTopPhotographers(photos), QualityScore = CalculateCollectionQuality(collection, photos) }; return analysis; } private Dictionary<string, int> GetDominantColors(List<Photo> photos) { return photos .GroupBy(p => p.Color) .ToDictionary(g => g.Key, g => g.Count()) .OrderByDescending(kvp => kvp.Value) .Take(5) .ToDictionary(kvp => kvp.Key, kvp => kvp.Value); } private Dictionary<string, int> GetOrientationDistribution(List<Photo> photos) { return photos .GroupBy(p => p.Width > p.Height ? \"Landscape\" : p.Height > p.Width ? \"Portrait\" : \"Square\") .ToDictionary(g => g.Key, g => g.Count()); } private List<(string Name, int PhotoCount)> GetTopPhotographers(List<Photo> photos) { return photos .GroupBy(p => p.User.Name) .Select(g => (Name: g.Key, PhotoCount: g.Count())) .OrderByDescending(x => x.PhotoCount) .Take(5) .ToList(); } private int CalculateCollectionQuality(Collection collection, List<Photo> photos) { var score = 0; // Collection size scoring if (collection.TotalPhotos > 100) score += 20; else if (collection.TotalPhotos > 50) score += 15; else if (collection.TotalPhotos > 10) score += 10; // Photo quality scoring if (photos.Any()) { var avgLikes = photos.Average(p => p.Likes); if (avgLikes > 1000) score += 30; else if (avgLikes > 100) score += 20; else if (avgLikes > 10) score += 10; var highResCount = photos.Count(p => p.Width >= 1920 && p.Height >= 1080); score += (highResCount * 100 / photos.Count) / 5; // Up to 20 points } // Curator reputation var curator = collection.User; if (curator.TotalLikes > 10000) score += 15; else if (curator.TotalLikes > 1000) score += 10; return Math.Min(score, 100); // Cap at 100 } } public class CollectionAnalysis { public Collection Collection { get; set; } public List<Photo> SamplePhotos { get; set; } = new(); public double AveragePhotoQuality { get; set; } public Dictionary<string, int> DominantColors { get; set; } = new(); public Dictionary<string, int> CommonOrientations { get; set; } = new(); public List<(string Name, int PhotoCount)> TopPhotographers { get; set; } = new(); public int QualityScore { get; set; } } Image Processing and Download Smart Image Downloader public class SmartImageDownloader { private readonly UnsplasharpClient _client; private readonly HttpClient _httpClient; private readonly ILogger<SmartImageDownloader> _logger; public SmartImageDownloader(UnsplasharpClient client, HttpClient httpClient, ILogger<SmartImageDownloader> logger) { _client = client; _httpClient = httpClient; _logger = logger; } public async Task<DownloadResult> DownloadOptimalSize(string photoId, int maxWidth, int maxHeight, string downloadPath) { try { var photo = await _client.GetPhotoAsync(photoId); var optimalUrl = SelectOptimalUrl(photo.Urls, maxWidth, maxHeight); _logger.LogInformation(\"Downloading photo {PhotoId} from {Url}\", photoId, optimalUrl); var imageBytes = await _httpClient.GetByteArrayAsync(optimalUrl); var fileName = GenerateFileName(photo, optimalUrl); var fullPath = Path.Combine(downloadPath, fileName); Directory.CreateDirectory(downloadPath); await File.WriteAllBytesAsync(fullPath, imageBytes); return new DownloadResult { Success = true, FilePath = fullPath, FileSize = imageBytes.Length, Photo = photo, DownloadUrl = optimalUrl }; } catch (Exception ex) { _logger.LogError(ex, \"Failed to download photo {PhotoId}\", photoId); return new DownloadResult { Success = false, Error = ex.Message }; } } private string SelectOptimalUrl(Urls urls, int maxWidth, int maxHeight) { var maxDimension = Math.Max(maxWidth, maxHeight); return maxDimension switch { <= 200 => urls.Thumbnail, <= 400 => urls.Small, <= 1080 => urls.Regular, <= 2048 => urls.Full, _ => urls.Raw }; } private string GenerateFileName(Photo photo, string url) { var extension = url.Contains(\"fm=\") && url.Contains(\"fm=webp\") ? \"webp\" : \"jpg\"; var sanitizedDescription = SanitizeFileName(photo.Description ?? \"untitled\"); var timestamp = DateTime.Now.ToString(\"yyyyMMdd_HHmmss\"); return $\"{photo.Id}_{sanitizedDescription}_{timestamp}.{extension}\"; } private string SanitizeFileName(string fileName) { var invalidChars = Path.GetInvalidFileNameChars(); var sanitized = new string(fileName.Where(c => !invalidChars.Contains(c)).ToArray()); return sanitized.Length > 50 ? sanitized.Substring(0, 50) : sanitized; } public async Task<BatchDownloadResult> DownloadMultiplePhotos( IEnumerable<string> photoIds, string downloadPath, int maxWidth = 1920, int maxHeight = 1080, int maxConcurrency = 3) { var semaphore = new SemaphoreSlim(maxConcurrency, maxConcurrency); var result = new BatchDownloadResult(); var downloadTasks = photoIds.Select(async photoId => { await semaphore.WaitAsync(); try { var downloadResult = await DownloadOptimalSize(photoId, maxWidth, maxHeight, downloadPath); lock (result) { if (downloadResult.Success) result.SuccessfulDownloads.Add(downloadResult); else result.FailedDownloads.Add(photoId, downloadResult.Error ?? \"Unknown error\"); } } finally { semaphore.Release(); } }); await Task.WhenAll(downloadTasks); return result; } } public class DownloadResult { public bool Success { get; set; } public string? FilePath { get; set; } public long FileSize { get; set; } public Photo? Photo { get; set; } public string? DownloadUrl { get; set; } public string? Error { get; set; } } public class BatchDownloadResult { public List<DownloadResult> SuccessfulDownloads { get; } = new(); public Dictionary<string, string> FailedDownloads { get; } = new(); public int TotalAttempted => SuccessfulDownloads.Count + FailedDownloads.Count; public double SuccessRate => TotalAttempted > 0 ? (double)SuccessfulDownloads.Count / TotalAttempted : 0; } Image Metadata Extractor public class ImageMetadataExtractor { public static ImageMetadata ExtractMetadata(Photo photo) { return new ImageMetadata { Id = photo.Id, Title = photo.Description ?? \"Untitled\", Photographer = photo.User.Name, PhotographerUsername = photo.User.Username, Dimensions = new Size(photo.Width, photo.Height), AspectRatio = (double)photo.Width / photo.Height, DominantColor = photo.Color, BlurHash = photo.BlurHash, CreatedAt = DateTime.Parse(photo.CreatedAt), Engagement = new EngagementMetrics { Likes = photo.Likes, Downloads = photo.Downloads, IsLikedByUser = photo.IsLikedByUser }, Camera = ExtractCameraInfo(photo.Exif), Location = ExtractLocationInfo(photo.Location), Keywords = ExtractKeywords(photo), QualityScore = CalculateQualityScore(photo) }; } private static CameraInfo? ExtractCameraInfo(Exif exif) { if (string.IsNullOrEmpty(exif.Make)) return null; return new CameraInfo { Make = exif.Make, Model = exif.Model, Aperture = exif.Aperture, ExposureTime = exif.ExposureTime, Iso = exif.Iso, FocalLength = exif.FocalLength }; } private static LocationInfo? ExtractLocationInfo(Location location) { if (string.IsNullOrEmpty(location.Name)) return null; return new LocationInfo { Name = location.Name, City = location.City, Country = location.Country, Coordinates = location.Position != null ? new Coordinates(location.Position.Latitude, location.Position.Longitude) : null }; } private static List<string> ExtractKeywords(Photo photo) { var keywords = new List<string>(); // Add categories keywords.AddRange(photo.Categories.Select(c => c.Title)); // Extract from description if (!string.IsNullOrEmpty(photo.Description)) { var words = photo.Description.Split(' ', StringSplitOptions.RemoveEmptyEntries) .Where(w => w.Length > 3) .Select(w => w.Trim('.', ',', '!', '?').ToLowerInvariant()) .Distinct(); keywords.AddRange(words); } // Add orientation keywords.Add(photo.Width > photo.Height ? \"landscape\" : photo.Height > photo.Width ? \"portrait\" : \"square\"); // Add color keywords.Add($\"color-{photo.Color.TrimStart('#')}\"); return keywords.Distinct().ToList(); } private static int CalculateQualityScore(Photo photo) { var score = 0; // Resolution scoring var pixels = photo.Width * photo.Height; if (pixels >= 8000000) score += 25; // 8MP+ else if (pixels >= 2000000) score += 20; // 2MP+ else if (pixels >= 1000000) score += 15; // 1MP+ else score += 10; // Engagement scoring if (photo.Likes > 10000) score += 25; else if (photo.Likes > 1000) score += 20; else if (photo.Likes > 100) score += 15; else score += 10; // Technical quality if (!string.IsNullOrEmpty(photo.Exif.Make)) score += 15; // Has EXIF if (!string.IsNullOrEmpty(photo.Location.Name)) score += 10; // Has location if (!string.IsNullOrEmpty(photo.Description)) score += 10; // Has description // Photographer reputation if (photo.User.TotalLikes > 100000) score += 15; else if (photo.User.TotalLikes > 10000) score += 10; else if (photo.User.TotalLikes > 1000) score += 5; return Math.Min(score, 100); } } public class ImageMetadata { public string Id { get; set; } = string.Empty; public string Title { get; set; } = string.Empty; public string Photographer { get; set; } = string.Empty; public string PhotographerUsername { get; set; } = string.Empty; public Size Dimensions { get; set; } public double AspectRatio { get; set; } public string DominantColor { get; set; } = string.Empty; public string BlurHash { get; set; } = string.Empty; public DateTime CreatedAt { get; set; } public EngagementMetrics Engagement { get; set; } = new(); public CameraInfo? Camera { get; set; } public LocationInfo? Location { get; set; } public List<string> Keywords { get; set; } = new(); public int QualityScore { get; set; } } public record Size(int Width, int Height); public record Coordinates(double Latitude, double Longitude); public class EngagementMetrics { public int Likes { get; set; } public int Downloads { get; set; } public bool IsLikedByUser { get; set; } } public class CameraInfo { public string Make { get; set; } = string.Empty; public string Model { get; set; } = string.Empty; public string Aperture { get; set; } = string.Empty; public string ExposureTime { get; set; } = string.Empty; public int Iso { get; set; } public string FocalLength { get; set; } = string.Empty; } public class LocationInfo { public string Name { get; set; } = string.Empty; public string City { get; set; } = string.Empty; public string Country { get; set; } = string.Empty; public Coordinates? Coordinates { get; set; } } Web Application Integration ASP.NET Core Photo API [ApiController] [Route(\"api/[controller]\")] public class PhotosController : ControllerBase { private readonly UnsplasharpClient _unsplashClient; private readonly IMemoryCache _cache; private readonly ILogger<PhotosController> _logger; public PhotosController(UnsplasharpClient unsplashClient, IMemoryCache cache, ILogger<PhotosController> logger) { _unsplashClient = unsplashClient; _cache = cache; _logger = logger; } [HttpGet(\"random\")] public async Task<ActionResult<PhotoDto>> GetRandomPhoto([FromQuery] string? query = null) { try { var photo = string.IsNullOrEmpty(query) ? await _unsplashClient.GetRandomPhotoAsync() : await _unsplashClient.GetRandomPhotoAsync(query: query); return Ok(PhotoDto.FromPhoto(photo)); } catch (UnsplasharpRateLimitException ex) { _logger.LogWarning(\"Rate limit exceeded: {RemainingRequests}/{TotalRequests}\", ex.RateLimitRemaining, ex.RateLimit); return StatusCode(429, new { error = \"Rate limit exceeded\", retryAfter = ex.TimeUntilReset }); } catch (UnsplasharpException ex) { _logger.LogError(ex, \"Error getting random photo\"); return StatusCode(500, new { error = \"Failed to fetch photo\" }); } } [HttpGet(\"search\")] public async Task<ActionResult<SearchResultDto>> SearchPhotos( [FromQuery] string query, [FromQuery] int page = 1, [FromQuery] int perPage = 20, [FromQuery] string? color = null, [FromQuery] string? orientation = null) { if (string.IsNullOrWhiteSpace(query)) return BadRequest(new { error = \"Query parameter is required\" }); var cacheKey = $\"search:{query}:{page}:{perPage}:{color}:{orientation}\"; if (_cache.TryGetValue(cacheKey, out SearchResultDto cachedResult)) { return Ok(cachedResult); } try { var orientationEnum = orientation?.ToLowerInvariant() switch { \"landscape\" => Orientation.Landscape, \"portrait\" => Orientation.Portrait, \"squarish\" => Orientation.Squarish, _ => Orientation.All }; var photos = await _unsplashClient.SearchPhotosAsync( query: query, page: page, perPage: Math.Min(perPage, 30), // Limit max per page color: color, orientation: orientationEnum ); var result = new SearchResultDto { Photos = photos.Select(PhotoDto.FromPhoto).ToList(), TotalResults = _unsplashClient.LastPhotosSearchTotalResults, TotalPages = _unsplashClient.LastPhotosSearchTotalPages, CurrentPage = page, Query = query }; // Cache for 5 minutes _cache.Set(cacheKey, result, TimeSpan.FromMinutes(5)); return Ok(result); } catch (UnsplasharpException ex) { _logger.LogError(ex, \"Error searching photos with query: {Query}\", query); return StatusCode(500, new { error = \"Search failed\" }); } } [HttpGet(\"{photoId}\")] public async Task<ActionResult<PhotoDto>> GetPhoto(string photoId) { var cacheKey = $\"photo:{photoId}\"; if (_cache.TryGetValue(cacheKey, out PhotoDto cachedPhoto)) { return Ok(cachedPhoto); } try { var photo = await _unsplashClient.GetPhotoAsync(photoId); var photoDto = PhotoDto.FromPhoto(photo); // Cache for 1 hour _cache.Set(cacheKey, photoDto, TimeSpan.FromHours(1)); return Ok(photoDto); } catch (UnsplasharpNotFoundException) { return NotFound(new { error = $\"Photo with ID '{photoId}' not found\" }); } catch (UnsplasharpException ex) { _logger.LogError(ex, \"Error getting photo: {PhotoId}\", photoId); return StatusCode(500, new { error = \"Failed to fetch photo\" }); } } } public class PhotoDto { public string Id { get; set; } = string.Empty; public string Description { get; set; } = string.Empty; public string PhotographerName { get; set; } = string.Empty; public string PhotographerUsername { get; set; } = string.Empty; public int Width { get; set; } public int Height { get; set; } public string Color { get; set; } = string.Empty; public int Likes { get; set; } public int Downloads { get; set; } public DateTime CreatedAt { get; set; } public UrlsDto Urls { get; set; } = new(); public static PhotoDto FromPhoto(Photo photo) { return new PhotoDto { Id = photo.Id, Description = photo.Description ?? string.Empty, PhotographerName = photo.User.Name, PhotographerUsername = photo.User.Username, Width = photo.Width, Height = photo.Height, Color = photo.Color, Likes = photo.Likes, Downloads = photo.Downloads, CreatedAt = DateTime.Parse(photo.CreatedAt), Urls = new UrlsDto { Thumbnail = photo.Urls.Thumbnail, Small = photo.Urls.Small, Regular = photo.Urls.Regular, Full = photo.Urls.Full } }; } } public class UrlsDto { public string Thumbnail { get; set; } = string.Empty; public string Small { get; set; } = string.Empty; public string Regular { get; set; } = string.Empty; public string Full { get; set; } = string.Empty; } public class SearchResultDto { public List<PhotoDto> Photos { get; set; } = new(); public int TotalResults { get; set; } public int TotalPages { get; set; } public int CurrentPage { get; set; } public string Query { get; set; } = string.Empty; } Desktop Application Examples WPF Photo Gallery public partial class PhotoGalleryWindow : Window { private readonly UnsplasharpClient _client; private readonly ObservableCollection<PhotoViewModel> _photos; private CancellationTokenSource? _searchCancellation; public PhotoGalleryWindow() { InitializeComponent(); _client = new UnsplasharpClient(\"YOUR_APP_ID\"); _photos = new ObservableCollection<PhotoViewModel>(); PhotosListView.ItemsSource = _photos; } private async void SearchButton_Click(object sender, RoutedEventArgs e) { var query = SearchTextBox.Text.Trim(); if (string.IsNullOrEmpty(query)) return; // Cancel previous search _searchCancellation?.Cancel(); _searchCancellation = new CancellationTokenSource(); LoadingProgressBar.Visibility = Visibility.Visible; SearchButton.IsEnabled = false; _photos.Clear(); try { var photos = await _client.SearchPhotosAsync(query, perPage: 30, cancellationToken: _searchCancellation.Token); foreach (var photo in photos) { _photos.Add(new PhotoViewModel(photo)); } StatusTextBlock.Text = $\"Found {_client.LastPhotosSearchTotalResults:N0} photos\"; } catch (OperationCanceledException) { StatusTextBlock.Text = \"Search cancelled\"; } catch (UnsplasharpRateLimitException ex) { StatusTextBlock.Text = $\"Rate limited. Try again at {ex.RateLimitReset:HH:mm}\"; } catch (UnsplasharpException ex) { StatusTextBlock.Text = $\"Error: {ex.Message}\"; } finally { LoadingProgressBar.Visibility = Visibility.Collapsed; SearchButton.IsEnabled = true; } } private async void DownloadButton_Click(object sender, RoutedEventArgs e) { if (sender is Button button && button.DataContext is PhotoViewModel photoVM) { var saveDialog = new Microsoft.Win32.SaveFileDialog { FileName = $\"{photoVM.Id}_{photoVM.PhotographerName}.jpg\", Filter = \"JPEG Image|*.jpg|All Files|*.*\" }; if (saveDialog.ShowDialog() == true) { button.IsEnabled = false; button.Content = \"Downloading...\"; try { using var httpClient = new HttpClient(); var imageBytes = await httpClient.GetByteArrayAsync(photoVM.RegularUrl); await File.WriteAllBytesAsync(saveDialog.FileName, imageBytes); MessageBox.Show(\"Photo downloaded successfully!\", \"Success\", MessageBoxButton.OK, MessageBoxImage.Information); } catch (Exception ex) { MessageBox.Show($\"Download failed: {ex.Message}\", \"Error\", MessageBoxButton.OK, MessageBoxImage.Error); } finally { button.Content = \"Download\"; button.IsEnabled = true; } } } } private void RandomPhotoButton_Click(object sender, RoutedEventArgs e) { _ = LoadRandomPhoto(); } private async Task LoadRandomPhoto() { LoadingProgressBar.Visibility = Visibility.Visible; try { var photo = await _client.GetRandomPhotoAsync(); _photos.Clear(); _photos.Add(new PhotoViewModel(photo)); StatusTextBlock.Text = \"Random photo loaded\"; } catch (UnsplasharpException ex) { StatusTextBlock.Text = $\"Error: {ex.Message}\"; } finally { LoadingProgressBar.Visibility = Visibility.Collapsed; } } } public class PhotoViewModel : INotifyPropertyChanged { public string Id { get; } public string Description { get; } public string PhotographerName { get; } public string PhotographerUsername { get; } public int Width { get; } public int Height { get; } public string Color { get; } public int Likes { get; } public string ThumbnailUrl { get; } public string SmallUrl { get; } public string RegularUrl { get; } public string AspectRatioText { get; } public string DimensionsText { get; } public string EngagementText { get; } public PhotoViewModel(Photo photo) { Id = photo.Id; Description = photo.Description ?? \"Untitled\"; PhotographerName = photo.User.Name; PhotographerUsername = photo.User.Username; Width = photo.Width; Height = photo.Height; Color = photo.Color; Likes = photo.Likes; ThumbnailUrl = photo.Urls.Thumbnail; SmallUrl = photo.Urls.Small; RegularUrl = photo.Urls.Regular; AspectRatioText = $\"{(double)Width / Height:F2}:1\"; DimensionsText = $\"{Width}×{Height}\"; EngagementText = $\"{Likes:N0} likes\"; } public event PropertyChangedEventHandler? PropertyChanged; } Console Photo Browser public class ConsolePhotoBrowser { private readonly UnsplasharpClient _client; private readonly List<Photo> _currentPhotos = new(); private int _currentIndex = 0; public ConsolePhotoBrowser(string applicationId) { _client = new UnsplasharpClient(applicationId); } public async Task RunAsync() { Console.WriteLine(\"=== Unsplash Photo Browser ===\"); Console.WriteLine(\"Commands: search <query>, random, next, prev, info, download, quit\"); Console.WriteLine(); while (true) { Console.Write(\"> \"); var input = Console.ReadLine()?.Trim().ToLowerInvariant(); if (string.IsNullOrEmpty(input)) continue; var parts = input.Split(' ', 2); var command = parts[0]; var argument = parts.Length > 1 ? parts[1] : string.Empty; try { switch (command) { case \"search\": if (string.IsNullOrEmpty(argument)) { Console.WriteLine(\"Usage: search <query>\"); break; } await SearchPhotos(argument); break; case \"random\": await LoadRandomPhoto(); break; case \"next\": ShowNextPhoto(); break; case \"prev\": ShowPreviousPhoto(); break; case \"info\": ShowCurrentPhotoInfo(); break; case \"download\": await DownloadCurrentPhoto(); break; case \"quit\": case \"exit\": return; default: Console.WriteLine(\"Unknown command. Available: search, random, next, prev, info, download, quit\"); break; } } catch (UnsplasharpRateLimitException ex) { Console.WriteLine($\"Rate limited. Try again at {ex.RateLimitReset:HH:mm:ss}\"); } catch (UnsplasharpException ex) { Console.WriteLine($\"Error: {ex.Message}\"); } catch (Exception ex) { Console.WriteLine($\"Unexpected error: {ex.Message}\"); } Console.WriteLine(); } } private async Task SearchPhotos(string query) { Console.WriteLine($\"Searching for '{query}'...\"); var photos = await _client.SearchPhotosAsync(query, perPage: 20); _currentPhotos.Clear(); _currentPhotos.AddRange(photos); _currentIndex = 0; Console.WriteLine($\"Found {_client.LastPhotosSearchTotalResults:N0} photos ({photos.Count} loaded)\"); if (photos.Count > 0) { ShowCurrentPhoto(); } } private async Task LoadRandomPhoto() { Console.WriteLine(\"Loading random photo...\"); var photo = await _client.GetRandomPhotoAsync(); _currentPhotos.Clear(); _currentPhotos.Add(photo); _currentIndex = 0; ShowCurrentPhoto(); } private void ShowNextPhoto() { if (_currentPhotos.Count == 0) { Console.WriteLine(\"No photos loaded. Use 'search' or 'random' first.\"); return; } _currentIndex = (_currentIndex + 1) % _currentPhotos.Count; ShowCurrentPhoto(); } private void ShowPreviousPhoto() { if (_currentPhotos.Count == 0) { Console.WriteLine(\"No photos loaded. Use 'search' or 'random' first.\"); return; } _currentIndex = _currentIndex == 0 ? _currentPhotos.Count - 1 : _currentIndex - 1; ShowCurrentPhoto(); } private void ShowCurrentPhoto() { if (_currentPhotos.Count == 0) return; var photo = _currentPhotos[_currentIndex]; Console.WriteLine($\"Photo {_currentIndex + 1}/{_currentPhotos.Count}:\"); Console.WriteLine($\" ID: {photo.Id}\"); Console.WriteLine($\" Title: {photo.Description ?? \"Untitled\"}\"); Console.WriteLine($\" By: {photo.User.Name} (@{photo.User.Username})\"); Console.WriteLine($\" Size: {photo.Width}×{photo.Height}\"); Console.WriteLine($\" Likes: {photo.Likes:N0}\"); Console.WriteLine($\" URL: {photo.Urls.Regular}\"); } private void ShowCurrentPhotoInfo() { if (_currentPhotos.Count == 0) { Console.WriteLine(\"No photo selected.\"); return; } var photo = _currentPhotos[_currentIndex]; DisplayPhotoInfo(photo); // Use the method from earlier examples } private async Task DownloadCurrentPhoto() { if (_currentPhotos.Count == 0) { Console.WriteLine(\"No photo selected.\"); return; } var photo = _currentPhotos[_currentIndex]; var fileName = $\"{photo.Id}_{photo.User.Username}.jpg\"; Console.WriteLine($\"Downloading {fileName}...\"); try { using var httpClient = new HttpClient(); var imageBytes = await httpClient.GetByteArrayAsync(photo.Urls.Regular); await File.WriteAllBytesAsync(fileName, imageBytes); Console.WriteLine($\"Downloaded to {fileName} ({imageBytes.Length:N0} bytes)\"); } catch (Exception ex) { Console.WriteLine($\"Download failed: {ex.Message}\"); } } } // Usage class Program { static async Task Main(string[] args) { var browser = new ConsolePhotoBrowser(\"YOUR_APP_ID\"); await browser.RunAsync(); } } Background Services Photo Sync Service public class PhotoSyncService : BackgroundService { private readonly UnsplasharpClient _client; private readonly IServiceProvider _serviceProvider; private readonly ILogger<PhotoSyncService> _logger; private readonly PhotoSyncOptions _options; public PhotoSyncService( UnsplasharpClient client, IServiceProvider serviceProvider, ILogger<PhotoSyncService> logger, IOptions<PhotoSyncOptions> options) { _client = client; _serviceProvider = serviceProvider; _logger = logger; _options = options.Value; } protected override async Task ExecuteAsync(CancellationToken stoppingToken) { _logger.LogInformation(\"Photo sync service started\"); while (!stoppingToken.IsCancellationRequested) { try { await SyncPhotos(stoppingToken); await Task.Delay(_options.SyncInterval, stoppingToken); } catch (OperationCanceledException) { break; } catch (Exception ex) { _logger.LogError(ex, \"Error during photo sync\"); await Task.Delay(TimeSpan.FromMinutes(5), stoppingToken); // Wait before retry } } _logger.LogInformation(\"Photo sync service stopped\"); } private async Task SyncPhotos(CancellationToken cancellationToken) { using var scope = _serviceProvider.CreateScope(); var photoRepository = scope.ServiceProvider.GetRequiredService<IPhotoRepository>(); foreach (var query in _options.SyncQueries) { try { _logger.LogInformation(\"Syncing photos for query: {Query}\", query); var photos = await _client.SearchPhotosAsync(query, perPage: _options.PhotosPerQuery, cancellationToken: cancellationToken); foreach (var photo in photos) { await SyncSinglePhoto(photo, photoRepository, cancellationToken); } _logger.LogInformation(\"Synced {Count} photos for query: {Query}\", photos.Count, query); } catch (UnsplasharpRateLimitException ex) { _logger.LogWarning(\"Rate limited during sync, waiting {Delay}ms\", ex.TimeUntilReset?.TotalMilliseconds); if (ex.TimeUntilReset.HasValue) { await Task.Delay(ex.TimeUntilReset.Value, cancellationToken); } } catch (Exception ex) { _logger.LogError(ex, \"Error syncing photos for query: {Query}\", query); } } } private async Task SyncSinglePhoto(Photo photo, IPhotoRepository repository, CancellationToken cancellationToken) { try { var existingPhoto = await repository.GetByIdAsync(photo.Id); if (existingPhoto == null) { // New photo var photoEntity = MapToEntity(photo); await repository.AddAsync(photoEntity); _logger.LogDebug(\"Added new photo: {PhotoId}\", photo.Id); } else if (existingPhoto.UpdatedAt < DateTime.Parse(photo.UpdatedAt)) { // Updated photo var updatedEntity = MapToEntity(photo); await repository.UpdateAsync(updatedEntity); _logger.LogDebug(\"Updated photo: {PhotoId}\", photo.Id); } } catch (Exception ex) { _logger.LogError(ex, \"Error syncing photo: {PhotoId}\", photo.Id); } } private PhotoEntity MapToEntity(Photo photo) { return new PhotoEntity { Id = photo.Id, Description = photo.Description, Width = photo.Width, Height = photo.Height, Color = photo.Color, Likes = photo.Likes, Downloads = photo.Downloads, CreatedAt = DateTime.Parse(photo.CreatedAt), UpdatedAt = DateTime.Parse(photo.UpdatedAt), PhotographerName = photo.User.Name, PhotographerUsername = photo.User.Username, ThumbnailUrl = photo.Urls.Thumbnail, SmallUrl = photo.Urls.Small, RegularUrl = photo.Urls.Regular, FullUrl = photo.Urls.Full, LastSyncedAt = DateTime.UtcNow }; } } public class PhotoSyncOptions { public TimeSpan SyncInterval { get; set; } = TimeSpan.FromHours(1); public List<string> SyncQueries { get; set; } = new() { \"nature\", \"technology\", \"business\" }; public int PhotosPerQuery { get; set; } = 30; } public interface IPhotoRepository { Task<PhotoEntity?> GetByIdAsync(string id); Task AddAsync(PhotoEntity photo); Task UpdateAsync(PhotoEntity photo); } public class PhotoEntity { public string Id { get; set; } = string.Empty; public string? Description { get; set; } public int Width { get; set; } public int Height { get; set; } public string Color { get; set; } = string.Empty; public int Likes { get; set; } public int Downloads { get; set; } public DateTime CreatedAt { get; set; } public DateTime UpdatedAt { get; set; } public string PhotographerName { get; set; } = string.Empty; public string PhotographerUsername { get; set; } = string.Empty; public string ThumbnailUrl { get; set; } = string.Empty; public string SmallUrl { get; set; } = string.Empty; public string RegularUrl { get; set; } = string.Empty; public string FullUrl { get; set; } = string.Empty; public DateTime LastSyncedAt { get; set; } } // Registration in Program.cs services.Configure<PhotoSyncOptions>(configuration.GetSection(\"PhotoSync\")); services.AddHostedService<PhotoSyncService>(); Testing Patterns Unit Testing with Mocking [TestFixture] public class PhotoServiceTests { private Mock<UnsplasharpClient> _mockClient; private Mock<ILogger<PhotoService>> _mockLogger; private PhotoService _photoService; [SetUp] public void Setup() { _mockClient = new Mock<UnsplasharpClient>(\"test-app-id\"); _mockLogger = new Mock<ILogger<PhotoService>>(); _photoService = new PhotoService(_mockClient.Object, _mockLogger.Object); } [Test] public async Task GetRandomPhoto_Success_ReturnsPhoto() { // Arrange var expectedPhoto = CreateTestPhoto(); _mockClient.Setup(c => c.GetRandomPhotoAsync(It.IsAny<CancellationToken>())) .ReturnsAsync(expectedPhoto); // Act var result = await _photoService.GetRandomPhotoAsync(); // Assert Assert.IsNotNull(result); Assert.AreEqual(expectedPhoto.Id, result.Id); Assert.AreEqual(expectedPhoto.Description, result.Description); } [Test] public async Task GetRandomPhoto_RateLimited_ReturnsNull() { // Arrange _mockClient.Setup(c => c.GetRandomPhotoAsync(It.IsAny<CancellationToken>())) .ThrowsAsync(new UnsplasharpRateLimitException(\"Rate limited\", null, null, null, null, null)); // Act var result = await _photoService.GetRandomPhotoAsync(); // Assert Assert.IsNull(result); // Verify logging _mockLogger.Verify( x => x.Log( LogLevel.Warning, It.IsAny<EventId>(), It.Is<It.IsAnyType>((v, t) => v.ToString().Contains(\"Rate limited\")), It.IsAny<Exception>(), It.IsAny<Func<It.IsAnyType, Exception, string>>()), Times.Once); } [Test] public async Task SearchPhotos_WithValidQuery_ReturnsPhotos() { // Arrange var query = \"nature\"; var expectedPhotos = new List<Photo> { CreateTestPhoto(), CreateTestPhoto() }; _mockClient.Setup(c => c.SearchPhotosAsync(query, It.IsAny<int>(), It.IsAny<int>(), It.IsAny<OrderBy>(), It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>(), It.IsAny<Orientation>(), It.IsAny<CancellationToken>())) .ReturnsAsync(expectedPhotos); // Act var result = await _photoService.SearchPhotosAsync(query); // Assert Assert.IsNotNull(result); Assert.AreEqual(expectedPhotos.Count, result.Count); } private Photo CreateTestPhoto() { return new Photo { Id = Guid.NewGuid().ToString(), Description = \"Test photo\", Width = 1920, Height = 1080, Color = \"#FF5733\", Likes = 100, Downloads = 500, CreatedAt = DateTime.UtcNow.ToString(\"O\"), UpdatedAt = DateTime.UtcNow.ToString(\"O\"), User = new User { Id = Guid.NewGuid().ToString(), Name = \"Test Photographer\", Username = \"testuser\" }, Urls = new Urls { Thumbnail = \"https://example.com/thumb.jpg\", Small = \"https://example.com/small.jpg\", Regular = \"https://example.com/regular.jpg\", Full = \"https://example.com/full.jpg\", Raw = \"https://example.com/raw.jpg\" } }; } } public class PhotoService { private readonly UnsplasharpClient _client; private readonly ILogger<PhotoService> _logger; public PhotoService(UnsplasharpClient client, ILogger<PhotoService> logger) { _client = client; _logger = logger; } public async Task<Photo?> GetRandomPhotoAsync() { try { return await _client.GetRandomPhotoAsync(); } catch (UnsplasharpRateLimitException ex) { _logger.LogWarning(\"Rate limited: {Message}\", ex.Message); return null; } catch (UnsplasharpException ex) { _logger.LogError(ex, \"Error getting random photo\"); throw; } } public async Task<List<Photo>> SearchPhotosAsync(string query) { try { return await _client.SearchPhotosAsync(query); } catch (UnsplasharpException ex) { _logger.LogError(ex, \"Error searching photos with query: {Query}\", query); throw; } } } Integration Testing [TestFixture] public class UnsplashIntegrationTests { private UnsplasharpClient _client; private readonly string _testApplicationId = Environment.GetEnvironmentVariable(\"UNSPLASH_APP_ID\") ?? \"test-app-id\"; [SetUp] public void Setup() { _client = new UnsplasharpClient(_testApplicationId); } [Test] [Category(\"Integration\")] public async Task GetRandomPhoto_ReturnsValidPhoto() { // Act var photo = await _client.GetRandomPhotoAsync(); // Assert Assert.IsNotNull(photo); Assert.IsNotEmpty(photo.Id); Assert.IsNotNull(photo.User); Assert.IsNotEmpty(photo.User.Name); Assert.IsNotNull(photo.Urls); Assert.IsNotEmpty(photo.Urls.Regular); Assert.Greater(photo.Width, 0); Assert.Greater(photo.Height, 0); } [Test] [Category(\"Integration\")] public async Task SearchPhotos_WithValidQuery_ReturnsResults() { // Arrange var query = \"nature\"; // Act var photos = await _client.SearchPhotosAsync(query, perPage: 5); // Assert Assert.IsNotNull(photos); Assert.IsNotEmpty(photos); Assert.LessOrEqual(photos.Count, 5); foreach (var photo in photos) { Assert.IsNotEmpty(photo.Id); Assert.IsNotNull(photo.User); Assert.IsNotNull(photo.Urls); } } [Test] [Category(\"Integration\")] public async Task GetPhoto_WithInvalidId_ThrowsNotFoundException() { // Arrange var invalidId = \"invalid-photo-id-12345\"; // Act & Assert var ex = await Assert.ThrowsAsync<UnsplasharpNotFoundException>( () => _client.GetPhotoAsync(invalidId)); Assert.IsNotNull(ex.Context); Assert.AreEqual(invalidId, ex.ResourceId); } [Test] [Category(\"Integration\")] [Retry(3)] // Retry in case of rate limiting public async Task RateLimitHandling_MultipleRequests_HandlesGracefully() { var tasks = new List<Task<Photo>>(); // Create multiple concurrent requests for (int i = 0; i < 10; i++) { tasks.Add(_client.GetRandomPhotoAsync()); } // Some requests might fail due to rate limiting, but shouldn't crash var results = await Task.WhenAll(tasks.Select(async task => { try { return await task; } catch (UnsplasharpRateLimitException) { return null; // Expected for some requests } })); // At least some requests should succeed var successfulResults = results.Where(r => r != null).ToList(); Assert.Greater(successfulResults.Count, 0); } } Performance Optimization Caching Strategy public class OptimizedPhotoService { private readonly UnsplasharpClient _client; private readonly IMemoryCache _memoryCache; private readonly IDistributedCache _distributedCache; private readonly ILogger<OptimizedPhotoService> _logger; private readonly SemaphoreSlim _semaphore; public OptimizedPhotoService( UnsplasharpClient client, IMemoryCache memoryCache, IDistributedCache distributedCache, ILogger<OptimizedPhotoService> logger) { _client = client; _memoryCache = memoryCache; _distributedCache = distributedCache; _logger = logger; _semaphore = new SemaphoreSlim(5, 5); // Limit concurrent requests } public async Task<Photo?> GetPhotoOptimizedAsync(string photoId) { var cacheKey = $\"photo:{photoId}\"; // Try memory cache first (fastest) if (_memoryCache.TryGetValue(cacheKey, out Photo cachedPhoto)) { _logger.LogDebug(\"Photo {PhotoId} found in memory cache\", photoId); return cachedPhoto; } // Try distributed cache var distributedData = await _distributedCache.GetStringAsync(cacheKey); if (distributedData != null) { try { var photo = JsonSerializer.Deserialize<Photo>(distributedData); // Store in memory cache for faster future access _memoryCache.Set(cacheKey, photo, TimeSpan.FromMinutes(15)); _logger.LogDebug(\"Photo {PhotoId} found in distributed cache\", photoId); return photo; } catch (JsonException ex) { _logger.LogWarning(ex, \"Failed to deserialize cached photo {PhotoId}\", photoId); } } // Fetch from API with concurrency control await _semaphore.WaitAsync(); try { var photo = await _client.GetPhotoAsync(photoId); // Cache with intelligent TTL var memoryCacheDuration = CalculateCacheDuration(photo); _memoryCache.Set(cacheKey, photo, memoryCacheDuration); // Store in distributed cache var serializedPhoto = JsonSerializer.Serialize(photo); await _distributedCache.SetStringAsync(cacheKey, serializedPhoto, new DistributedCacheEntryOptions { AbsoluteExpirationRelativeToNow = memoryCacheDuration.Multiply(4) }); _logger.LogDebug(\"Photo {PhotoId} fetched from API and cached\", photoId); return photo; } catch (UnsplasharpNotFoundException) { // Cache negative results _memoryCache.Set(cacheKey, (Photo?)null, TimeSpan.FromMinutes(5)); return null; } finally { _semaphore.Release(); } } public async Task<List<Photo>> SearchPhotosOptimizedAsync(string query, int page = 1, int perPage = 20) { var cacheKey = $\"search:{query}:{page}:{perPage}\"; // Check cache first if (_memoryCache.TryGetValue(cacheKey, out List<Photo> cachedResults)) { return cachedResults; } await _semaphore.WaitAsync(); try { var photos = await _client.SearchPhotosAsync(query, page: page, perPage: perPage); // Cache search results for shorter time _memoryCache.Set(cacheKey, photos, TimeSpan.FromMinutes(5)); // Pre-cache individual photos foreach (var photo in photos) { var photoCacheKey = $\"photo:{photo.Id}\"; _memoryCache.Set(photoCacheKey, photo, CalculateCacheDuration(photo)); } return photos; } finally { _semaphore.Release(); } } private TimeSpan CalculateCacheDuration(Photo photo) { // Popular photos cached longer var popularity = photo.Likes + (photo.Downloads / 10); return popularity switch { > 10000 => TimeSpan.FromHours(2), > 1000 => TimeSpan.FromHours(1), > 100 => TimeSpan.FromMinutes(30), _ => TimeSpan.FromMinutes(15) }; } } Batch Processing Optimization public class BatchPhotoProcessor { private readonly UnsplasharpClient _client; private readonly ILogger<BatchPhotoProcessor> _logger; private readonly SemaphoreSlim _semaphore; public BatchPhotoProcessor(UnsplasharpClient client, ILogger<BatchPhotoProcessor> logger) { _client = client; _logger = logger; _semaphore = new SemaphoreSlim(3, 3); // Limit concurrent API calls } public async Task<List<Photo>> ProcessPhotosBatch(IEnumerable<string> photoIds, CancellationToken cancellationToken = default) { var results = new ConcurrentBag<Photo>(); var batches = photoIds.Chunk(10); // Process in batches of 10 foreach (var batch in batches) { var batchTasks = batch.Select(async photoId => { await _semaphore.WaitAsync(cancellationToken); try { var photo = await _client.GetPhotoAsync(photoId, cancellationToken); results.Add(photo); _logger.LogDebug(\"Processed photo {PhotoId}\", photoId); } catch (UnsplasharpNotFoundException) { _logger.LogWarning(\"Photo {PhotoId} not found\", photoId); } catch (UnsplasharpRateLimitException ex) { _logger.LogWarning(\"Rate limited, waiting {Delay}ms\", ex.TimeUntilReset?.TotalMilliseconds); if (ex.TimeUntilReset.HasValue) { await Task.Delay(ex.TimeUntilReset.Value, cancellationToken); } } catch (Exception ex) { _logger.LogError(ex, \"Error processing photo {PhotoId}\", photoId); } finally { _semaphore.Release(); } }); await Task.WhenAll(batchTasks); // Rate limiting courtesy delay between batches await Task.Delay(500, cancellationToken); } return results.ToList(); } } Connection Pool Optimization public static class UnsplashHttpOptimization { public static void ConfigureOptimizedHttpClient(this IServiceCollection services, string applicationId) { services.AddHttpClient(\"unsplash\", client => { client.BaseAddress = new Uri(\"https://api.unsplash.com/\"); client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Client-ID\", applicationId); client.Timeout = TimeSpan.FromSeconds(30); // Optimize headers client.DefaultRequestHeaders.Accept.Clear(); client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\")); client.DefaultRequestHeaders.AcceptEncoding.Add(new StringWithQualityHeaderValue(\"gzip\")); client.DefaultRequestHeaders.AcceptEncoding.Add(new StringWithQualityHeaderValue(\"deflate\")); }) .ConfigurePrimaryHttpMessageHandler(() => new SocketsHttpHandler { // Connection pooling optimization PooledConnectionLifetime = TimeSpan.FromMinutes(15), PooledConnectionIdleTimeout = TimeSpan.FromMinutes(5), MaxConnectionsPerServer = 10, // Performance settings EnableMultipleHttp2Connections = true, UseCookies = false, AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate, // DNS optimization UseProxy = false }); } } This comprehensive collection of code examples and recipes covers the most common use cases for Unsplasharp, from basic operations to advanced integration patterns. Each example includes proper error handling, performance considerations, and follows modern C# best practices. Key takeaways: Always implement proper error handling with specific exception types Use caching strategies to improve performance and reduce API calls Implement rate limiting awareness in your applications Consider using dependency injection for better testability Use cancellation tokens for responsive applications Follow async/await best practices throughout your code"
  },
  "docs/downloading-a-photo.html": {
    "href": "docs/downloading-a-photo.html",
    "title": "Downloading a Photo | Unsplasharp Documentation",
    "summary": "Downloading a Photo This section explains how to download an Unsplash photo using the Unsplasharp DSK (Developer SDK) library. Prerequisites Before you begin, ensure you have: An Unsplash API key. If you don't have one, refer to the Obtaining an API Key guide. The Unsplasharp library installed in your project. Example: Downloading a Photo To download a photo, you typically need the photo's ID. You can then use the UnsplasharpClient to retrieve the photo details and its download link. using Unsplasharp; using System; using System.Net.Http; using System.Threading.Tasks; using System.IO; public class PhotoDownloader { public static async Task Main(string[] args) { // Replace with your actual Unsplash API key string apiKey = \"YOUR_UNSPLASH_API_KEY\"; // Replace with the ID of the photo you want to download string photoId = \"PHOTO_ID_TO_DOWNLOAD\"; // Replace with the desired path to save the downloaded photo string downloadPath = \"path/to/your/downloaded_photo.jpg\"; var client = new UnsplasharpClient(apiKey); try { // Get photo details var photo = await client.GetPhoto(photoId); if (photo != null && !string.IsNullOrEmpty(photo.Links.DownloadLocation)) { // Unsplash requires you to hit the download location endpoint to register a download // before you can download the actual image. var downloadLink = await client.GetPhotoDownloadLink(photoId); if (!string.IsNullOrEmpty(downloadLink)) { using (HttpClient httpClient = new HttpClient()) { // Download the image byte[] imageBytes = await httpClient.GetByteArrayAsync(downloadLink); await File.WriteAllBytesAsync(downloadPath, imageBytes); Console.WriteLine($\"Photo downloaded successfully to: {downloadPath}\"); } } else { Console.WriteLine(\"Could not retrieve download link for the photo.\"); } } else { Console.WriteLine($\"Photo with ID '{photoId}' not found or download link is missing.\"); } } catch (Exception ex) { Console.WriteLine($\"An error occurred: {ex.Message}\"); } } } Remember to replace \"YOUR_UNSPLASH_API_KEY\", \"PHOTO_ID_TO_DOWNLOAD\", and \"path/to/your/downloaded_photo.jpg\" with your actual values. Important Considerations API Key: Always keep your API key secure and do not expose it in client-side code. Download Tracking: Unsplash requires you to trigger the download_location endpoint before you can download the actual image. This is important for their download statistics. The GetPhotoDownloadLink method handles this for you. Error Handling: Implement robust error handling to gracefully manage API errors, network issues, or invalid photo IDs. Rate Limiting: Be mindful of Unsplash API rate limits. If you exceed them, your requests might be temporarily blocked."
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started with Unsplasharp | Unsplasharp Documentation",
    "summary": "Getting Started with Unsplasharp This comprehensive guide will walk you through setting up and using Unsplasharp in your .NET application, from basic installation to advanced usage patterns. Table of Contents Prerequisites Installation Getting Your API Key Basic Setup Your First Request Common Use Cases Error Handling Best Practices Next Steps Prerequisites Before you begin, ensure you have: .NET 6.0 or later (or .NET Framework 4.6.1+, .NET Standard 2.0+) An Unsplash API key - See Getting Your API Key below Basic knowledge of C# and async/await Installation Package Manager Console Install-Package Unsplasharp .NET CLI dotnet add package Unsplasharp PackageReference (in .csproj) <PackageReference Include=\"Unsplasharp\" Version=\"*\" /> Getting Your API Key Create an Unsplash Account: Visit unsplash.com and sign up Join as Developer: Go to Unsplash for Developers Create New Application: Visit your applications dashboard Click \"New Application\" Accept the API terms Fill in your application details Get Your Access Key: Copy the \"Access Key\" - this is your ApplicationId Important: Keep your API key secure and never expose it in client-side code or public repositories. Basic Setup Simple Console Application using Unsplasharp; using System; using System.Threading.Tasks; class Program { static async Task Main(string[] args) { // Replace with your actual Application ID var client = new UnsplasharpClient(\"YOUR_APPLICATION_ID\"); try { var photo = await client.GetRandomPhoto(); Console.WriteLine($\"Random photo by {photo?.User?.Name}\"); Console.WriteLine($\"URL: {photo?.Urls?.Regular}\"); } catch (Exception ex) { Console.WriteLine($\"Error: {ex.Message}\"); } } } ASP.NET Core Setup Program.cs: using Unsplasharp.Extensions; var builder = WebApplication.CreateBuilder(args); // Add Unsplasharp to dependency injection builder.Services.AddUnsplasharp(\"YOUR_APPLICATION_ID\"); // Or configure from appsettings.json builder.Services.AddUnsplasharp(options => { options.ApplicationId = builder.Configuration[\"Unsplash:ApplicationId\"]; options.ConfigureHttpClient = client => { client.Timeout = TimeSpan.FromSeconds(30); }; }); var app = builder.Build(); Controller: [ApiController] [Route(\"api/[controller]\")] public class PhotosController : ControllerBase { private readonly UnsplasharpClient _unsplashClient; public PhotosController(UnsplasharpClient unsplashClient) { _unsplashClient = unsplashClient; } [HttpGet(\"random\")] public async Task<IActionResult> GetRandomPhoto() { try { var photo = await _unsplashClient.GetRandomPhoto(); return Ok(new { id = photo?.Id, description = photo?.Description, author = photo?.User?.Name, url = photo?.Urls?.Regular }); } catch (Exception ex) { return StatusCode(500, new { error = ex.Message }); } } } Your First Request Let's start with a simple example that demonstrates the basic workflow: using Unsplasharp; using System; using System.Threading.Tasks; public class UnsplashExample { private readonly UnsplasharpClient _client; public UnsplashExample() { _client = new UnsplasharpClient(\"YOUR_APPLICATION_ID\"); } public async Task GetRandomPhotoExample() { try { // Get a random photo var photo = await _client.GetRandomPhoto(); if (photo != null) { Console.WriteLine(\"=== Random Photo ===\"); Console.WriteLine($\"ID: {photo.Id}\"); Console.WriteLine($\"Description: {photo.Description ?? \"No description\"}\"); Console.WriteLine($\"Author: {photo.User.Name} (@{photo.User.Username})\"); Console.WriteLine($\"Dimensions: {photo.Width}x{photo.Height}\"); Console.WriteLine($\"Likes: {photo.Likes:N0}\"); Console.WriteLine($\"Downloads: {photo.Downloads:N0}\"); Console.WriteLine($\"Color: {photo.Color}\"); Console.WriteLine($\"Regular URL: {photo.Urls.Regular}\"); Console.WriteLine($\"Small URL: {photo.Urls.Small}\"); // Check if location data is available if (!string.IsNullOrEmpty(photo.Location.Name)) { Console.WriteLine($\"Location: {photo.Location.Name}\"); } // Check EXIF data if (!string.IsNullOrEmpty(photo.Exif.Make)) { Console.WriteLine($\"Camera: {photo.Exif.Make} {photo.Exif.Model}\"); } } else { Console.WriteLine(\"No photo received\"); } } catch (Exception ex) { Console.WriteLine($\"Error getting random photo: {ex.Message}\"); } } } Common Use Cases 1. Search for Photos public async Task SearchPhotosExample() { try { // Basic search var photos = await _client.SearchPhotos(\"mountain landscape\", page: 1, perPage: 10); Console.WriteLine($\"Found {photos.Count} photos\"); Console.WriteLine($\"Total results: {_client.LastPhotosSearchTotalResults:N0}\"); Console.WriteLine($\"Total pages: {_client.LastPhotosSearchTotalPages}\"); foreach (var photo in photos) { Console.WriteLine($\"- {photo.Id}: {photo.Description ?? \"Untitled\"}\"); Console.WriteLine($\" By: {photo.User.Name} | Likes: {photo.Likes}\"); } } catch (Exception ex) { Console.WriteLine($\"Search error: {ex.Message}\"); } } 2. Get Photos from a Collection public async Task GetCollectionPhotosExample() { try { // First, get collection details var collection = await _client.GetCollection(\"499830\"); // Nature collection if (collection != null) { Console.WriteLine($\"Collection: {collection.Title}\"); Console.WriteLine($\"Description: {collection.Description}\"); Console.WriteLine($\"Total photos: {collection.TotalPhotos}\"); Console.WriteLine($\"Created by: {collection.User.Name}\"); // Get photos from the collection var photos = await _client.GetCollectionPhotos(collection.Id, page: 1, perPage: 5); Console.WriteLine(\"\\nFirst 5 photos:\"); foreach (var photo in photos) { Console.WriteLine($\"- {photo.Description ?? \"Untitled\"} by {photo.User.Name}\"); } } } catch (Exception ex) { Console.WriteLine($\"Collection error: {ex.Message}\"); } } 3. Get User Information and Photos public async Task GetUserPhotosExample() { try { var username = \"chrisjoelcampbell\"; // Get user profile var user = await _client.GetUser(username); if (user != null) { Console.WriteLine($\"User: {user.Name} (@{user.Username})\"); Console.WriteLine($\"Bio: {user.Bio}\"); Console.WriteLine($\"Location: {user.Location}\"); Console.WriteLine($\"Total photos: {user.TotalPhotos:N0}\"); Console.WriteLine($\"Total likes: {user.TotalLikes:N0}\"); Console.WriteLine($\"Portfolio: {user.PortfolioUrl}\"); // Get user's photos var userPhotos = await _client.GetUserPhotos(username, page: 1, perPage: 5); Console.WriteLine($\"\\nRecent photos by {user.Name}:\"); foreach (var photo in userPhotos) { Console.WriteLine($\"- {photo.Description ?? \"Untitled\"}\"); Console.WriteLine($\" {photo.Width}x{photo.Height} | {photo.Likes} likes\"); } } } catch (Exception ex) { Console.WriteLine($\"User error: {ex.Message}\"); } } 4. Download a Photo public async Task DownloadPhotoExample() { try { var photoId = \"qcs09SwNPHY\"; // Example photo ID // Get photo details var photo = await _client.GetPhoto(photoId); if (photo != null) { Console.WriteLine($\"Downloading: {photo.Description ?? \"Untitled\"}\"); Console.WriteLine($\"By: {photo.User.Name}\"); // Use HttpClient to download the image using var httpClient = new HttpClient(); // Download different sizes var sizes = new Dictionary<string, string> { [\"thumbnail\"] = photo.Urls.Thumbnail, [\"small\"] = photo.Urls.Small, [\"regular\"] = photo.Urls.Regular }; foreach (var (sizeName, url) in sizes) { try { var imageBytes = await httpClient.GetByteArrayAsync(url); var fileName = $\"{photo.Id}_{sizeName}.jpg\"; await File.WriteAllBytesAsync(fileName, imageBytes); Console.WriteLine($\"Downloaded {sizeName}: {fileName} ({imageBytes.Length:N0} bytes)\"); } catch (Exception downloadEx) { Console.WriteLine($\"Failed to download {sizeName}: {downloadEx.Message}\"); } } } } catch (Exception ex) { Console.WriteLine($\"Download error: {ex.Message}\"); } } 5. Pagination Example public async Task PaginationExample() { try { var query = \"sunset\"; var allPhotos = new List<Photo>(); var maxPages = 3; // Limit for demo Console.WriteLine($\"Searching for '{query}' across {maxPages} pages...\"); for (int page = 1; page <= maxPages; page++) { var photos = await _client.SearchPhotos(query, page: page, perPage: 20); if (photos.Count == 0) { Console.WriteLine($\"No more results at page {page}\"); break; } allPhotos.AddRange(photos); Console.WriteLine($\"Page {page}: {photos.Count} photos\"); // Be respectful of rate limits await Task.Delay(100); } Console.WriteLine($\"Total photos collected: {allPhotos.Count}\"); Console.WriteLine($\"Total available: {_client.LastPhotosSearchTotalResults:N0}\"); } catch (Exception ex) { Console.WriteLine($\"Pagination error: {ex.Message}\"); } } 6. Advanced Search with Filters public async Task AdvancedSearchExample() { try { // Search with multiple filters var photos = await _client.SearchPhotos( query: \"ocean waves\", page: 1, perPage: 15, orderBy: OrderBy.Popular, color: \"blue\", orientation: Orientation.Landscape ); Console.WriteLine(\"Advanced search results:\"); Console.WriteLine($\"Query: ocean waves\"); Console.WriteLine($\"Filters: blue color, landscape orientation, popular order\"); Console.WriteLine($\"Results: {photos.Count} photos\"); foreach (var photo in photos.Take(5)) { Console.WriteLine($\"- {photo.Description ?? \"Untitled\"}\"); Console.WriteLine($\" {photo.Width}x{photo.Height} | Color: {photo.Color}\"); Console.WriteLine($\" Likes: {photo.Likes} | Downloads: {photo.Downloads}\"); } } catch (Exception ex) { Console.WriteLine($\"Advanced search error: {ex.Message}\"); } } Error Handling Unsplasharp provides comprehensive error handling with specific exception types. Here's how to handle different error scenarios: Basic Error Handling public async Task BasicErrorHandlingExample() { try { var photo = await _client.GetPhoto(\"invalid-photo-id\"); // Handle success } catch (Exception ex) { Console.WriteLine($\"Error: {ex.Message}\"); // Basic error handling - not recommended for production } } Advanced Error Handling (Recommended) public async Task AdvancedErrorHandlingExample() { try { // Use the exception-throwing version for better error handling var photo = await _client.GetPhotoAsync(\"some-photo-id\"); Console.WriteLine($\"Successfully retrieved: {photo.Description}\"); } catch (UnsplasharpNotFoundException ex) { Console.WriteLine(\"Photo not found - it may have been deleted or made private\"); // Handle gracefully - maybe show a placeholder or try alternative } catch (UnsplasharpRateLimitException ex) { Console.WriteLine($\"Rate limit exceeded: {ex.RateLimitRemaining}/{ex.RateLimit}\"); Console.WriteLine($\"Reset time: {ex.RateLimitReset}\"); // Wait until reset time if (ex.RateLimitReset.HasValue) { var waitTime = ex.RateLimitReset.Value - DateTimeOffset.UtcNow; if (waitTime > TimeSpan.Zero) { Console.WriteLine($\"Waiting {waitTime.TotalMinutes:F1} minutes...\"); await Task.Delay(waitTime); // Retry the request } } } catch (UnsplasharpAuthenticationException ex) { Console.WriteLine(\"Authentication failed - check your API key\"); // Log the error and potentially refresh credentials } catch (UnsplasharpNetworkException ex) { Console.WriteLine($\"Network error: {ex.Message}\"); if (ex.IsRetryable) { Console.WriteLine(\"This error is retryable - implementing exponential backoff\"); // Implement retry logic with exponential backoff } } catch (UnsplasharpTimeoutException ex) { Console.WriteLine($\"Request timed out after {ex.Timeout}\"); // Consider increasing timeout or checking network conditions } catch (UnsplasharpException ex) { Console.WriteLine($\"Unsplash API error: {ex.Message}\"); // Access rich error context if (ex.Context != null) { Console.WriteLine($\"Correlation ID: {ex.Context.CorrelationId}\"); Console.WriteLine($\"Timestamp: {ex.Context.Timestamp}\"); Console.WriteLine($\"Request URL: {ex.RequestUrl}\"); // Check rate limit info if (ex.Context.RateLimitInfo != null) { var rateLimit = ex.Context.RateLimitInfo; Console.WriteLine($\"Rate limit: {rateLimit.Remaining}/{rateLimit.Limit}\"); } } } } Retry Logic with Exponential Backoff public async Task<Photo?> GetPhotoWithRetry(string photoId, int maxRetries = 3) { for (int attempt = 1; attempt <= maxRetries; attempt++) { try { return await _client.GetPhotoAsync(photoId); } catch (UnsplasharpNetworkException ex) when (ex.IsRetryable && attempt < maxRetries) { var delay = TimeSpan.FromSeconds(Math.Pow(2, attempt)); // Exponential backoff Console.WriteLine($\"Attempt {attempt} failed, retrying in {delay.TotalSeconds}s...\"); await Task.Delay(delay); } catch (UnsplasharpRateLimitException ex) when (attempt < maxRetries) { var delay = ex.TimeUntilReset ?? TimeSpan.FromMinutes(1); Console.WriteLine($\"Rate limited, waiting {delay.TotalMinutes:F1} minutes...\"); await Task.Delay(delay); } catch (UnsplasharpNotFoundException) { // Don't retry for not found errors Console.WriteLine($\"Photo {photoId} not found\"); return null; } } throw new InvalidOperationException($\"Failed to get photo after {maxRetries} attempts\"); } Best Practices 1. Use Dependency Injection // In Program.cs or Startup.cs services.AddUnsplasharp(options => { options.ApplicationId = configuration[\"Unsplash:ApplicationId\"]; options.ConfigureHttpClient = client => { client.Timeout = TimeSpan.FromSeconds(30); }; }); // In your service public class PhotoService { private readonly UnsplasharpClient _client; private readonly ILogger<PhotoService> _logger; public PhotoService(UnsplasharpClient client, ILogger<PhotoService> logger) { _client = client; _logger = logger; } public async Task<List<Photo>> GetFeaturedPhotos(int count = 10) { try { return await _client.ListPhotos(page: 1, perPage: count, orderBy: OrderBy.Popular); } catch (UnsplasharpException ex) { _logger.LogError(ex, \"Failed to get featured photos\"); return new List<Photo>(); } } } 2. Implement Caching public class CachedPhotoService { private readonly UnsplasharpClient _client; private readonly IMemoryCache _cache; private readonly ILogger<CachedPhotoService> _logger; public CachedPhotoService(UnsplasharpClient client, IMemoryCache cache, ILogger<CachedPhotoService> logger) { _client = client; _cache = cache; _logger = logger; } public async Task<Photo?> GetPhotoAsync(string photoId) { var cacheKey = $\"photo:{photoId}\"; if (_cache.TryGetValue(cacheKey, out Photo cachedPhoto)) { _logger.LogDebug(\"Photo {PhotoId} found in cache\", photoId); return cachedPhoto; } try { var photo = await _client.GetPhotoAsync(photoId); // Cache for 1 hour _cache.Set(cacheKey, photo, TimeSpan.FromHours(1)); _logger.LogDebug(\"Photo {PhotoId} cached\", photoId); return photo; } catch (UnsplasharpNotFoundException) { // Cache negative results for shorter time _cache.Set(cacheKey, (Photo?)null, TimeSpan.FromMinutes(5)); return null; } } } 3. Monitor Rate Limits public class RateLimitAwareService { private readonly UnsplasharpClient _client; private readonly ILogger<RateLimitAwareService> _logger; public RateLimitAwareService(UnsplasharpClient client, ILogger<RateLimitAwareService> logger) { _client = client; _logger = logger; } public async Task<List<Photo>> SearchPhotosWithRateLimit(string query, int maxResults = 100) { var allPhotos = new List<Photo>(); var perPage = 30; var maxPages = (maxResults + perPage - 1) / perPage; for (int page = 1; page <= maxPages; page++) { // Check rate limit before making request if (_client.RateLimitRemaining < 10) { _logger.LogWarning(\"Rate limit running low: {Remaining}/{Max}\", _client.RateLimitRemaining, _client.MaxRateLimit); // Pause to avoid hitting the limit await Task.Delay(TimeSpan.FromSeconds(30)); } try { var photos = await _client.SearchPhotosAsync(query, page: page, perPage: perPage); allPhotos.AddRange(photos); _logger.LogDebug(\"Page {Page}: {Count} photos, Rate limit: {Remaining}/{Max}\", page, photos.Count, _client.RateLimitRemaining, _client.MaxRateLimit); if (photos.Count < perPage) { // No more results break; } } catch (UnsplasharpRateLimitException ex) { _logger.LogWarning(\"Rate limit exceeded, stopping search\"); break; } } return allPhotos.Take(maxResults).ToList(); } } 4. Use Cancellation Tokens public class ResponsivePhotoService { private readonly UnsplasharpClient _client; public ResponsivePhotoService(UnsplasharpClient client) { _client = client; } public async Task<List<Photo>> SearchWithTimeout(string query, TimeSpan timeout) { using var cts = new CancellationTokenSource(timeout); try { return await _client.SearchPhotosAsync(query, cancellationToken: cts.Token); } catch (OperationCanceledException) { Console.WriteLine($\"Search for '{query}' timed out after {timeout.TotalSeconds}s\"); return new List<Photo>(); } } public async Task<Photo?> GetPhotoWithCancellation(string photoId, CancellationToken cancellationToken) { try { return await _client.GetPhotoAsync(photoId, cancellationToken); } catch (OperationCanceledException) { Console.WriteLine(\"Operation was cancelled\"); return null; } } } 5. Configuration Management appsettings.json: { \"Unsplash\": { \"ApplicationId\": \"YOUR_APPLICATION_ID\", \"Secret\": \"YOUR_SECRET\", \"DefaultTimeout\": \"00:00:30\", \"MaxRetries\": 3, \"CacheEnabled\": true, \"CacheDuration\": \"01:00:00\" }, \"Logging\": { \"LogLevel\": { \"Unsplasharp\": \"Information\" } } } Configuration class: public class UnsplashConfiguration { public string ApplicationId { get; set; } = string.Empty; public string? Secret { get; set; } public TimeSpan DefaultTimeout { get; set; } = TimeSpan.FromSeconds(30); public int MaxRetries { get; set; } = 3; public bool CacheEnabled { get; set; } = true; public TimeSpan CacheDuration { get; set; } = TimeSpan.FromHours(1); } Service registration: // In Program.cs var unsplashConfig = builder.Configuration.GetSection(\"Unsplash\").Get<UnsplashConfiguration>(); builder.Services.AddSingleton(unsplashConfig); builder.Services.AddMemoryCache(); builder.Services.AddUnsplasharp(options => { options.ApplicationId = unsplashConfig.ApplicationId; options.Secret = unsplashConfig.Secret; options.ConfigureHttpClient = client => { client.Timeout = unsplashConfig.DefaultTimeout; }; }); Next Steps Congratulations! You now have a solid foundation for using Unsplasharp. Here are some recommended next steps: 1. Explore Advanced Features API Reference Guide - Complete method documentation Error Handling Guide - Comprehensive error handling strategies IHttpClientFactory Integration - Production-ready HTTP client management Logging Guide - Structured logging and monitoring 2. Common Integration Patterns Image Gallery Applications - Build photo galleries with search and filtering Background Image Services - Provide dynamic backgrounds for applications Content Management Systems - Integrate stock photos into CMS platforms Social Media Tools - Create tools for social media content creation 3. Performance Optimization Implement caching to reduce API calls and improve response times Use pagination effectively for large result sets Monitor rate limits to avoid service interruptions Implement retry logic for resilient applications 4. Production Considerations Security: Never expose API keys in client-side code Monitoring: Set up logging and monitoring for API usage Error Handling: Implement comprehensive error handling strategies Testing: Write unit tests for your Unsplash integration 5. Sample Projects Consider building these sample projects to practice: // 1. Photo Search CLI Tool public class PhotoSearchTool { public async Task RunAsync(string[] args) { var query = args.Length > 0 ? args[0] : \"nature\"; var client = new UnsplasharpClient(\"YOUR_APP_ID\"); var photos = await client.SearchPhotos(query, perPage: 10); foreach (var photo in photos) { Console.WriteLine($\"{photo.User.Name}: {photo.Description}\"); Console.WriteLine($\" {photo.Urls.Small}\"); } } } // 2. Random Wallpaper Downloader public class WallpaperDownloader { public async Task DownloadRandomWallpaper(string category = \"landscape\") { var client = new UnsplasharpClient(\"YOUR_APP_ID\"); var photo = await client.GetRandomPhoto(query: category, orientation: Orientation.Landscape); if (photo != null) { using var httpClient = new HttpClient(); var imageBytes = await httpClient.GetByteArrayAsync(photo.Urls.Full); var fileName = $\"wallpaper_{photo.Id}.jpg\"; await File.WriteAllBytesAsync(fileName, imageBytes); Console.WriteLine($\"Downloaded wallpaper: {fileName}\"); Console.WriteLine($\"By: {photo.User.Name}\"); } } } // 3. Photo Collection Manager public class CollectionManager { private readonly UnsplasharpClient _client; public CollectionManager(string appId) { _client = new UnsplasharpClient(appId); } public async Task ExploreCollection(string collectionId) { var collection = await _client.GetCollection(collectionId); var photos = await _client.GetCollectionPhotos(collectionId, perPage: 20); Console.WriteLine($\"Collection: {collection?.Title}\"); Console.WriteLine($\"Photos: {photos.Count}\"); foreach (var photo in photos) { Console.WriteLine($\" - {photo.Description ?? \"Untitled\"} by {photo.User.Name}\"); } } } 6. Community and Support GitHub Repository: github.com/rootasjey/unsplasharp Issues and Bug Reports: Use GitHub Issues for bug reports and feature requests Unsplash API Documentation: unsplash.com/documentation Unsplash Developer Guidelines: Follow Unsplash's API guidelines and terms of service 7. Contributing If you'd like to contribute to Unsplasharp: Fork the repository Create a feature branch Make your changes Add tests for new functionality Submit a pull request You're now ready to build amazing applications with Unsplasharp! Remember to always respect Unsplash's API rate limits and terms of service, and consider implementing proper error handling and caching for production applications."
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introduction | Unsplasharp Documentation",
    "summary": "Introduction Welcome to the documentation for Unsplasharp, a modern, asynchronous, and feature-rich .NET library for interacting with the Unsplash API. What is Unsplasharp? Unsplasharp is a .NET Standard 2.0 library that provides a convenient and easy-to-use wrapper around the Unsplash API. It allows you to easily integrate Unsplash's vast library of high-quality photos into your .NET applications. Features Modern and Asynchronous: Built with async/await for non-blocking I/O. Comprehensive Error Handling: Provides specific exception types for different error scenarios. IHttpClientFactory Integration: Supports IHttpClientFactory for efficient management of HttpClient instances. Structured Logging: Integrates with Microsoft.Extensions.Logging for detailed insights. System.Text.Json: Uses the high-performance System.Text.Json for JSON serialization. Full API Coverage: Provides access to all of the Unsplash API endpoints. Getting Help If you need help or have any questions, please feel free to open an issue on GitHub."
  },
  "docs/obtaining-an-api-key.html": {
    "href": "docs/obtaining-an-api-key.html",
    "title": "Obtaining an API Key | Unsplasharp Documentation",
    "summary": "Obtaining an API Key To use the Unsplash API, you need to register as a developer and create an application to get an API key. Steps Create an Unsplash Account: If you don't have an Unsplash account, you'll need to create one at unsplash.com. Join as a Developer: Go to the Unsplash for Developers page and click \"Join as a Developer\". Register a New Application: Go to your applications dashboard. Click the \"New Application\" button. Read and accept the API terms. Fill out the application details: Application Name: A descriptive name for your application. Description: A brief description of what your application does. Click \"Create Application\". Get Your API Keys: After creating the application, you'll be redirected to the application's page. You will find your Access Key and Secret Key. The Access Key is what you'll use as your ApplicationId in Unsplasharp. API Usage Limits The Unsplash API has the following rate limits for new applications: Demo: 50 requests per hour. Production: 5000 requests per hour (requires approval from Unsplash). You can see your current rate limit status in the response headers of each API call. Unsplasharp provides this information in the RateLimitInfo property of the UnsplasharpException and ErrorContext classes."
  },
  "error-handling.html": {
    "href": "error-handling.html",
    "title": "Comprehensive Error Handling in Unsplasharp | Unsplasharp Documentation",
    "summary": "Comprehensive Error Handling in Unsplasharp This document describes the comprehensive error handling system introduced in Unsplasharp, providing structured exceptions with rich context information for better debugging and error recovery. Overview The new error handling system provides: Specific Exception Types: Different exceptions for different error scenarios Rich Error Context: Detailed information about requests, responses, and timing Intelligent Retry Logic: Smart retry decisions based on error types Backward Compatibility: Existing methods continue to work as before Enhanced Debugging: Correlation IDs and structured logging Exception Hierarchy Base Exception: UnsplasharpException All Unsplasharp-specific exceptions inherit from UnsplasharpException, which provides: public abstract class UnsplasharpException : Exception { public string? RequestUrl { get; } // The URL that caused the error public string? HttpMethod { get; } // HTTP method used public ErrorContext? Context { get; } // Rich error context } Specific Exception Types UnsplasharpHttpException For HTTP-related errors with status codes: public class UnsplasharpHttpException : UnsplasharpException { public HttpStatusCode? StatusCode { get; } // HTTP status code public string? ResponseContent { get; } // Response body public bool IsRetryable { get; } // Whether error is retryable } UnsplasharpAuthenticationException For authentication failures (401 Unauthorized): var client = new UnsplasharpClient(\"invalid_app_id\"); try { var photo = await client.GetRandomPhotoAsync(); } catch (UnsplasharpAuthenticationException ex) { Console.WriteLine($\"Authentication failed: {ex.Message}\"); // Check your application ID } UnsplasharpNotFoundException For resource not found errors (404 Not Found): try { var photo = await client.GetPhotoAsync(\"invalid_photo_id\"); } catch (UnsplasharpNotFoundException ex) { Console.WriteLine($\"Photo '{ex.ResourceId}' not found\"); Console.WriteLine($\"Resource type: {ex.ResourceType}\"); } UnsplasharpRateLimitException For rate limit exceeded errors (429 Too Many Requests): try { var photos = await client.SearchPhotosAsync(\"nature\"); } catch (UnsplasharpRateLimitException ex) { Console.WriteLine($\"Rate limit exceeded: {ex.RateLimitRemaining}/{ex.RateLimit}\"); Console.WriteLine($\"Reset time: {ex.RateLimitReset}\"); // Wait until reset time or implement exponential backoff if (ex.RateLimitReset.HasValue) { var waitTime = ex.RateLimitReset.Value - DateTimeOffset.UtcNow; await Task.Delay(waitTime); } } UnsplasharpNetworkException For network-related errors: try { var photo = await client.GetRandomPhotoAsync(); } catch (UnsplasharpNetworkException ex) { if (ex.IsRetryable) { Console.WriteLine(\"Network error occurred, retrying...\"); // Implement retry logic } else { Console.WriteLine(\"Permanent network error\"); } } UnsplasharpTimeoutException For request timeout errors: try { var photo = await client.GetRandomPhotoAsync(); } catch (UnsplasharpTimeoutException ex) { Console.WriteLine($\"Request timed out after {ex.Timeout}\"); // Consider increasing timeout or checking network conditions } UnsplasharpParsingException For JSON parsing errors: try { var photo = await client.GetRandomPhotoAsync(); } catch (UnsplasharpParsingException ex) { Console.WriteLine($\"Failed to parse response: {ex.Message}\"); Console.WriteLine($\"Expected type: {ex.ExpectedType}\"); // Log raw content for debugging: ex.RawContent } Error Context Every exception includes an ErrorContext object with detailed information: public class ErrorContext { public DateTimeOffset Timestamp { get; } // When error occurred public string? ApplicationId { get; } // Your app ID public string? CorrelationId { get; } // Unique request ID public Dictionary<string, string> RequestHeaders { get; } public Dictionary<string, string> ResponseHeaders { get; } public RateLimitInfo? RateLimitInfo { get; } // Rate limit details public Dictionary<string, object> Properties { get; } // Custom properties } Using Error Context try { var photo = await client.GetRandomPhotoAsync(); } catch (UnsplasharpException ex) { var context = ex.Context; Console.WriteLine($\"Error occurred at: {context?.Timestamp}\"); Console.WriteLine($\"Correlation ID: {context?.CorrelationId}\"); Console.WriteLine($\"Summary: {context?.ToSummary()}\"); // Access rate limit information if (context?.RateLimitInfo != null) { var rateLimit = context.RateLimitInfo; Console.WriteLine($\"Rate limit: {rateLimit.Remaining}/{rateLimit.Limit}\"); } } Backward Compatibility Existing methods continue to work exactly as before, returning null or empty collections on errors: // Old approach - still works var photo = await client.GetRandomPhoto(); // Returns null on error if (photo == null) { Console.WriteLine(\"Failed to get photo\"); } // New approach - throws exceptions try { var photo = await client.GetRandomPhotoAsync(); // Throws on error Console.WriteLine($\"Got photo: {photo.Id}\"); } catch (UnsplasharpException ex) { Console.WriteLine($\"Error: {ex.Message}\"); } Migration Guide For New Code Use the new *Async methods that throw exceptions: // Instead of: var photo = await client.GetRandomPhoto(); if (photo == null) { /* handle error */ } // Use: try { var photo = await client.GetRandomPhotoAsync(); // Use photo } catch (UnsplasharpException ex) { // Handle specific error types } For Existing Code No changes required - existing methods maintain their behavior: // This continues to work unchanged var photos = await client.SearchPhotos(\"nature\"); if (photos.Count == 0) { // Handle no results or error } Gradual Migration You can migrate gradually by replacing method calls one at a time: // Step 1: Replace method call // var photo = await client.GetRandomPhoto(); var photo = await client.GetRandomPhotoAsync(); // Step 2: Add exception handling try { var photo = await client.GetRandomPhotoAsync(); // Use photo } catch (UnsplasharpNotFoundException) { // Handle not found } catch (UnsplasharpRateLimitException ex) { // Handle rate limiting await Task.Delay(ex.TimeUntilReset ?? TimeSpan.FromMinutes(1)); } catch (UnsplasharpException ex) { // Handle other errors logger.LogError(ex, \"Unsplash API error: {Context}\", ex.Context?.ToSummary()); } Best Practices 1. Handle Specific Exception Types try { var photo = await client.GetPhotoAsync(photoId); } catch (UnsplasharpNotFoundException) { // Photo doesn't exist - show user-friendly message } catch (UnsplasharpRateLimitException ex) { // Rate limited - implement backoff await Task.Delay(ex.TimeUntilReset ?? TimeSpan.FromMinutes(1)); } catch (UnsplasharpNetworkException ex) when (ex.IsRetryable) { // Transient network error - retry } catch (UnsplasharpException ex) { // Other API errors - log and show generic error logger.LogError(ex, \"API error: {Context}\", ex.Context?.ToSummary()); } 2. Use Correlation IDs for Debugging try { var photo = await client.GetRandomPhotoAsync(); } catch (UnsplasharpException ex) { logger.LogError(ex, \"Request failed [CorrelationId: {CorrelationId}]: {Message}\", ex.Context?.CorrelationId, ex.Message); } 3. Implement Intelligent Retry Logic public async Task<Photo> GetPhotoWithRetry(string photoId, int maxRetries = 3) { for (int attempt = 1; attempt <= maxRetries; attempt++) { try { return await client.GetPhotoAsync(photoId); } catch (UnsplasharpNetworkException ex) when (ex.IsRetryable && attempt < maxRetries) { var delay = TimeSpan.FromSeconds(Math.Pow(2, attempt)); // Exponential backoff await Task.Delay(delay); } catch (UnsplasharpRateLimitException ex) when (attempt < maxRetries) { var delay = ex.TimeUntilReset ?? TimeSpan.FromMinutes(1); await Task.Delay(delay); } } throw new InvalidOperationException($\"Failed to get photo after {maxRetries} attempts\"); } 4. Monitor Rate Limits try { var photos = await client.SearchPhotosAsync(\"nature\"); } catch (UnsplasharpException ex) { if (ex.Context?.RateLimitInfo != null) { var rateLimit = ex.Context.RateLimitInfo; if (rateLimit.Remaining < 100) { logger.LogWarning(\"Rate limit running low: {Remaining}/{Limit}\", rateLimit.Remaining, rateLimit.Limit); } } } Configuration The error handling system can be configured through the retry policies: // The client automatically uses intelligent retry policies var client = new UnsplasharpClient(\"your_app_id\", logger: logger); // Retry policies handle: // - Exponential backoff with jitter // - Rate limit-aware delays // - Circuit breaker patterns (optional) // - Comprehensive logging Logging Integration The error handling system integrates with Microsoft.Extensions.Logging: using var loggerFactory = LoggerFactory.Create(builder => builder.AddConsole().SetMinimumLevel(LogLevel.Debug)); var logger = loggerFactory.CreateLogger<UnsplasharpClient>(); var client = new UnsplasharpClient(\"your_app_id\", logger: logger); // All errors are automatically logged with correlation IDs and context Summary The comprehensive error handling system provides: ✅ Better Debugging: Specific exception types with rich context ✅ Intelligent Retries: Smart retry logic based on error types ✅ Rate Limit Awareness: Automatic rate limit detection and handling ✅ Backward Compatibility: Existing code continues to work ✅ Enhanced Monitoring: Correlation IDs and structured logging ✅ Production Ready: Circuit breakers and resilience patterns This system makes your applications more robust and easier to debug while maintaining full backward compatibility with existing code."
  },
  "http-client-factory.html": {
    "href": "http-client-factory.html",
    "title": "IHttpClientFactory Integration Guide | Unsplasharp Documentation",
    "summary": "IHttpClientFactory Integration Guide This document explains how to use Unsplasharp with IHttpClientFactory for modern .NET applications. Overview Unsplasharp now supports IHttpClientFactory, Microsoft's recommended pattern for managing HttpClient instances in .NET applications. This provides several benefits: Proper HttpClient lifecycle management - Automatic DNS refresh and connection pooling Dependency injection integration - Seamless integration with DI containers Configuration centralization - Configure HTTP clients in one place Better testability - Easy to mock and test HTTP interactions Resource management - Prevents socket exhaustion and DNS issues Quick Start ASP.NET Core Integration // Program.cs or Startup.cs using Unsplasharp.Extensions; var builder = WebApplication.CreateBuilder(args); // Add Unsplasharp with IHttpClientFactory builder.Services.AddUnsplasharp(\"YOUR_APPLICATION_ID\"); // Or with configuration builder.Services.AddUnsplasharp(options => { options.ApplicationId = \"YOUR_APPLICATION_ID\"; options.Secret = \"YOUR_SECRET\"; // Optional options.ConfigureHttpClient = client => { client.Timeout = TimeSpan.FromSeconds(60); // Add custom headers, etc. }; }); var app = builder.Build(); Using in Controllers [ApiController] [Route(\"api/[controller]\")] public class PhotosController : ControllerBase { private readonly UnsplasharpClient _unsplashClient; public PhotosController(UnsplasharpClient unsplashClient) { _unsplashClient = unsplashClient; } [HttpGet(\"random\")] public async Task<IActionResult> GetRandomPhoto() { var photo = await _unsplashClient.GetRandomPhoto(); return Ok(photo); } [HttpGet(\"search\")] public async Task<IActionResult> SearchPhotos(string query, int page = 1) { var photos = await _unsplashClient.SearchPhotos(query, page); return Ok(photos); } } Manual Configuration Console Application using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Hosting; using Microsoft.Extensions.Logging; using Unsplasharp; using Unsplasharp.Extensions; var host = Host.CreateDefaultBuilder(args) .ConfigureServices((context, services) => { // Add logging services.AddLogging(builder => builder.AddConsole()); // Add Unsplasharp services.AddUnsplasharp(\"YOUR_APPLICATION_ID\"); }) .Build(); // Use the client var unsplashClient = host.Services.GetRequiredService<UnsplasharpClient>(); var photo = await unsplashClient.GetRandomPhoto(); Console.WriteLine($\"Photo by {photo?.User?.Name}: {photo?.Urls?.Regular}\"); Manual DI Setup using Microsoft.Extensions.DependencyInjection; using Microsoft.Extensions.Http; using Microsoft.Extensions.Logging; using Unsplasharp; var services = new ServiceCollection(); // Add required services services.AddHttpClient(); services.AddLogging(); // Add Unsplasharp manually services.AddScoped<UnsplasharpClient>(provider => { var httpClientFactory = provider.GetRequiredService<IHttpClientFactory>(); var logger = provider.GetService<ILogger<UnsplasharpClient>>(); return new UnsplasharpClient( applicationId: \"YOUR_APPLICATION_ID\", secret: null, // Optional logger: logger, httpClientFactory: httpClientFactory ); }); var serviceProvider = services.BuildServiceProvider(); var client = serviceProvider.GetRequiredService<UnsplasharpClient>(); Advanced Configuration Custom HttpClient Configuration services.AddUnsplasharp(options => { options.ApplicationId = \"YOUR_APPLICATION_ID\"; options.ConfigureHttpClient = client => { // Custom timeout client.Timeout = TimeSpan.FromMinutes(2); // Custom headers client.DefaultRequestHeaders.Add(\"X-Custom-Header\", \"MyValue\"); // Custom user agent client.DefaultRequestHeaders.UserAgent.ParseAdd(\"MyApp/1.0\"); }; }); Multiple Clients with Different Configurations // Register multiple named clients services.AddHttpClient(\"unsplash-primary\", client => { client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Client-ID\", \"PRIMARY_APP_ID\"); client.Timeout = TimeSpan.FromSeconds(30); }); services.AddHttpClient(\"unsplash-secondary\", client => { client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Client-ID\", \"SECONDARY_APP_ID\"); client.Timeout = TimeSpan.FromSeconds(60); }); // Register clients manually services.AddScoped<UnsplasharpClient>(\"primary\", provider => { var factory = provider.GetRequiredService<IHttpClientFactory>(); var logger = provider.GetService<ILogger<UnsplasharpClient>>(); return new UnsplasharpClient(\"PRIMARY_APP_ID\", logger: logger, httpClientFactory: factory); }); Configuration from appsettings.json { \"Unsplash\": { \"ApplicationId\": \"YOUR_APPLICATION_ID\", \"Secret\": \"YOUR_SECRET\", \"Timeout\": \"00:01:00\" } } // Configuration class public class UnsplashOptions { public string ApplicationId { get; set; } = string.Empty; public string? Secret { get; set; } public TimeSpan Timeout { get; set; } = TimeSpan.FromSeconds(30); } // In Program.cs var unsplashOptions = builder.Configuration.GetSection(\"Unsplash\").Get<UnsplashOptions>(); builder.Services.AddUnsplasharp(options => { options.ApplicationId = unsplashOptions.ApplicationId; options.Secret = unsplashOptions.Secret; options.ConfigureHttpClient = client => { client.Timeout = unsplashOptions.Timeout; }; }); Backward Compatibility The library maintains full backward compatibility. Existing code will continue to work: // Legacy usage (still works) var client = new UnsplasharpClient(\"YOUR_APPLICATION_ID\"); var photos = await client.SearchPhotos(\"nature\"); // With logging (still works) var logger = loggerFactory.CreateLogger<UnsplasharpClient>(); var client = new UnsplasharpClient(\"YOUR_APPLICATION_ID\", logger: logger); Benefits of IHttpClientFactory Automatic Resource Management Prevents socket exhaustion Handles DNS changes automatically Manages connection pooling Better Performance Reuses connections efficiently Reduces memory allocations Optimizes network usage Enhanced Reliability Built-in retry policies (when configured) Better error handling Improved timeout management Improved Testability // Easy to mock for testing var mockFactory = new Mock<IHttpClientFactory>(); var mockHttpClient = new Mock<HttpClient>(); mockFactory.Setup(f => f.CreateClient(\"unsplash\")).Returns(mockHttpClient.Object); var client = new UnsplasharpClient(\"test\", httpClientFactory: mockFactory.Object); Migration Guide From Legacy to IHttpClientFactory Add the extension method: // Old services.AddScoped(_ => new UnsplasharpClient(\"APP_ID\")); // New services.AddUnsplasharp(\"APP_ID\"); Update constructor calls: // Old var client = new UnsplasharpClient(\"APP_ID\"); // New (in DI context) // Inject UnsplasharpClient directly Configuration changes: // Old - manual HttpClient management // No centralized configuration // New - centralized configuration services.AddUnsplasharp(options => { options.ApplicationId = \"APP_ID\"; options.ConfigureHttpClient = client => { /* configure */ }; }); Troubleshooting Common Issues Missing HttpClient registration: Ensure AddHttpClient() is called DI scope issues: Register as Scoped or Transient, not Singleton Configuration not applied: Check that ConfigureHttpClient is called correctly Debug Logging Enable debug logging to see HTTP client creation: services.AddLogging(builder => { builder.AddConsole(); builder.SetMinimumLevel(LogLevel.Debug); }); This will show when HttpClients are created and reused."
  },
  "index.html": {
    "href": "index.html",
    "title": "Unsplasharp Documentation | Unsplasharp Documentation",
    "summary": "Unsplasharp Documentation A modern, asynchronous, and feature-rich .NET library for the Unsplash API. This comprehensive documentation will help you get started quickly and make the most of Unsplasharp's powerful features. \uD83D\uDE80 Quick Start New to Unsplasharp? Start here: Getting Started Guide - Complete setup guide with examples API Key Setup - How to get your Unsplash API credentials Basic Examples - Simple code examples to get you started \uD83D\uDCDA Core Documentation Essential Guides Getting Started - Comprehensive setup and first steps API Reference - Complete method documentation with examples Model Reference - Detailed model class documentation Error Handling - Comprehensive error handling strategies Advanced Topics Advanced Usage Patterns - Pagination, filtering, and optimization Code Examples & Recipes - Practical examples for common scenarios Testing & Best Practices - Testing strategies and production tips Migration Guide - Upgrading from older versions Integration & Configuration IHttpClientFactory Integration - Modern HTTP client management Logging Configuration - Structured logging setup Downloading Photos - Image download examples Navigation & Reference Quick Reference - Fast reference for common operations Navigation Guide - Find what you need quickly Table of Contents - Complete documentation overview \uD83C\uDFAF Quick Navigation By Use Case I want to... Go to Get started quickly Getting Started Guide Search for photos Search Examples Handle errors properly Error Handling Guide Download images Download Examples Build a web app Web Integration Test my code Testing Guide Optimize performance Advanced Patterns Migrate from older version Migration Guide By Experience Level Level Recommended Reading Beginner Getting Started → Basic Examples → Error Handling Intermediate API Reference → Advanced Patterns → Model Reference Advanced Testing Guide → Performance Optimization → Migration Guide \uD83D\uDD27 API Overview Unsplasharp provides access to all major Unsplash API endpoints: Core Features Photos: Get random photos, search, retrieve by ID Collections: Browse curated collections Users: Access photographer profiles and portfolios Search: Powerful search with filters and pagination Statistics: Platform usage statistics Modern .NET Features Async/Await: Full async support with cancellation tokens Exception Handling: Specific exception types with rich context Dependency Injection: Built-in DI container support IHttpClientFactory: Proper HTTP client lifecycle management Structured Logging: Microsoft.Extensions.Logging integration Performance: Connection pooling and intelligent caching \uD83C\uDFA8 Code Examples Quick Example using Unsplasharp; // Create client var client = new UnsplasharpClient(\"YOUR_APPLICATION_ID\"); // Get a random photo try { var photo = await client.GetRandomPhotoAsync(); Console.WriteLine($\"Photo by {photo.User.Name}: {photo.Urls.Regular}\"); } catch (UnsplasharpException ex) { Console.WriteLine($\"Error: {ex.Message}\"); } Search Photos // Search with filters var photos = await client.SearchPhotosAsync( query: \"mountain landscape\", orientation: Orientation.Landscape, color: \"blue\", perPage: 20 ); foreach (var photo in photos) { Console.WriteLine($\"{photo.Description} by {photo.User.Name}\"); } More examples: Code Examples & Recipes \uD83D\uDEE0️ Installation Package Manager Console Install-Package Unsplasharp .NET CLI dotnet add package Unsplasharp PackageReference <PackageReference Include=\"Unsplasharp\" Version=\"*\" /> \uD83D\uDD17 External Resources Unsplash API Documentation - Official API docs Unsplash Developer Guidelines - API usage guidelines GitHub Repository - Source code and issues NuGet Package - Package downloads \uD83D\uDCA1 Need Help? Getting Started Issues: Check the Getting Started Guide API Questions: See the API Reference Error Handling: Review Error Handling Guide Performance Issues: Read Advanced Usage Patterns Bug Reports: Use GitHub Issues \uD83D\uDCDD Contributing Unsplasharp is an open-source project. Contributions are welcome! Please see the contribution guidelines for more information. Ready to get started? → Getting Started Guide"
  },
  "logging.html": {
    "href": "logging.html",
    "title": "Logging Guide | Unsplasharp Documentation",
    "summary": "Logging Guide This document explains how to use the structured logging features in Unsplasharp. Overview Unsplasharp now includes built-in support for Microsoft.Extensions.Logging, providing detailed insights into: HTTP requests and responses Retry attempts and failures Rate limit information Error conditions and exceptions Quick Start Basic Setup using Microsoft.Extensions.Logging; using Unsplasharp; // Create a logger factory using var loggerFactory = LoggerFactory.Create(builder => builder.AddConsole().SetMinimumLevel(LogLevel.Information)); var logger = loggerFactory.CreateLogger<UnsplasharpClient>(); // Create client with logging var client = new UnsplasharpClient(\"YOUR_APP_ID\", logger: logger); ASP.NET Core Integration // In Startup.cs or Program.cs services.AddScoped<UnsplasharpClient>(provider => { var logger = provider.GetRequiredService<ILogger<UnsplasharpClient>>(); return new UnsplasharpClient(\"YOUR_APP_ID\", logger: logger); }); Log Levels Debug Level HTTP request URLs HttpClient creation events Rate limit status after successful requests [Debug] Making HTTP request to https://api.unsplash.com/photos/random [Debug] Created new HttpClient for application ID your-app-id [Debug] HTTP request successful. Rate limit: 4999/5000 Information Level Search operations with parameters and results Photo retrieval operations High-level operation outcomes [Information] Searching photos with query 'nature', page 1, perPage 10 [Information] Photo search completed. Found 10 photos, total results: 1500 [Information] Fetching random photo [Information] Successfully retrieved random photo with ID abc123 Warning Level Retry attempts due to transient failures Timeout scenarios Failed photo retrievals [Warning] Retrying HTTP request (attempt 2/3). Exception: The operation was canceled. [Warning] HTTP request timed out for URL https://api.unsplash.com/photos/random after retries [Warning] Failed to retrieve random photo Error Level HTTP request failures after all retries Unexpected exceptions Network-related errors [Error] HTTP request failed for URL https://api.unsplash.com/photos/random after retries [Error] Unexpected error during HTTP request to https://api.unsplash.com/search/photos after retries Configuration Examples Console Logging with Custom Format using var loggerFactory = LoggerFactory.Create(builder => builder.AddConsole(options => { options.IncludeScopes = true; options.TimestampFormat = \"yyyy-MM-dd HH:mm:ss \"; }) .SetMinimumLevel(LogLevel.Debug)); File Logging with Serilog using Serilog; using Microsoft.Extensions.Logging; Log.Logger = new LoggerConfiguration() .WriteTo.File(\"unsplasharp.log\") .CreateLogger(); using var loggerFactory = LoggerFactory.Create(builder => builder.AddSerilog()); var logger = loggerFactory.CreateLogger<UnsplasharpClient>(); var client = new UnsplasharpClient(\"YOUR_APP_ID\", logger: logger); Structured Logging with Properties The library uses structured logging with named properties: // Example log entries with structured properties _logger.LogInformation(\"Searching photos with query '{Query}', page {Page}, perPage {PerPage}\", query, page, perPage); _logger.LogWarning(\"Retrying HTTP request (attempt {AttemptNumber}/{MaxAttempts}). Exception: {Exception}\", attemptNumber, maxAttempts, exception.Message); Filtering Logs By Category builder.AddFilter(\"Unsplasharp.UnsplasharpClient\", LogLevel.Information); By Log Level builder.SetMinimumLevel(LogLevel.Warning); // Only warnings and errors Custom Filtering builder.AddFilter((category, level) => category.Contains(\"Unsplasharp\") && level >= LogLevel.Information); Monitoring and Observability Application Insights Integration services.AddApplicationInsightsTelemetry(); services.AddLogging(builder => builder.AddApplicationInsights()); Custom Log Processors public class UnsplasharpLogProcessor : ILoggerProvider { public ILogger CreateLogger(string categoryName) { if (categoryName.Contains(\"UnsplasharpClient\")) { return new CustomUnsplasharpLogger(); } return NullLogger.Instance; } public void Dispose() { } } Performance Considerations Logging is designed to have minimal performance impact Debug-level logging may affect performance in high-throughput scenarios Consider using Information level or higher in production Structured logging properties are efficiently formatted Troubleshooting Common Issues No logs appearing: Check log level configuration Too many logs: Increase minimum log level Missing retry logs: Ensure Warning level is enabled Debug Mode Enable debug logging to see detailed HTTP request information: builder.SetMinimumLevel(LogLevel.Debug); This will show: Exact URLs being requested HttpClient lifecycle events Rate limit information Detailed retry attempt information"
  },
  "migration-guide.html": {
    "href": "migration-guide.html",
    "title": "Migration and Upgrade Guide | Unsplasharp Documentation",
    "summary": "Migration and Upgrade Guide This guide helps you migrate from older versions of Unsplasharp and adopt new features like comprehensive error handling, IHttpClientFactory integration, and modern async patterns. Table of Contents Version Compatibility Breaking Changes New Features Overview Migration Strategies Error Handling Migration IHttpClientFactory Migration Logging Integration Performance Improvements Best Practices Updates Version Compatibility Supported .NET Versions Unsplasharp Version .NET Framework .NET Core .NET 5+ 1.x 4.6.1+ 2.0+ ❌ 2.x 4.6.1+ 2.0+ 5.0+ 3.x (Current) 4.6.1+ 2.0+ 5.0+ API Compatibility Backward Compatible: All existing methods continue to work New Methods: Exception-throwing variants added (e.g., GetPhotoAsync) Enhanced Features: Logging, metrics, and error context added No Breaking Changes: Existing code will compile and run without modifications Breaking Changes None! \uD83C\uDF89 Unsplasharp maintains full backward compatibility. Your existing code will continue to work exactly as before. // This code from v1.x still works in v3.x var client = new UnsplasharpClient(\"YOUR_APP_ID\"); var photo = await client.GetRandomPhoto(); if (photo != null) { Console.WriteLine(photo.Urls.Regular); } New Features Overview 1. Comprehensive Error Handling New Exception Types: Specific exceptions for different error scenarios Rich Error Context: Detailed information about requests and responses Correlation IDs: For better debugging and monitoring Rate Limit Awareness: Automatic rate limit detection and handling 2. IHttpClientFactory Integration Modern HTTP Management: Proper HttpClient lifecycle management Dependency Injection: Seamless integration with DI containers Connection Pooling: Better performance and resource utilization Configuration Centralization: Configure HTTP clients in one place 3. Structured Logging Microsoft.Extensions.Logging: Integration with standard logging framework Detailed Insights: HTTP requests, retries, rate limits, and errors Correlation Tracking: Link related log entries with correlation IDs Performance Metrics: Request timing and success rates 4. Enhanced Async Support CancellationToken Support: All methods now support cancellation Better Exception Handling: Exception-throwing variants for better error handling Timeout Management: Configurable timeouts with proper cancellation Migration Strategies Strategy 1: Gradual Migration (Recommended) Migrate your codebase gradually by replacing method calls one at a time: // Step 1: Keep existing code working var client = new UnsplasharpClient(\"YOUR_APP_ID\"); var photo = await client.GetRandomPhoto(); // Old method // Step 2: Add logging (optional) var logger = loggerFactory.CreateLogger<UnsplasharpClient>(); var clientWithLogging = new UnsplasharpClient(\"YOUR_APP_ID\", logger: logger); // Step 3: Replace with exception-throwing methods try { var photo = await client.GetRandomPhotoAsync(); // New method // Handle success } catch (UnsplasharpException ex) { // Handle errors } // Step 4: Add IHttpClientFactory (for new projects or major refactoring) services.AddUnsplasharp(\"YOUR_APP_ID\"); Strategy 2: New Project Setup For new projects, start with the modern approach: // Program.cs services.AddUnsplasharp(options => { options.ApplicationId = configuration[\"Unsplash:ApplicationId\"]; options.ConfigureHttpClient = client => { client.Timeout = TimeSpan.FromSeconds(30); }; }); // Service class public class PhotoService { private readonly UnsplasharpClient _client; private readonly ILogger<PhotoService> _logger; public PhotoService(UnsplasharpClient client, ILogger<PhotoService> logger) { _client = client; _logger = logger; } public async Task<Photo?> GetPhotoAsync(string photoId) { try { return await _client.GetPhotoAsync(photoId); } catch (UnsplasharpNotFoundException) { _logger.LogWarning(\"Photo {PhotoId} not found\", photoId); return null; } catch (UnsplasharpException ex) { _logger.LogError(ex, \"Error getting photo {PhotoId}\", photoId); throw; } } } Error Handling Migration Before: Basic Error Handling // Old approach - null checking var photo = await client.GetRandomPhoto(); if (photo == null) { Console.WriteLine(\"Failed to get photo\"); return; } // Process photo Console.WriteLine($\"Photo by {photo.User.Name}\"); After: Comprehensive Error Handling // New approach - exception handling try { var photo = await client.GetRandomPhotoAsync(); Console.WriteLine($\"Photo by {photo.User.Name}\"); } catch (UnsplasharpNotFoundException) { Console.WriteLine(\"Photo not found\"); } catch (UnsplasharpRateLimitException ex) { Console.WriteLine($\"Rate limited. Reset at: {ex.RateLimitReset}\"); // Implement backoff strategy } catch (UnsplasharpAuthenticationException) { Console.WriteLine(\"Invalid API key\"); } catch (UnsplasharpNetworkException ex) when (ex.IsRetryable) { Console.WriteLine(\"Network error - retrying...\"); // Implement retry logic } catch (UnsplasharpException ex) { Console.WriteLine($\"API error: {ex.Message}\"); // Access rich error context if (ex.Context != null) { Console.WriteLine($\"Correlation ID: {ex.Context.CorrelationId}\"); Console.WriteLine($\"Request URL: {ex.RequestUrl}\"); } } Migration Helper public static class MigrationHelper { /// <summary> /// Wraps old-style methods to provide exception-based error handling /// </summary> public static async Task<T> WrapWithExceptions<T>(Func<Task<T?>> oldMethod) where T : class { var result = await oldMethod(); if (result == null) { throw new InvalidOperationException(\"Operation returned null - this may indicate an API error\"); } return result; } } // Usage try { var photo = await MigrationHelper.WrapWithExceptions(() => client.GetRandomPhoto()); // Process photo } catch (Exception ex) { // Handle error } IHttpClientFactory Migration Before: Manual HttpClient Management // Old approach - basic client creation var client = new UnsplasharpClient(\"YOUR_APP_ID\"); // Or with logging var logger = loggerFactory.CreateLogger<UnsplasharpClient>(); var client = new UnsplasharpClient(\"YOUR_APP_ID\", logger: logger); After: IHttpClientFactory Integration // New approach - dependency injection setup // In Program.cs or Startup.cs services.AddUnsplasharp(\"YOUR_APP_ID\"); // Or with configuration services.AddUnsplasharp(options => { options.ApplicationId = configuration[\"Unsplash:ApplicationId\"]; options.Secret = configuration[\"Unsplash:Secret\"]; options.ConfigureHttpClient = client => { client.Timeout = TimeSpan.FromSeconds(60); client.DefaultRequestHeaders.UserAgent.ParseAdd(\"MyApp/1.0\"); }; }); // In your service public class PhotoService { private readonly UnsplasharpClient _client; public PhotoService(UnsplasharpClient client) { _client = client; // Injected with proper HttpClient management } } Manual IHttpClientFactory Setup If you can't use the extension method: // Manual setup services.AddHttpClient(); services.AddScoped<UnsplasharpClient>(provider => { var httpClientFactory = provider.GetRequiredService<IHttpClientFactory>(); var logger = provider.GetService<ILogger<UnsplasharpClient>>(); return new UnsplasharpClient( applicationId: \"YOUR_APP_ID\", logger: logger, httpClientFactory: httpClientFactory ); }); Logging Integration Before: No Logging var client = new UnsplasharpClient(\"YOUR_APP_ID\"); var photo = await client.GetRandomPhoto(); // No visibility into what's happening After: Structured Logging // Setup logging services.AddLogging(builder => { builder.AddConsole(); builder.AddDebug(); builder.SetMinimumLevel(LogLevel.Information); }); // Client with logging var logger = serviceProvider.GetRequiredService<ILogger<UnsplasharpClient>>(); var client = new UnsplasharpClient(\"YOUR_APP_ID\", logger: logger); // Or with DI services.AddUnsplasharp(\"YOUR_APP_ID\"); // Automatically includes logging // Now you get detailed logs: // [Information] Making HTTP request to https://api.unsplash.com/photos/random // [Debug] Rate limit: 4999/5000 // [Information] Request completed in 245ms Custom Logging Configuration services.AddLogging(builder => { builder.AddConsole(options => { options.IncludeScopes = true; options.TimestampFormat = \"yyyy-MM-dd HH:mm:ss \"; }); // Set specific log levels builder.AddFilter(\"Unsplasharp\", LogLevel.Information); builder.AddFilter(\"System.Net.Http\", LogLevel.Warning); }); Performance Improvements Connection Pooling The new version automatically uses connection pooling when IHttpClientFactory is available: // Old: Each client instance creates its own HttpClient var client1 = new UnsplasharpClient(\"APP_ID\"); var client2 = new UnsplasharpClient(\"APP_ID\"); // Creates another HttpClient // New: Shared connection pool services.AddUnsplasharp(\"APP_ID\"); // All injected clients share the same optimized HttpClient pool Retry Policies Built-in retry policies with exponential backoff: // Automatic retry for transient failures try { var photo = await client.GetPhotoAsync(\"photo-id\"); } catch (UnsplasharpNetworkException ex) when (ex.IsRetryable) { // The client already attempted retries with exponential backoff // This exception means all retries were exhausted } Rate Limit Optimization Better rate limit handling: // Automatic rate limit tracking Console.WriteLine($\"Rate limit: {client.RateLimitRemaining}/{client.MaxRateLimit}\"); // Smart retry on rate limit exceeded try { var photos = await client.SearchPhotosAsync(\"nature\"); } catch (UnsplasharpRateLimitException ex) { // Exception includes exact reset time var waitTime = ex.RateLimitReset - DateTimeOffset.UtcNow; await Task.Delay(waitTime); // Retry the request } Best Practices Updates 1. Use CancellationTokens All methods now support cancellation tokens: // Before: No cancellation support var photos = await client.SearchPhotos(\"nature\"); // After: With cancellation support using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(30)); try { var photos = await client.SearchPhotosAsync(\"nature\", cancellationToken: cts.Token); } catch (OperationCanceledException) { Console.WriteLine(\"Search timed out\"); } 2. Implement Proper Error Handling // Before: Basic null checking public async Task<List<Photo>> GetPhotosOldWay(string query) { var photos = await client.SearchPhotos(query); return photos ?? new List<Photo>(); } // After: Comprehensive error handling public async Task<List<Photo>> GetPhotosNewWay(string query) { try { return await client.SearchPhotosAsync(query); } catch (UnsplasharpNotFoundException) { return new List<Photo>(); } catch (UnsplasharpRateLimitException ex) { logger.LogWarning(\"Rate limited, waiting {Delay}ms\", ex.TimeUntilReset?.TotalMilliseconds); throw; // Let caller handle rate limiting } catch (UnsplasharpException ex) { logger.LogError(ex, \"Search failed for query: {Query}\", query); throw; } } 3. Use Dependency Injection // Before: Manual instantiation public class PhotoService { private readonly UnsplasharpClient _client; public PhotoService() { _client = new UnsplasharpClient(\"YOUR_APP_ID\"); } } // After: Dependency injection public class PhotoService { private readonly UnsplasharpClient _client; private readonly ILogger<PhotoService> _logger; public PhotoService(UnsplasharpClient client, ILogger<PhotoService> logger) { _client = client; _logger = logger; } } // Registration services.AddUnsplasharp(\"YOUR_APP_ID\"); services.AddScoped<PhotoService>(); 4. Implement Caching // Enhanced caching with error handling public class CachedPhotoService { private readonly UnsplasharpClient _client; private readonly IMemoryCache _cache; private readonly ILogger<CachedPhotoService> _logger; public async Task<Photo?> GetPhotoAsync(string photoId) { var cacheKey = $\"photo:{photoId}\"; if (_cache.TryGetValue(cacheKey, out Photo cachedPhoto)) { return cachedPhoto; } try { var photo = await _client.GetPhotoAsync(photoId); _cache.Set(cacheKey, photo, TimeSpan.FromHours(1)); return photo; } catch (UnsplasharpNotFoundException) { // Cache negative results for shorter time _cache.Set(cacheKey, (Photo?)null, TimeSpan.FromMinutes(5)); return null; } catch (UnsplasharpRateLimitException) { // Don't cache rate limit errors throw; } catch (UnsplasharpException ex) { _logger.LogError(ex, \"Failed to get photo {PhotoId}\", photoId); throw; } } } Troubleshooting Common Migration Issues Issue 1: Null Reference Exceptions Problem: Code that worked before now throws null reference exceptions. Cause: You might be using new exception-throwing methods without proper error handling. Solution: // If you get NullReferenceException here: var photo = await client.GetPhotoAsync(\"invalid-id\"); Console.WriteLine(photo.Description); // NullReferenceException // Change to: try { var photo = await client.GetPhotoAsync(\"invalid-id\"); Console.WriteLine(photo.Description); } catch (UnsplasharpNotFoundException) { Console.WriteLine(\"Photo not found\"); } Issue 2: HttpClient Disposal Issues Problem: \"Cannot access a disposed object\" errors. Cause: Manual HttpClient management conflicts with IHttpClientFactory. Solution: // Don't do this: using var httpClient = new HttpClient(); var client = new UnsplasharpClient(\"APP_ID\", httpClientFactory: someFactory); // Do this instead: services.AddUnsplasharp(\"APP_ID\"); // Let DI handle lifecycle Issue 3: Rate Limit Handling Problem: Application stops working when rate limits are hit. Solution: public async Task<T> ExecuteWithRetry<T>(Func<Task<T>> operation, int maxRetries = 3) { for (int attempt = 1; attempt <= maxRetries; attempt++) { try { return await operation(); } catch (UnsplasharpRateLimitException ex) when (attempt < maxRetries) { var delay = ex.TimeUntilReset ?? TimeSpan.FromMinutes(1); await Task.Delay(delay); } catch (UnsplasharpNetworkException ex) when (ex.IsRetryable && attempt < maxRetries) { var delay = TimeSpan.FromSeconds(Math.Pow(2, attempt)); await Task.Delay(delay); } } throw new InvalidOperationException($\"Operation failed after {maxRetries} attempts\"); } // Usage var photo = await ExecuteWithRetry(() => client.GetPhotoAsync(\"photo-id\")); Issue 4: Configuration Problems Problem: API key not being recognized or configuration not loading. Solution: // Check configuration loading var config = builder.Configuration.GetSection(\"Unsplash\").Get<UnsplashConfiguration>(); if (string.IsNullOrEmpty(config?.ApplicationId)) { throw new InvalidOperationException(\"Unsplash ApplicationId not configured\"); } // Validate at startup services.AddUnsplasharp(options => { options.ApplicationId = config.ApplicationId ?? throw new ArgumentNullException(nameof(config.ApplicationId)); }); Migration Checklist Phase 1: Preparation [ ] Review current Unsplasharp usage in your codebase [ ] Identify error handling patterns [ ] Plan migration strategy (gradual vs. complete) [ ] Set up logging infrastructure [ ] Update NuGet package Phase 2: Basic Migration [ ] Add logging to existing clients [ ] Replace null checks with try-catch blocks [ ] Add CancellationToken support to async methods [ ] Test existing functionality Phase 3: Advanced Features [ ] Implement IHttpClientFactory integration [ ] Add comprehensive error handling [ ] Implement retry policies [ ] Add performance monitoring [ ] Update caching strategies Phase 4: Optimization [ ] Review and optimize HTTP client configuration [ ] Implement connection pooling [ ] Add metrics collection [ ] Performance testing [ ] Documentation updates Testing Your Migration Unit Testing [Test] public async Task GetPhoto_WithValidId_ReturnsPhoto() { // Arrange var mockFactory = new Mock<IHttpClientFactory>(); var mockLogger = new Mock<ILogger<UnsplasharpClient>>(); var client = new UnsplasharpClient(\"test-app-id\", logger: mockLogger.Object, httpClientFactory: mockFactory.Object); // Act & Assert try { var photo = await client.GetPhotoAsync(\"valid-photo-id\"); Assert.IsNotNull(photo); } catch (UnsplasharpNotFoundException) { // Expected for invalid test ID Assert.Pass(\"Exception handling working correctly\"); } } [Test] public async Task GetPhoto_WithInvalidId_ThrowsNotFoundException() { var client = new UnsplasharpClient(\"test-app-id\"); await Assert.ThrowsAsync<UnsplasharpNotFoundException>( () => client.GetPhotoAsync(\"invalid-photo-id\")); } Integration Testing [Test] public async Task Integration_SearchPhotos_ReturnsResults() { var client = new UnsplasharpClient(TestConfiguration.ApplicationId); var photos = await client.SearchPhotosAsync(\"nature\", perPage: 5); Assert.IsNotEmpty(photos); Assert.All(photos, photo => Assert.IsNotNull(photo.Id)); } Performance Comparison Before Migration Manual HttpClient management No connection pooling Basic error handling No retry logic No structured logging After Migration Optimized HttpClient with connection pooling Automatic retry with exponential backoff Comprehensive error handling with context Structured logging with correlation IDs Rate limit awareness Expected Improvements Reduced memory usage: Better HttpClient lifecycle management Improved reliability: Automatic retries and better error handling Better observability: Structured logging and metrics Enhanced performance: Connection pooling and optimized HTTP settings Summary The migration to the latest Unsplasharp version provides significant improvements while maintaining full backward compatibility. Key benefits include: ✅ Zero Breaking Changes - Existing code continues to work ✅ Enhanced Error Handling - Specific exceptions with rich context ✅ Modern HTTP Management - IHttpClientFactory integration ✅ Structured Logging - Better observability and debugging ✅ Improved Performance - Connection pooling and retry policies ✅ Better Testing - Easier to mock and test Take your time with the migration and adopt new features gradually. The investment in proper error handling and logging will pay dividends in production reliability and maintainability."
  },
  "models-reference.html": {
    "href": "models-reference.html",
    "title": "Models Reference Guide | Unsplasharp Documentation",
    "summary": "Models Reference Guide This comprehensive guide covers all model classes in Unsplasharp, their properties, relationships, and usage examples. Table of Contents Photo Model User Model Collection Model URL Models Location and EXIF Models Statistics Models Link Models Supporting Models Model Relationships Usage Examples Photo Model The Photo class is the core model representing an Unsplash photo with comprehensive metadata. Properties public class Photo : INotifyPropertyChanged { // Basic Properties public string Id { get; set; } // Unique photo identifier public string Description { get; set; } // Photo description/alt text public string CreatedAt { get; set; } // ISO 8601 creation timestamp public string UpdatedAt { get; set; } // ISO 8601 last update timestamp public int Width { get; set; } // Photo width in pixels public int Height { get; set; } // Photo height in pixels public string Color { get; set; } // Dominant color (hex format) public string BlurHash { get; set; } // BlurHash for placeholder // Engagement Metrics public int Downloads { get; set; } // Total download count public int Likes { get; set; } // Total like count public bool IsLikedByUser { get; set; } // Current user's like status // Complex Properties public Urls Urls { get; set; } // Photo URLs in different sizes public User User { get; set; } // Photo author/photographer public Exif Exif { get; set; } // Camera EXIF data public Location Location { get; set; } // Photo location data public PhotoLinks Links { get; set; } // Related API links public List<Category> Categories { get; set; } // Photo categories/tags public List<Collection> CurrentUserCollection { get; set; } // User's collections } Usage Examples // Basic photo information var photo = await client.GetPhotoAsync(\"qcs09SwNPHY\"); Console.WriteLine($\"Photo ID: {photo.Id}\"); Console.WriteLine($\"Title: {photo.Description ?? \"Untitled\"}\"); Console.WriteLine($\"Photographer: {photo.User.Name} (@{photo.User.Username})\"); Console.WriteLine($\"Dimensions: {photo.Width}x{photo.Height}\"); Console.WriteLine($\"Aspect Ratio: {(double)photo.Width / photo.Height:F2}\"); Console.WriteLine($\"Dominant Color: {photo.Color}\"); Console.WriteLine($\"Engagement: {photo.Likes:N0} likes, {photo.Downloads:N0} downloads\"); // Check if photo has location data if (!string.IsNullOrEmpty(photo.Location.Name)) { Console.WriteLine($\"Location: {photo.Location.Name}\"); if (photo.Location.Position != null) { Console.WriteLine($\"Coordinates: {photo.Location.Position.Latitude}, {photo.Location.Position.Longitude}\"); } } // Check camera information if (!string.IsNullOrEmpty(photo.Exif.Make)) { Console.WriteLine($\"Camera: {photo.Exif.Make} {photo.Exif.Model}\"); Console.WriteLine($\"Settings: f/{photo.Exif.Aperture}, {photo.Exif.ExposureTime}s, ISO {photo.Exif.Iso}\"); } // Access different photo sizes Console.WriteLine(\"Available sizes:\"); Console.WriteLine($\" Thumbnail: {photo.Urls.Thumbnail}\"); Console.WriteLine($\" Small: {photo.Urls.Small}\"); Console.WriteLine($\" Regular: {photo.Urls.Regular}\"); Console.WriteLine($\" Full: {photo.Urls.Full}\"); Console.WriteLine($\" Raw: {photo.Urls.Raw}\"); Photo Filtering and Analysis public static class PhotoAnalyzer { public static bool IsLandscape(Photo photo) => photo.Width > photo.Height; public static bool IsPortrait(Photo photo) => photo.Height > photo.Width; public static bool IsSquare(Photo photo) => Math.Abs(photo.Width - photo.Height) < 50; public static bool IsHighResolution(Photo photo) => photo.Width >= 1920 && photo.Height >= 1080; public static bool IsPopular(Photo photo) => photo.Likes > 1000 || photo.Downloads > 10000; public static string GetOrientationDescription(Photo photo) { return photo.Width switch { var w when w > photo.Height * 1.5 => \"Wide Landscape\", var w when w > photo.Height => \"Landscape\", var w when w < photo.Height / 1.5 => \"Tall Portrait\", var w when w < photo.Height => \"Portrait\", _ => \"Square\" }; } public static PhotoQuality AssessQuality(Photo photo) { var score = 0; // Resolution scoring if (photo.Width >= 3840 && photo.Height >= 2160) score += 3; // 4K+ else if (photo.Width >= 1920 && photo.Height >= 1080) score += 2; // Full HD+ else if (photo.Width >= 1280 && photo.Height >= 720) score += 1; // HD+ // Engagement scoring if (photo.Likes > 10000) score += 3; else if (photo.Likes > 1000) score += 2; else if (photo.Likes > 100) score += 1; // EXIF data availability if (!string.IsNullOrEmpty(photo.Exif.Make)) score += 1; return score switch { >= 6 => PhotoQuality.Excellent, >= 4 => PhotoQuality.Good, >= 2 => PhotoQuality.Average, _ => PhotoQuality.Basic }; } } public enum PhotoQuality { Basic, Average, Good, Excellent } User Model The User class represents an Unsplash photographer or user profile. Properties public class User : INotifyPropertyChanged { // Identity public string Id { get; set; } // Unique user identifier public string Username { get; set; } // Username (handle) public string Name { get; set; } // Display name public string FirstName { get; set; } // First name public string LastName { get; set; } // Last name // Profile Information public string Bio { get; set; } // User biography public string Location { get; set; } // User location public string PortfolioUrl { get; set; } // Portfolio website public string TwitterUsername { get; set; } // Twitter handle public bool ForHire { get; set; } // Available for hire // Statistics public int TotalLikes { get; set; } // Total likes received public int TotalPhotos { get; set; } // Total photos uploaded public int TotalCollections { get; set; } // Total collections created public int FollowersCount { get; set; } // Number of followers public int FollowingCount { get; set; } // Number of following // Complex Properties public ProfileImage ProfileImage { get; set; } // Profile image URLs public Badge Badge { get; set; } // User badge information public UserLinks Links { get; set; } // Related API links } Usage Examples // Get user profile information var user = await client.GetUserAsync(\"chrisjoelcampbell\"); Console.WriteLine($\"Photographer: {user.Name} (@{user.Username})\"); Console.WriteLine($\"Bio: {user.Bio}\"); Console.WriteLine($\"Location: {user.Location}\"); Console.WriteLine($\"Portfolio: {user.PortfolioUrl}\"); // Statistics Console.WriteLine($\"Statistics:\"); Console.WriteLine($\" Photos: {user.TotalPhotos:N0}\"); Console.WriteLine($\" Likes received: {user.TotalLikes:N0}\"); Console.WriteLine($\" Collections: {user.TotalCollections:N0}\"); Console.WriteLine($\" Followers: {user.FollowersCount:N0}\"); // Profile images Console.WriteLine($\"Profile Images:\"); Console.WriteLine($\" Small: {user.ProfileImage.Small}\"); Console.WriteLine($\" Medium: {user.ProfileImage.Medium}\"); Console.WriteLine($\" Large: {user.ProfileImage.Large}\"); // Check if user is available for hire if (user.ForHire) { Console.WriteLine(\"✅ Available for hire\"); } // Social media links if (!string.IsNullOrEmpty(user.TwitterUsername)) { Console.WriteLine($\"Twitter: @{user.TwitterUsername}\"); } User Analysis public static class UserAnalyzer { public static UserTier GetUserTier(User user) { return user.TotalPhotos switch { >= 1000 => UserTier.Professional, >= 100 => UserTier.Advanced, >= 10 => UserTier.Intermediate, _ => UserTier.Beginner }; } public static double GetEngagementRate(User user) { return user.TotalPhotos > 0 ? (double)user.TotalLikes / user.TotalPhotos : 0; } public static bool IsInfluencer(User user) { return user.FollowersCount > 10000 || user.TotalLikes > 100000 || user.TotalPhotos > 500; } public static string GetUserDescription(User user) { var tier = GetUserTier(user); var engagement = GetEngagementRate(user); var isInfluencer = IsInfluencer(user); var description = $\"{tier} photographer\"; if (engagement > 100) description += \" with high engagement\"; if (isInfluencer) description += \" and influencer status\"; if (user.ForHire) description += \" (available for hire)\"; return description; } } public enum UserTier { Beginner, Intermediate, Advanced, Professional } Collection Model The Collection class represents a curated collection of photos. Properties public class Collection : INotifyPropertyChanged { // Basic Information public string Id { get; set; } // Unique collection identifier public string Title { get; set; } // Collection title public string Description { get; set; } // Collection description public string PublishedAt { get; set; } // Publication timestamp public string UpdatedAt { get; set; } // Last update timestamp // Metadata public int TotalPhotos { get; set; } // Number of photos in collection public bool IsPrivate { get; set; } // Privacy status public string ShareKey { get; set; } // Share key for private collections // Complex Properties public Photo CoverPhoto { get; set; } // Collection cover photo public User User { get; set; } // Collection creator public CollectionLinks Links { get; set; } // Related API links } Usage Examples // Get collection information var collection = await client.GetCollectionAsync(\"499830\"); Console.WriteLine($\"Collection: {collection.Title}\"); Console.WriteLine($\"Description: {collection.Description}\"); Console.WriteLine($\"Created by: {collection.User.Name}\"); Console.WriteLine($\"Photos: {collection.TotalPhotos:N0}\"); Console.WriteLine($\"Published: {DateTime.Parse(collection.PublishedAt):yyyy-MM-dd}\"); Console.WriteLine($\"Privacy: {(collection.IsPrivate ? \"Private\" : \"Public\")}\"); // Cover photo information if (collection.CoverPhoto != null) { Console.WriteLine($\"Cover Photo:\"); Console.WriteLine($\" By: {collection.CoverPhoto.User.Name}\"); Console.WriteLine($\" URL: {collection.CoverPhoto.Urls.Regular}\"); } // Get photos from collection var photos = await client.GetCollectionPhotosAsync(collection.Id, perPage: 10); Console.WriteLine($\"\\nFirst 10 photos:\"); foreach (var photo in photos) { Console.WriteLine($\" - {photo.Description ?? \"Untitled\"} by {photo.User.Name}\"); } URL Models Urls Class The Urls class provides different sizes and formats of photo URLs. public class Urls { public string Raw { get; set; } // Full resolution, uncompressed public string Full { get; set; } // Large size (max 2048px on longest side) public string Regular { get; set; } // Medium size (max 1080px on longest side) public string Small { get; set; } // Small size (max 400px on longest side) public string Thumbnail { get; set; } // Thumbnail (max 200px on longest side) public string Custom { get; set; } // Custom size (when width/height specified) } URL Usage Examples public static class PhotoUrlHelper { public static string GetBestUrlForSize(Urls urls, int maxWidth, int maxHeight) { // Choose the most appropriate URL based on desired dimensions var maxDimension = Math.Max(maxWidth, maxHeight); return maxDimension switch { <= 200 => urls.Thumbnail, <= 400 => urls.Small, <= 1080 => urls.Regular, <= 2048 => urls.Full, _ => urls.Raw }; } public static Dictionary<string, string> GetAllSizes(Urls urls) { return new Dictionary<string, string> { [\"thumbnail\"] = urls.Thumbnail, [\"small\"] = urls.Small, [\"regular\"] = urls.Regular, [\"full\"] = urls.Full, [\"raw\"] = urls.Raw }; } public static long EstimateFileSize(string url, int width, int height) { // Rough estimation based on dimensions and compression var pixels = width * height; var compressionRatio = url.Contains(\"raw\") ? 0.3 : 0.1; // Raw vs compressed return (long)(pixels * 3 * compressionRatio); // 3 bytes per pixel (RGB) } } // Usage example var photo = await client.GetPhotoAsync(\"photo-id\"); // Get appropriate URL for different use cases var thumbnailUrl = PhotoUrlHelper.GetBestUrlForSize(photo.Urls, 200, 200); var heroImageUrl = PhotoUrlHelper.GetBestUrlForSize(photo.Urls, 1920, 1080); var printQualityUrl = PhotoUrlHelper.GetBestUrlForSize(photo.Urls, 4000, 3000); // Estimate download sizes var sizes = PhotoUrlHelper.GetAllSizes(photo.Urls); foreach (var (sizeName, url) in sizes) { var estimatedSize = PhotoUrlHelper.EstimateFileSize(url, photo.Width, photo.Height); Console.WriteLine($\"{sizeName}: {url} (~{estimatedSize / 1024:N0} KB)\"); } ProfileImage Class public class ProfileImage { public string Small { get; set; } // Small profile image (32x32) public string Medium { get; set; } // Medium profile image (64x64) public string Large { get; set; } // Large profile image (128x128) } Location and EXIF Models Location Class public class Location { public string Name { get; set; } // Location name (e.g., \"Paris, France\") public string City { get; set; } // City name public string Country { get; set; } // Country name public Position Position { get; set; } // GPS coordinates } public class Position { public double Latitude { get; set; } // GPS latitude public double Longitude { get; set; } // GPS longitude } EXIF Class public class Exif { public string Make { get; set; } // Camera manufacturer (e.g., \"Canon\") public string Model { get; set; } // Camera model (e.g., \"EOS 5D Mark IV\") public string ExposureTime { get; set; } // Shutter speed (e.g., \"1/125\") public string Aperture { get; set; } // F-stop (e.g., \"2.8\") public int Iso { get; set; } // ISO sensitivity public string FocalLength { get; set; } // Focal length (e.g., \"85mm\") } Location and EXIF Usage Examples // Analyze photo location data public static class LocationAnalyzer { public static bool HasLocationData(Photo photo) { return photo.Location != null && (!string.IsNullOrEmpty(photo.Location.Name) || photo.Location.Position != null); } public static double CalculateDistance(Position pos1, Position pos2) { // Haversine formula for distance calculation const double R = 6371; // Earth's radius in kilometers var lat1Rad = pos1.Latitude * Math.PI / 180; var lat2Rad = pos2.Latitude * Math.PI / 180; var deltaLatRad = (pos2.Latitude - pos1.Latitude) * Math.PI / 180; var deltaLonRad = (pos2.Longitude - pos1.Longitude) * Math.PI / 180; var a = Math.Sin(deltaLatRad / 2) * Math.Sin(deltaLatRad / 2) + Math.Cos(lat1Rad) * Math.Cos(lat2Rad) * Math.Sin(deltaLonRad / 2) * Math.Sin(deltaLonRad / 2); var c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a)); return R * c; } public static string GetLocationSummary(Location location) { if (string.IsNullOrEmpty(location.Name)) return \"Location not specified\"; var summary = location.Name; if (location.Position != null) { summary += $\" ({location.Position.Latitude:F4}, {location.Position.Longitude:F4})\"; } return summary; } } // Analyze camera EXIF data public static class ExifAnalyzer { public static bool HasExifData(Photo photo) { return photo.Exif != null && !string.IsNullOrEmpty(photo.Exif.Make); } public static string GetCameraInfo(Exif exif) { if (string.IsNullOrEmpty(exif.Make)) return \"Camera information not available\"; return $\"{exif.Make} {exif.Model}\".Trim(); } public static string GetCameraSettings(Exif exif) { var settings = new List<string>(); if (!string.IsNullOrEmpty(exif.Aperture)) settings.Add($\"f/{exif.Aperture}\"); if (!string.IsNullOrEmpty(exif.ExposureTime)) settings.Add($\"{exif.ExposureTime}s\"); if (exif.Iso > 0) settings.Add($\"ISO {exif.Iso}\"); if (!string.IsNullOrEmpty(exif.FocalLength)) settings.Add(exif.FocalLength); return settings.Count > 0 ? string.Join(\", \", settings) : \"Settings not available\"; } public static CameraType GetCameraType(Exif exif) { if (string.IsNullOrEmpty(exif.Make)) return CameraType.Unknown; var make = exif.Make.ToLowerInvariant(); return make switch { var m when m.Contains(\"canon\") => CameraType.Canon, var m when m.Contains(\"nikon\") => CameraType.Nikon, var m when m.Contains(\"sony\") => CameraType.Sony, var m when m.Contains(\"fuji\") => CameraType.Fujifilm, var m when m.Contains(\"olympus\") => CameraType.Olympus, var m when m.Contains(\"panasonic\") => CameraType.Panasonic, var m when m.Contains(\"leica\") => CameraType.Leica, _ => CameraType.Other }; } } public enum CameraType { Unknown, Canon, Nikon, Sony, Fujifilm, Olympus, Panasonic, Leica, Other } // Usage example var photo = await client.GetPhotoAsync(\"photo-id\"); // Location analysis if (LocationAnalyzer.HasLocationData(photo)) { Console.WriteLine($\"Location: {LocationAnalyzer.GetLocationSummary(photo.Location)}\"); } // EXIF analysis if (ExifAnalyzer.HasExifData(photo)) { Console.WriteLine($\"Camera: {ExifAnalyzer.GetCameraInfo(photo.Exif)}\"); Console.WriteLine($\"Settings: {ExifAnalyzer.GetCameraSettings(photo.Exif)}\"); Console.WriteLine($\"Brand: {ExifAnalyzer.GetCameraType(photo.Exif)}\"); } Statistics Models UnplashTotalStats Class public class UnplashTotalStats { public long Photos { get; set; } // Total photos on Unsplash public long Downloads { get; set; } // Total downloads public long Views { get; set; } // Total views public long Likes { get; set; } // Total likes public long Photographers { get; set; } // Total photographers public long PixelsServed { get; set; } // Total pixels served public long ViewsThisMonth { get; set; } // Views in current month public long NewPhotosThisMonth { get; set; } // New photos this month } UnplashMonthlyStats Class public class UnplashMonthlyStats { public long Downloads { get; set; } // Downloads this month public long Views { get; set; } // Views this month public long Likes { get; set; } // Likes this month public long NewPhotos { get; set; } // New photos this month public long NewPhotographers { get; set; } // New photographers this month public long NewPixels { get; set; } // New pixels this month public long NewDevelopers { get; set; } // New developers this month public long NewApplications { get; set; } // New applications this month public long NewRequests { get; set; } // New API requests this month } Statistics Usage Examples // Get and analyze platform statistics public static class StatsAnalyzer { public static async Task AnalyzePlatformGrowth(UnsplasharpClient client) { var totalStats = await client.GetTotalStatsAsync(); var monthlyStats = await client.GetMonthlyStatsAsync(); Console.WriteLine(\"=== Unsplash Platform Statistics ===\"); Console.WriteLine($\"Total Photos: {totalStats.Photos:N0}\"); Console.WriteLine($\"Total Photographers: {totalStats.Photographers:N0}\"); Console.WriteLine($\"Total Downloads: {totalStats.Downloads:N0}\"); Console.WriteLine($\"Total Views: {totalStats.Views:N0}\"); // Calculate averages var avgPhotosPerPhotographer = (double)totalStats.Photos / totalStats.Photographers; var avgDownloadsPerPhoto = (double)totalStats.Downloads / totalStats.Photos; var avgViewsPerPhoto = (double)totalStats.Views / totalStats.Photos; Console.WriteLine($\"\\n=== Platform Averages ===\"); Console.WriteLine($\"Photos per photographer: {avgPhotosPerPhotographer:F1}\"); Console.WriteLine($\"Downloads per photo: {avgDownloadsPerPhoto:F1}\"); Console.WriteLine($\"Views per photo: {avgViewsPerPhoto:F1}\"); // Monthly growth analysis Console.WriteLine($\"\\n=== Monthly Growth ===\"); Console.WriteLine($\"New photos: {monthlyStats.NewPhotos:N0}\"); Console.WriteLine($\"New photographers: {monthlyStats.NewPhotographers:N0}\"); Console.WriteLine($\"New developers: {monthlyStats.NewDevelopers:N0}\"); Console.WriteLine($\"New applications: {monthlyStats.NewApplications:N0}\"); // Growth rates (approximate) var monthlyPhotoGrowthRate = (double)monthlyStats.NewPhotos / totalStats.Photos * 100; var monthlyPhotographerGrowthRate = (double)monthlyStats.NewPhotographers / totalStats.Photographers * 100; Console.WriteLine($\"\\n=== Growth Rates (Monthly) ===\"); Console.WriteLine($\"Photo growth: {monthlyPhotoGrowthRate:F2}%\"); Console.WriteLine($\"Photographer growth: {monthlyPhotographerGrowthRate:F2}%\"); } public static PlatformHealth AssessPlatformHealth(UnplashTotalStats totalStats, UnplashMonthlyStats monthlyStats) { var score = 0; // Photo volume scoring if (totalStats.Photos > 1000000) score += 2; else if (totalStats.Photos > 100000) score += 1; // Engagement scoring var engagementRate = (double)totalStats.Likes / totalStats.Views; if (engagementRate > 0.1) score += 2; else if (engagementRate > 0.05) score += 1; // Growth scoring var monthlyGrowthRate = (double)monthlyStats.NewPhotos / totalStats.Photos; if (monthlyGrowthRate > 0.01) score += 2; // >1% monthly growth else if (monthlyGrowthRate > 0.005) score += 1; // >0.5% monthly growth return score switch { >= 5 => PlatformHealth.Excellent, >= 3 => PlatformHealth.Good, >= 1 => PlatformHealth.Fair, _ => PlatformHealth.Poor }; } } public enum PlatformHealth { Poor, Fair, Good, Excellent } Link Models PhotoLinks Class public class PhotoLinks { public string Self { get; set; } // API endpoint for this photo public string Html { get; set; } // Unsplash.com page for this photo public string Download { get; set; } // Direct download URL public string DownloadLocation { get; set; } // Download tracking endpoint } UserLinks Class public class UserLinks { public string Self { get; set; } // API endpoint for this user public string Html { get; set; } // Unsplash.com profile page public string Photos { get; set; } // API endpoint for user's photos public string Likes { get; set; } // API endpoint for user's likes public string Portfolio { get; set; } // API endpoint for user's portfolio public string Following { get; set; } // API endpoint for users this user follows public string Followers { get; set; } // API endpoint for this user's followers } CollectionLinks Class public class CollectionLinks { public string Self { get; set; } // API endpoint for this collection public string Html { get; set; } // Unsplash.com page for this collection public string Photos { get; set; } // API endpoint for collection's photos public string Related { get; set; } // API endpoint for related collections } Supporting Models Category Class public class Category { public int Id { get; set; } // Category identifier public string Title { get; set; } // Category title public int PhotoCount { get; set; } // Number of photos in category public CategoryLinks Links { get; set; } // Related links } public class CategoryLinks { public string Self { get; set; } // API endpoint for this category public string Photos { get; set; } // API endpoint for category's photos } Badge Class public class Badge { public string Title { get; set; } // Badge title (e.g., \"Book contributor\") public bool Primary { get; set; } // Whether this is the primary badge public string Slug { get; set; } // Badge slug identifier public string Link { get; set; } // Link related to the badge } Model Relationships Relationship Diagram Photo ├── User (photographer) ├── Urls (different sizes) ├── Location │ └── Position (GPS coordinates) ├── Exif (camera data) ├── PhotoLinks (API endpoints) ├── Categories[] (tags/topics) └── CurrentUserCollection[] (user's collections) User ├── ProfileImage (avatar URLs) ├── Badge (achievements) └── UserLinks (API endpoints) Collection ├── User (creator) ├── CoverPhoto (Photo) └── CollectionLinks (API endpoints) Navigation Examples // Navigate from photo to photographer's other work var photo = await client.GetPhotoAsync(\"photo-id\"); var photographer = photo.User; var photographerPhotos = await client.GetUserPhotosAsync(photographer.Username); // Find photos in the same location if (photo.Location?.Position != null) { var nearbyPhotos = await client.SearchPhotosAsync( $\"location:{photo.Location.Name}\", perPage: 20 ); } // Get photos with similar camera equipment if (!string.IsNullOrEmpty(photo.Exif.Make)) { var similarCameraPhotos = await client.SearchPhotosAsync( $\"{photo.Exif.Make} {photo.Exif.Model}\", perPage: 20 ); } // Explore collections containing this photo foreach (var collection in photo.CurrentUserCollection) { var collectionPhotos = await client.GetCollectionPhotosAsync(collection.Id); Console.WriteLine($\"Collection '{collection.Title}' has {collectionPhotos.Count} photos\"); } Usage Examples Complete Photo Analysis public static async Task AnalyzePhoto(UnsplasharpClient client, string photoId) { var photo = await client.GetPhotoAsync(photoId); Console.WriteLine(\"=== PHOTO ANALYSIS ===\"); Console.WriteLine($\"ID: {photo.Id}\"); Console.WriteLine($\"Title: {photo.Description ?? \"Untitled\"}\"); Console.WriteLine($\"Dimensions: {photo.Width}x{photo.Height} ({PhotoAnalyzer.GetOrientationDescription(photo)})\"); Console.WriteLine($\"Quality: {PhotoAnalyzer.AssessQuality(photo)}\"); Console.WriteLine($\"Dominant Color: {photo.Color}\"); Console.WriteLine($\"Engagement: {photo.Likes:N0} likes, {photo.Downloads:N0} downloads\"); // Photographer information Console.WriteLine($\"\\n=== PHOTOGRAPHER ===\"); Console.WriteLine($\"Name: {photo.User.Name} (@{photo.User.Username})\"); Console.WriteLine($\"Profile: {UserAnalyzer.GetUserDescription(photo.User)}\"); Console.WriteLine($\"Stats: {photo.User.TotalPhotos:N0} photos, {photo.User.TotalLikes:N0} likes received\"); // Technical details if (ExifAnalyzer.HasExifData(photo)) { Console.WriteLine($\"\\n=== CAMERA INFO ===\"); Console.WriteLine($\"Camera: {ExifAnalyzer.GetCameraInfo(photo.Exif)}\"); Console.WriteLine($\"Settings: {ExifAnalyzer.GetCameraSettings(photo.Exif)}\"); } // Location information if (LocationAnalyzer.HasLocationData(photo)) { Console.WriteLine($\"\\n=== LOCATION ===\"); Console.WriteLine($\"Location: {LocationAnalyzer.GetLocationSummary(photo.Location)}\"); } // Available URLs Console.WriteLine($\"\\n=== AVAILABLE SIZES ===\"); var sizes = PhotoUrlHelper.GetAllSizes(photo.Urls); foreach (var (sizeName, url) in sizes) { var estimatedSize = PhotoUrlHelper.EstimateFileSize(url, photo.Width, photo.Height); Console.WriteLine($\"{sizeName}: ~{estimatedSize / 1024:N0} KB\"); } }"
  },
  "navigation.html": {
    "href": "navigation.html",
    "title": "Documentation Navigation Guide | Unsplasharp Documentation",
    "summary": "Documentation Navigation Guide This guide helps you navigate the Unsplasharp documentation efficiently based on your needs and experience level. \uD83C\uDFAF Find What You Need I'm New to Unsplasharp Start Here: Getting Started Guide - Complete setup and first examples API Key Setup - Get your Unsplash credentials Basic Examples - Simple code to get you started Error Handling Basics - Handle common errors Next Steps: API Reference - Learn about available methods Model Reference - Understand data structures I Want to Build Something Specific Photo Search Application Search Examples - Search implementation Advanced Search - Filters and optimization Pagination - Handle large result sets Caching - Improve performance Photo Gallery/Viewer Photo Retrieval - Get photos by ID User Profiles - Display photographer info Collections - Browse curated collections Download Images - Save photos locally Web Application Integration ASP.NET Core Examples - Web API integration Dependency Injection - Proper DI setup Caching Strategies - Web app caching Error Handling - Web-specific error handling Desktop Application WPF Examples - Desktop UI integration Console Examples - Command-line tools Background Services - Long-running tasks Local Storage - File management Background/Service Applications Background Services - Service implementation Batch Processing - Handle multiple operations Rate Limiting - Avoid API limits Monitoring - Track performance I'm Having Problems Common Issues Problem Solution API key not working API Key Setup Rate limit errors Rate Limiting Guide Photos not loading Error Handling Slow performance Performance Optimization Memory issues Best Practices Testing problems Testing Guide Error Types UnsplasharpNotFoundException: Not Found Handling UnsplasharpRateLimitException: Rate Limit Handling UnsplasharpAuthenticationException: Auth Issues UnsplasharpNetworkException: Network Problems I Want to Upgrade/Migrate From Older Versions Migration Guide - Complete upgrade guide Breaking Changes - What changed New Features - What's new Migration Strategies - How to upgrade Adopting New Features Exception Handling - New error handling IHttpClientFactory - Modern HTTP clients Logging - Structured logging Performance - Speed improvements I'm Building for Production Essential Reading Testing Guide - Comprehensive testing Best Practices - Production guidelines Security - Secure implementation Monitoring - Track your app Production Checklist [ ] Error Handling implemented [ ] Rate Limiting handled [ ] Caching configured [ ] Logging set up [ ] Health Checks added [ ] Tests written [ ] Monitoring configured \uD83D\uDCD6 Documentation Structure Core Documentation Files docs/ ├── index.md # Main documentation hub ├── api-reference.md # Complete API documentation ├── models-reference.md # Model classes documentation ├── advanced-usage.md # Advanced patterns and optimization ├── code-examples.md # Practical examples and recipes ├── testing-best-practices.md # Testing and production guidance ├── migration-guide.md # Version upgrade guide ├── error-handling.md # Error handling strategies ├── http-client-factory.md # HTTP client configuration ├── logging.md # Logging setup and configuration └── docs/ ├── getting-started.md # Comprehensive getting started guide ├── introduction.md # Library introduction ├── obtaining-an-api-key.md # API key setup └── downloading-a-photo.md # Photo download examples Content Organization By Complexity Level Beginner: docs/getting-started.md, docs/obtaining-an-api-key.md Intermediate: api-reference.md, models-reference.md, error-handling.md Advanced: advanced-usage.md, testing-best-practices.md, migration-guide.md By Topic Setup & Configuration: Getting started, API keys, HTTP client factory, logging API Usage: API reference, models, code examples Advanced Topics: Advanced usage, performance, batch operations Quality & Production: Testing, best practices, error handling, monitoring Migration & Maintenance: Migration guide, troubleshooting \uD83D\uDD0D Search Tips Finding Specific Information Method documentation: Check API Reference Data structures: See Model Reference Code examples: Browse Code Examples Error solutions: Search Error Handling Performance tips: Look in Advanced Usage Using Documentation Search Use browser search (Ctrl+F / Cmd+F) within pages Search for specific method names (e.g., \"GetRandomPhoto\") Look for error types (e.g., \"UnsplasharpRateLimitException\") Search by use case (e.g., \"download\", \"search\", \"cache\") \uD83D\uDE80 Learning Paths Path 1: Quick Start (30 minutes) Getting Started - Setup and first request Basic Examples - Simple operations Error Handling Basics - Handle errors Path 2: Building an App (2-3 hours) Getting Started - Foundation API Reference - Learn the API Code Examples - Implementation patterns Error Handling - Robust error handling Testing - Quality assurance Path 3: Production Ready (1-2 days) Complete Path 2 above Advanced Usage - Optimization techniques Best Practices - Production guidelines Security - Secure implementation Monitoring - Observability Path 4: Expert Level (Ongoing) Complete Path 3 above Migration Guide - Stay current Advanced Patterns - Complex scenarios Performance Optimization - Maximum efficiency Contribute to documentation and examples \uD83D\uDCF1 Mobile-Friendly Navigation Quick Links \uD83D\uDCD6 Getting Started \uD83D\uDD0D API Reference \uD83D\uDCA1 Examples ⚠️ Error Handling \uD83D\uDE80 Advanced \uD83E\uDDEA Testing Bookmarks for Development Save these for quick reference during development: Method List Error Types Model Properties Code Snippets Need help finding something? Check the main documentation index or open an issue on GitHub."
  },
  "quick-reference.html": {
    "href": "quick-reference.html",
    "title": "Unsplasharp Quick Reference | Unsplasharp Documentation",
    "summary": "Unsplasharp Quick Reference Fast reference for common operations and patterns. Perfect for developers who need quick access to code snippets and method signatures. \uD83D\uDE80 Quick Setup // Basic setup var client = new UnsplasharpClient(\"YOUR_APPLICATION_ID\"); // With dependency injection services.AddUnsplasharp(\"YOUR_APPLICATION_ID\"); // With logging var logger = loggerFactory.CreateLogger<UnsplasharpClient>(); var client = new UnsplasharpClient(\"YOUR_APPLICATION_ID\", logger: logger); \uD83D\uDCF8 Common Operations Get Random Photo // Basic var photo = await client.GetRandomPhotoAsync(); // With query var photo = await client.GetRandomPhotoAsync(query: \"nature\"); // With filters var photo = await client.GetRandomPhotoAsync( query: \"landscape\", orientation: Orientation.Landscape ); Search Photos // Basic search var photos = await client.SearchPhotosAsync(\"mountain\"); // Advanced search var photos = await client.SearchPhotosAsync( query: \"sunset beach\", page: 1, perPage: 20, orderBy: OrderBy.Popular, color: \"orange\", orientation: Orientation.Landscape ); Get Specific Photo // By ID var photo = await client.GetPhotoAsync(\"photo-id\"); // With custom size var photo = await client.GetPhoto(\"photo-id\", width: 800, height: 600); Get User Information // User profile var user = await client.GetUserAsync(\"username\"); // User's photos var photos = await client.GetUserPhotosAsync(\"username\", perPage: 20); // User's likes var likes = await client.GetUserLikesAsync(\"username\"); Collections // Get collection var collection = await client.GetCollectionAsync(\"collection-id\"); // Collection photos var photos = await client.GetCollectionPhotosAsync(\"collection-id\"); // Search collections var collections = await client.SearchCollectionsAsync(\"travel\"); ⚠️ Error Handling Basic Pattern try { var photo = await client.GetPhotoAsync(\"photo-id\"); // Success } catch (UnsplasharpNotFoundException) { // Photo not found } catch (UnsplasharpRateLimitException ex) { // Rate limited - wait until ex.RateLimitReset } catch (UnsplasharpException ex) { // Other API errors } Exception Types UnsplasharpNotFoundException - Resource not found (404) UnsplasharpRateLimitException - Rate limit exceeded (429) UnsplasharpAuthenticationException - Invalid API key (401) UnsplasharpNetworkException - Network/connection issues UnsplasharpTimeoutException - Request timeout UnsplasharpException - Base exception type \uD83D\uDD04 Rate Limiting Check Rate Limit Console.WriteLine($\"Rate limit: {client.RateLimitRemaining}/{client.MaxRateLimit}\"); Handle Rate Limits try { var photos = await client.SearchPhotosAsync(\"nature\"); } catch (UnsplasharpRateLimitException ex) { var waitTime = ex.TimeUntilReset ?? TimeSpan.FromMinutes(1); await Task.Delay(waitTime); // Retry request } \uD83D\uDCCA Data Models Photo Properties photo.Id // Unique identifier photo.Description // Photo description photo.Width // Width in pixels photo.Height // Height in pixels photo.Color // Dominant color (hex) photo.Likes // Like count photo.Downloads // Download count photo.User // Photographer info photo.Urls // Different sizes photo.Exif // Camera data photo.Location // GPS location Photo URLs photo.Urls.Thumbnail // ~200px photo.Urls.Small // ~400px photo.Urls.Regular // ~1080px photo.Urls.Full // ~2048px photo.Urls.Raw // Original size User Properties user.Id // Unique identifier user.Username // Username user.Name // Display name user.Bio // Biography user.Location // Location user.TotalPhotos // Photo count user.TotalLikes // Likes received user.ProfileImage // Avatar URLs \uD83D\uDD0D Search Parameters Common Parameters query: \"search term\" // Search query page: 1 // Page number (1-based) perPage: 20 // Results per page (max 30) orderBy: OrderBy.Popular // Latest, Oldest, Popular, Relevant Photo Search Filters color: \"blue\" // Color filter orientation: Orientation.Landscape // Landscape, Portrait, Squarish contentFilter: \"high\" // Content safety (low, high) Orientation Options Orientation.All - All orientations Orientation.Landscape - Landscape only Orientation.Portrait - Portrait only Orientation.Squarish - Square-ish only Order Options OrderBy.Latest - Most recent first OrderBy.Oldest - Oldest first OrderBy.Popular - Most popular first OrderBy.Relevant - Most relevant (search only) \uD83D\uDCBE Caching Example public class CachedPhotoService { private readonly UnsplasharpClient _client; private readonly IMemoryCache _cache; public async Task<Photo?> GetPhotoAsync(string photoId) { var cacheKey = $\"photo:{photoId}\"; if (_cache.TryGetValue(cacheKey, out Photo cachedPhoto)) return cachedPhoto; try { var photo = await _client.GetPhotoAsync(photoId); _cache.Set(cacheKey, photo, TimeSpan.FromHours(1)); return photo; } catch (UnsplasharpNotFoundException) { _cache.Set(cacheKey, (Photo?)null, TimeSpan.FromMinutes(5)); return null; } } } \uD83D\uDD27 Configuration ASP.NET Core Setup // Program.cs services.AddUnsplasharp(options => { options.ApplicationId = Configuration[\"Unsplash:ApplicationId\"]; options.ConfigureHttpClient = client => { client.Timeout = TimeSpan.FromSeconds(30); }; }); appsettings.json { \"Unsplash\": { \"ApplicationId\": \"your-app-id-here\" } } \uD83D\uDCE5 Download Images public async Task DownloadPhoto(Photo photo, string filePath) { using var httpClient = new HttpClient(); var imageBytes = await httpClient.GetByteArrayAsync(photo.Urls.Regular); await File.WriteAllBytesAsync(filePath, imageBytes); } \uD83D\uDD04 Pagination public async Task<List<Photo>> GetAllPhotos(string query, int maxPhotos = 100) { var allPhotos = new List<Photo>(); var page = 1; var perPage = 30; while (allPhotos.Count < maxPhotos) { var photos = await client.SearchPhotosAsync(query, page: page, perPage: perPage); if (photos.Count == 0) break; allPhotos.AddRange(photos); page++; // Rate limiting courtesy delay await Task.Delay(100); } return allPhotos.Take(maxPhotos).ToList(); } \uD83E\uDDEA Testing Unit Test Example [Test] public async Task GetPhoto_WithValidId_ReturnsPhoto() { // Arrange var mockClient = new Mock<UnsplasharpClient>(\"test-app-id\"); var expectedPhoto = new Photo { Id = \"test-id\" }; mockClient.Setup(c => c.GetPhotoAsync(\"test-id\", It.IsAny<CancellationToken>())) .ReturnsAsync(expectedPhoto); // Act var result = await mockClient.Object.GetPhotoAsync(\"test-id\"); // Assert Assert.AreEqual(\"test-id\", result.Id); } \uD83D\uDEA8 Common Pitfalls ❌ Don't Do This // Don't ignore rate limits for (int i = 0; i < 100; i++) { await client.GetRandomPhotoAsync(); // Will hit rate limit } // Don't create multiple clients var client1 = new UnsplasharpClient(\"app-id\"); var client2 = new UnsplasharpClient(\"app-id\"); // Wasteful // Don't hardcode API keys var client = new UnsplasharpClient(\"hardcoded-key\"); // Security risk ✅ Do This Instead // Handle rate limits try { await client.GetRandomPhotoAsync(); } catch (UnsplasharpRateLimitException ex) { await Task.Delay(ex.TimeUntilReset ?? TimeSpan.FromMinutes(1)); } // Use dependency injection services.AddUnsplasharp(\"app-id\"); // Use configuration var appId = Configuration[\"Unsplash:ApplicationId\"]; var client = new UnsplasharpClient(appId); \uD83D\uDCF1 Method Signatures Quick Reference // Photos Task<Photo> GetPhotoAsync(string id, CancellationToken cancellationToken = default) Task<Photo> GetRandomPhotoAsync(CancellationToken cancellationToken = default) Task<List<Photo>> SearchPhotosAsync(string query, int page = 1, int perPage = 10, ...) Task<List<Photo>> ListPhotosAsync(int page = 1, int perPage = 10, ...) // Users Task<User> GetUserAsync(string username, CancellationToken cancellationToken = default) Task<List<Photo>> GetUserPhotosAsync(string username, int page = 1, int perPage = 10, ...) Task<List<Photo>> GetUserLikesAsync(string username, int page = 1, int perPage = 10, ...) // Collections Task<Collection> GetCollectionAsync(string id, CancellationToken cancellationToken = default) Task<List<Photo>> GetCollectionPhotosAsync(string collectionId, int page = 1, int perPage = 10, ...) Task<List<Collection>> SearchCollectionsAsync(string query, int page = 1, int perPage = 10, ...) // Statistics Task<UnplashTotalStats> GetTotalStatsAsync(CancellationToken cancellationToken = default) Task<UnplashMonthlyStats> GetMonthlyStatsAsync(CancellationToken cancellationToken = default) Need more details? Check the complete documentation or API reference."
  },
  "system-text-json.html": {
    "href": "system-text-json.html",
    "title": "System.Text.Json Migration Guide | Unsplasharp Documentation",
    "summary": "System.Text.Json Migration Guide This document explains the migration from Newtonsoft.Json to System.Text.Json in Unsplasharp and its benefits. Overview Starting with version 2.0, Unsplasharp has migrated from Newtonsoft.Json to System.Text.Json for JSON serialization and deserialization. This change brings significant performance improvements and better integration with the modern .NET ecosystem. Benefits \uD83D\uDE80 Performance Improvements 2-3x faster JSON parsing compared to Newtonsoft.Json Reduced memory allocations during JSON operations Lower memory footprint due to System.Text.Json's efficient design Better garbage collection pressure with fewer temporary objects \uD83D\uDD27 Modern .NET Integration Built into .NET Standard 2.0+ - no additional dependencies required Better async support with JsonDocument and JsonElement Source generators support for AOT scenarios (future enhancement) Consistent with .NET ecosystem standards \uD83D\uDCE6 Reduced Dependencies Removed Newtonsoft.Json dependency - smaller package size Fewer transitive dependencies in your projects Better compatibility with trimming and AOT scenarios Technical Implementation JSON Parsing Architecture The migration involved replacing all Newtonsoft.Json usage with System.Text.Json equivalents: // Old approach (Newtonsoft.Json) var jObject = JObject.Parse(jsonString); var id = (string)jObject[\"id\"]; var width = (int)jObject[\"width\"]; // New approach (System.Text.Json) using var document = JsonDocument.Parse(jsonString); var root = document.RootElement; var id = root.GetProperty(\"id\").GetString(); var width = root.GetProperty(\"width\").GetInt32(); Custom JsonHelper Extensions We've created extension methods to make JSON property access safer and more convenient: // Safe property access with fallbacks var id = root.GetString(\"id\"); // Returns null if property doesn't exist var width = root.GetInt32(\"width\"); // Returns 0 if property doesn't exist var isPublic = root.GetBoolean(\"public\", true); // Returns true if property doesn't exist var rating = root.GetDouble(\"rating\", 0.0); // Returns 0.0 if property doesn't exist Model Serialization Models now use JsonPropertyName attributes for proper property mapping: public class Photo { [JsonPropertyName(\"id\")] public string Id { get; set; } [JsonPropertyName(\"created_at\")] public string CreatedAt { get; set; } [JsonPropertyName(\"updated_at\")] public string UpdatedAt { get; set; } // ... other properties } Custom Converters For complex scenarios, we've implemented custom JsonConverter classes: public class DateTimeConverter : JsonConverter<DateTime> { public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options) { var dateString = reader.GetString(); return DateTime.TryParse(dateString, out var date) ? date : DateTime.MinValue; } public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options) { writer.WriteStringValue(value.ToString(\"yyyy-MM-ddTHH:mm:ssZ\")); } } Performance Benchmarks Our performance tests show significant improvements: JSON Parsing Performance 1000 iterations of photo JSON parsing: ~50ms (vs ~150ms with Newtonsoft.Json) Memory usage: ~60% reduction in allocations Throughput: 2-3x improvement in operations per second JSON Serialization Performance 1000 iterations of object serialization: ~30ms (vs ~80ms with Newtonsoft.Json) Memory efficiency: ~40% fewer allocations CPU usage: ~50% reduction in processing time Migration Impact For Library Users No breaking changes - The public API remains exactly the same. Your existing code will continue to work without modifications: // This code works exactly the same as before var client = new UnsplasharpClient(\"YOUR_APP_ID\"); var photos = await client.SearchPhotos(\"nature\"); var photo = await client.GetPhoto(\"photo-id\"); For Contributors If you're contributing to the library, be aware of these changes: Use JsonDocument/JsonElement instead of JObject/JArray Use extension methods from JsonHelpers for safe property access Add JsonPropertyName attributes to new model properties Test JSON parsing with the new performance test suite Error Handling System.Text.Json has different error handling characteristics: // Robust error handling with our extension methods try { using var document = JsonDocument.Parse(jsonString); var root = document.RootElement; // Safe property access - returns null/default if property missing var id = root.GetString(\"id\"); var width = root.GetInt32(\"width\"); // Handle potential null values appropriately if (id != null) { // Process the photo } } catch (JsonException ex) { // Handle JSON parsing errors logger.LogError(ex, \"Failed to parse JSON response\"); } Future Enhancements With System.Text.Json in place, we're positioned for future improvements: Source generators for AOT compilation support Streaming JSON parsing for large responses Custom serialization policies for different API versions Better integration with .NET's built-in HTTP client features Troubleshooting Common Issues JsonException during parsing Check that the JSON response format matches expected structure Use our JsonHelper extension methods for safer property access Missing properties Verify JsonPropertyName attributes match API response Use optional parameters in extension methods for fallback values Performance not as expected Ensure you're disposing JsonDocument instances properly Use ConfigureAwait(false) in async scenarios Getting Help If you encounter issues related to the JSON migration: Check the performance tests for examples Review the JsonHelpers extension methods Open an issue on GitHub with specific error details Conclusion The migration to System.Text.Json represents a significant step forward for Unsplasharp, bringing better performance, reduced dependencies, and improved integration with the modern .NET ecosystem. The migration maintains full backward compatibility while providing a foundation for future enhancements."
  },
  "table-of-contents.html": {
    "href": "table-of-contents.html",
    "title": "Unsplasharp Documentation - Table of Contents | Unsplasharp Documentation",
    "summary": "Unsplasharp Documentation - Table of Contents Complete overview of all Unsplasharp documentation with detailed section breakdowns. \uD83D\uDCCB Complete Documentation Index \uD83C\uDFE0 Main Documentation Hub Quick start guide Core documentation overview Navigation by use case and experience level API overview and features Installation instructions External resources \uD83D\uDE80 Getting Started Guide Prerequisites and installation Getting your API key Basic setup (Console, ASP.NET Core) Your first request Common use cases with examples Error handling introduction Best practices overview Next steps and sample projects \uD83D\uDD27 API Reference Guide Client Initialization Basic initialization Dependency injection setup Photo Methods GetPhoto / GetPhotoAsync GetRandomPhoto / GetRandomPhotoAsync ListPhotos / ListPhotosAsync Search Methods SearchPhotos / SearchPhotosAsync Collection Methods GetCollection / GetCollectionAsync ListCollections / ListCollectionsAsync GetCollectionPhotos / GetCollectionPhotosAsync SearchCollections / SearchCollectionsAsync User Methods GetUser / GetUserAsync GetUserPhotos / GetUserPhotosAsync GetUserLikes / GetUserLikesAsync GetUserCollections / GetUserCollectionsAsync Statistics Methods GetTotalStats / GetTotalStatsAsync GetMonthlyStats / GetMonthlyStatsAsync Method Parameters Common parameters Photo-specific parameters Search filters Return Types Photo model Collection model User model URL types Rate Limiting Rate limit information Handling rate limits Best Practices Exception-throwing methods Error handling patterns Cancellation tokens Rate limit monitoring \uD83D\uDCCA Models Reference Guide Photo Model Properties and usage examples Photo filtering and analysis User Model Properties and usage examples User analysis utilities Collection Model Properties and usage examples URL Models Urls class ProfileImage class URL optimization helpers Location and EXIF Models Location class with GPS data EXIF class with camera data Analysis utilities Statistics Models UnplashTotalStats class UnplashMonthlyStats class Usage examples Link Models PhotoLinks, UserLinks, CollectionLinks Supporting Models Category, Badge classes Model Relationships Relationship diagram Navigation examples Usage Examples Complete photo analysis \uD83D\uDE80 Advanced Usage Patterns Advanced Pagination Strategies Infinite scroll implementation Parallel pagination Filtering and Search Optimization Advanced search builder Smart search with fallbacks Custom Parameters and URL Manipulation Custom photo sizing URL parameter optimization Performance Optimization Intelligent caching strategy Connection pooling and HTTP optimization Batch Operations Efficient bulk photo processing Batch download manager Monitoring and Metrics Performance metrics collection \uD83D\uDCBB Code Examples and Recipes Basic Operations Simple photo retrieval Photo information display Search and Discovery Smart search with fallbacks Advanced search filters Pagination helper User and Collection Management User profile analysis Collection explorer Image Processing and Download Smart image downloader Image metadata extractor Web Application Integration ASP.NET Core photo API Desktop Application Examples WPF photo gallery Console photo browser Background Services Photo sync service Testing Patterns Unit testing with mocking Integration testing Performance Optimization Caching strategies Batch processing Connection pool optimization \uD83E\uDDEA Testing and Best Practices Guide Testing Strategies Test pyramid approach Testing infrastructure setup Unit Testing Success scenarios Error scenarios Caching behavior Integration Testing API contract testing Rate limit testing Performance Testing Load testing Memory usage testing Best Practices Error handling patterns Caching strategies Rate limiting approaches Dependency injection Common Pitfalls Rate limit handling mistakes HttpClient usage issues Cancellation token omissions Security Considerations API key management Input validation User rate limiting Production Deployment Configuration management Health checks Graceful degradation Monitoring and Observability Structured logging Custom metrics Application Insights integration \uD83D\uDD04 Migration and Upgrade Guide Version Compatibility Supported .NET versions API compatibility Breaking Changes (None!) New Features Overview Comprehensive error handling IHttpClientFactory integration Structured logging Enhanced async support Migration Strategies Gradual migration (recommended) New project setup Error Handling Migration Before and after examples Migration helper utilities IHttpClientFactory Migration Manual vs. DI setup Logging Integration Setup and configuration Performance Improvements Connection pooling Retry policies Rate limit optimization Best Practices Updates Cancellation tokens Error handling patterns Dependency injection Caching strategies Troubleshooting Common Issues Null reference exceptions HttpClient disposal issues Rate limit handling Configuration problems Migration Checklist Testing Your Migration ⚠️ Error Handling Guide Exception Types UnsplasharpException (base) UnsplasharpNotFoundException UnsplasharpRateLimitException UnsplasharpAuthenticationException UnsplasharpNetworkException UnsplasharpTimeoutException Error Context Rich error information Correlation IDs Request/response details Handling Strategies Basic error handling Advanced error handling Retry patterns Rate Limit Handling Detection and response Backoff strategies Network Error Handling Transient vs. permanent errors Retry logic Authentication Errors API key validation Permission issues Best Practices Exception-throwing methods Logging strategies User experience considerations \uD83C\uDF10 IHttpClientFactory Integration Overview and Benefits Basic Setup Advanced Configuration Dependency Injection Custom HTTP Handlers Performance Considerations Troubleshooting \uD83D\uDCDD Logging Configuration Setup and Configuration Log Levels and Categories Structured Logging Custom Log Providers Performance Considerations Troubleshooting \uD83D\uDCD6 Introduction Library overview Key features Architecture Getting started \uD83D\uDD11 Obtaining an API Key Unsplash developer account setup Application registration API key management Rate limits and quotas \uD83D\uDCE5 Downloading a Photo Basic download examples Different image sizes Error handling Best practices \uD83E\uDDED Navigation Guide Find what you need quickly Documentation structure Learning paths Search tips \uD83D\uDCDA Documentation Categories By Audience Beginners: Getting Started, Introduction, API Key Setup Developers: API Reference, Models, Code Examples Advanced Users: Advanced Usage, Testing, Migration DevOps/Production: Best Practices, Error Handling, Monitoring By Topic Setup & Configuration: Getting Started, HTTP Client Factory, Logging API Usage: API Reference, Models, Error Handling Development: Code Examples, Testing, Best Practices Advanced Topics: Advanced Usage, Performance, Migration Production: Testing, Security, Monitoring, Deployment By Content Type Guides: Step-by-step instructions and tutorials References: Complete API and model documentation Examples: Practical code samples and recipes Best Practices: Recommendations and patterns \uD83D\uDD17 Cross-References Common Workflows New Project Setup: Getting Started → API Key → Basic Examples → Error Handling Production Deployment: Best Practices → Testing → Error Handling → Monitoring Performance Optimization: Advanced Usage → Caching → Batch Operations → Monitoring Troubleshooting: Error Handling → Testing → Migration Guide → Navigation Related Topics Error Handling ↔ Testing ↔ Best Practices API Reference ↔ Models ↔ Code Examples Advanced Usage ↔ Performance ↔ Production Migration ↔ Best Practices ↔ Testing Quick Navigation: Main Hub | Getting Started | API Reference | Examples"
  },
  "testing-best-practices.html": {
    "href": "testing-best-practices.html",
    "title": "Testing and Best Practices Guide | Unsplasharp Documentation",
    "summary": "Testing and Best Practices Guide This comprehensive guide covers testing strategies, best practices, and common pitfalls to avoid when working with Unsplasharp. Table of Contents Testing Strategies Unit Testing Integration Testing Performance Testing Best Practices Common Pitfalls Security Considerations Production Deployment Monitoring and Observability Testing Strategies Test Pyramid for Unsplasharp Applications /\\ / \\ E2E Tests (Few) /____\\ - Full application flow / \\ - Real API integration /__________\\ Integration Tests (Some) - API contract testing - Error handling scenarios Unit Tests (Many) - Business logic - Error handling - Caching behavior - Data transformation Testing Approach Unit Tests (70%): Test business logic, error handling, and data transformations Integration Tests (20%): Test API interactions and error scenarios End-to-End Tests (10%): Test complete user workflows Unit Testing Setting Up Test Infrastructure [TestFixture] public class PhotoServiceTests { private Mock<UnsplasharpClient> _mockClient; private Mock<IMemoryCache> _mockCache; private Mock<ILogger<PhotoService>> _mockLogger; private PhotoService _photoService; private TestData _testData; [SetUp] public void Setup() { _mockClient = new Mock<UnsplasharpClient>(\"test-app-id\"); _mockCache = new Mock<IMemoryCache>(); _mockLogger = new Mock<ILogger<PhotoService>>(); _testData = new TestData(); _photoService = new PhotoService(_mockClient.Object, _mockCache.Object, _mockLogger.Object); } [TearDown] public void TearDown() { _photoService?.Dispose(); } } public class TestData { public Photo CreateValidPhoto(string id = null) { return new Photo { Id = id ?? Guid.NewGuid().ToString(), Description = \"Test photo description\", Width = 1920, Height = 1080, Color = \"#FF5733\", Likes = 150, Downloads = 500, CreatedAt = DateTime.UtcNow.AddDays(-30).ToString(\"O\"), UpdatedAt = DateTime.UtcNow.AddDays(-1).ToString(\"O\"), User = CreateValidUser(), Urls = CreateValidUrls(), Exif = CreateValidExif(), Location = CreateValidLocation() }; } public User CreateValidUser(string username = null) { return new User { Id = Guid.NewGuid().ToString(), Username = username ?? \"testuser\", Name = \"Test User\", Bio = \"Test photographer\", TotalPhotos = 100, TotalLikes = 5000, ProfileImage = new ProfileImage { Small = \"https://example.com/profile-small.jpg\", Medium = \"https://example.com/profile-medium.jpg\", Large = \"https://example.com/profile-large.jpg\" } }; } public Urls CreateValidUrls() { return new Urls { Thumbnail = \"https://example.com/thumb.jpg\", Small = \"https://example.com/small.jpg\", Regular = \"https://example.com/regular.jpg\", Full = \"https://example.com/full.jpg\", Raw = \"https://example.com/raw.jpg\" }; } public Exif CreateValidExif() { return new Exif { Make = \"Canon\", Model = \"EOS 5D Mark IV\", Aperture = \"2.8\", ExposureTime = \"1/125\", Iso = 400, FocalLength = \"85mm\" }; } public Location CreateValidLocation() { return new Location { Name = \"Paris, France\", City = \"Paris\", Country = \"France\", Position = new Position { Latitude = 48.8566, Longitude = 2.3522 } }; } } Testing Success Scenarios [Test] public async Task GetRandomPhoto_Success_ReturnsPhoto() { // Arrange var expectedPhoto = _testData.CreateValidPhoto(); _mockClient.Setup(c => c.GetRandomPhotoAsync(It.IsAny<CancellationToken>())) .ReturnsAsync(expectedPhoto); // Act var result = await _photoService.GetRandomPhotoAsync(); // Assert Assert.IsNotNull(result); Assert.AreEqual(expectedPhoto.Id, result.Id); Assert.AreEqual(expectedPhoto.Description, result.Description); Assert.AreEqual(expectedPhoto.User.Name, result.User.Name); // Verify the mock was called correctly _mockClient.Verify(c => c.GetRandomPhotoAsync(It.IsAny<CancellationToken>()), Times.Once); } [Test] public async Task SearchPhotos_WithValidQuery_ReturnsFilteredResults() { // Arrange var query = \"nature\"; var photos = new List<Photo> { _testData.CreateValidPhoto(\"1\"), _testData.CreateValidPhoto(\"2\"), _testData.CreateValidPhoto(\"3\") }; _mockClient.Setup(c => c.SearchPhotosAsync( query, It.IsAny<int>(), It.IsAny<int>(), It.IsAny<OrderBy>(), It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>(), It.IsAny<Orientation>(), It.IsAny<CancellationToken>())) .ReturnsAsync(photos); // Act var result = await _photoService.SearchPhotosAsync(query); // Assert Assert.IsNotNull(result); Assert.AreEqual(photos.Count, result.Count); CollectionAssert.AreEqual(photos.Select(p => p.Id), result.Select(p => p.Id)); } Testing Error Scenarios [Test] public async Task GetPhoto_NotFound_ReturnsNull() { // Arrange var photoId = \"non-existent-id\"; _mockClient.Setup(c => c.GetPhotoAsync(photoId, It.IsAny<CancellationToken>())) .ThrowsAsync(new UnsplasharpNotFoundException(\"Photo not found\", photoId, \"Photo\", \"https://api.unsplash.com/photos/non-existent-id\", \"GET\", new ErrorContext(\"test-app\"))); // Act var result = await _photoService.GetPhotoSafelyAsync(photoId); // Assert Assert.IsNull(result); // Verify logging VerifyLogCalled(LogLevel.Warning, \"Photo non-existent-id not found\"); } [Test] public async Task GetPhoto_RateLimited_ThrowsException() { // Arrange var photoId = \"test-id\"; var rateLimitException = new UnsplasharpRateLimitException( \"Rate limit exceeded\", 0, 5000, DateTimeOffset.UtcNow.AddMinutes(15), \"https://api.unsplash.com/photos/test-id\", \"GET\", new ErrorContext(\"test-app\")); _mockClient.Setup(c => c.GetPhotoAsync(photoId, It.IsAny<CancellationToken>())) .ThrowsAsync(rateLimitException); // Act & Assert var ex = await Assert.ThrowsAsync<UnsplasharpRateLimitException>( () => _photoService.GetPhotoAsync(photoId)); Assert.AreEqual(0, ex.RateLimitRemaining); Assert.AreEqual(5000, ex.RateLimit); Assert.IsNotNull(ex.RateLimitReset); } [Test] public async Task SearchPhotos_NetworkError_RetriesAndFails() { // Arrange var query = \"test\"; var networkException = new UnsplasharpNetworkException( \"Network error\", new HttpRequestException(\"Connection failed\"), true, // IsRetryable \"https://api.unsplash.com/search/photos\", \"GET\", new ErrorContext(\"test-app\")); _mockClient.Setup(c => c.SearchPhotosAsync( It.IsAny<string>(), It.IsAny<int>(), It.IsAny<int>(), It.IsAny<OrderBy>(), It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>(), It.IsAny<Orientation>(), It.IsAny<CancellationToken>())) .ThrowsAsync(networkException); // Act & Assert var ex = await Assert.ThrowsAsync<UnsplasharpNetworkException>( () => _photoService.SearchPhotosAsync(query)); Assert.IsTrue(ex.IsRetryable); // Verify retry attempts (if implemented) _mockClient.Verify(c => c.SearchPhotosAsync( It.IsAny<string>(), It.IsAny<int>(), It.IsAny<int>(), It.IsAny<OrderBy>(), It.IsAny<string>(), It.IsAny<string>(), It.IsAny<string>(), It.IsAny<Orientation>(), It.IsAny<CancellationToken>()), Times.AtLeastOnce); } private void VerifyLogCalled(LogLevel level, string message) { _mockLogger.Verify( x => x.Log( level, It.IsAny<EventId>(), It.Is<It.IsAnyType>((v, t) => v.ToString().Contains(message)), It.IsAny<Exception>(), It.IsAny<Func<It.IsAnyType, Exception, string>>()), Times.Once); } Testing Caching Behavior [Test] public async Task GetPhoto_CacheHit_ReturnsFromCache() { // Arrange var photoId = \"cached-photo\"; var cachedPhoto = _testData.CreateValidPhoto(photoId); object cacheValue = cachedPhoto; _mockCache.Setup(c => c.TryGetValue($\"photo:{photoId}\", out cacheValue)) .Returns(true); // Act var result = await _photoService.GetPhotoAsync(photoId); // Assert Assert.IsNotNull(result); Assert.AreEqual(cachedPhoto.Id, result.Id); // Verify API was not called _mockClient.Verify(c => c.GetPhotoAsync(It.IsAny<string>(), It.IsAny<CancellationToken>()), Times.Never); // Verify cache was checked _mockCache.Verify(c => c.TryGetValue($\"photo:{photoId}\", out It.Ref<object>.IsAny), Times.Once); } [Test] public async Task GetPhoto_CacheMiss_FetchesAndCaches() { // Arrange var photoId = \"new-photo\"; var photo = _testData.CreateValidPhoto(photoId); object cacheValue = null; _mockCache.Setup(c => c.TryGetValue($\"photo:{photoId}\", out cacheValue)) .Returns(false); _mockClient.Setup(c => c.GetPhotoAsync(photoId, It.IsAny<CancellationToken>())) .ReturnsAsync(photo); // Act var result = await _photoService.GetPhotoAsync(photoId); // Assert Assert.IsNotNull(result); Assert.AreEqual(photo.Id, result.Id); // Verify API was called _mockClient.Verify(c => c.GetPhotoAsync(photoId, It.IsAny<CancellationToken>()), Times.Once); // Verify caching occurred _mockCache.Verify(c => c.Set( $\"photo:{photoId}\", photo, It.IsAny<TimeSpan>()), Times.Once); } Integration Testing Test Configuration [TestFixture] [Category(\"Integration\")] public class UnsplashIntegrationTests { private UnsplasharpClient _client; private ILogger<UnsplashIntegrationTests> _logger; private readonly string _testApplicationId; public UnsplashIntegrationTests() { // Use environment variable or test configuration _testApplicationId = Environment.GetEnvironmentVariable(\"UNSPLASH_TEST_APP_ID\") ?? throw new InvalidOperationException(\"UNSPLASH_TEST_APP_ID environment variable not set\"); } [SetUp] public void Setup() { var loggerFactory = LoggerFactory.Create(builder => builder.AddConsole().SetMinimumLevel(LogLevel.Debug)); _logger = loggerFactory.CreateLogger<UnsplashIntegrationTests>(); _client = new UnsplasharpClient(_testApplicationId, logger: _logger); } [TearDown] public void TearDown() { _client?.Dispose(); } } API Contract Testing [Test] [Retry(3)] // Retry on rate limit or network issues public async Task GetRandomPhoto_ReturnsValidPhotoStructure() { // Act var photo = await _client.GetRandomPhotoAsync(); // Assert - Validate complete photo structure Assert.IsNotNull(photo); // Basic properties Assert.IsNotEmpty(photo.Id); Assert.Greater(photo.Width, 0); Assert.Greater(photo.Height, 0); Assert.IsNotEmpty(photo.Color); Assert.GreaterOrEqual(photo.Likes, 0); Assert.GreaterOrEqual(photo.Downloads, 0); // User information Assert.IsNotNull(photo.User); Assert.IsNotEmpty(photo.User.Id); Assert.IsNotEmpty(photo.User.Name); Assert.IsNotEmpty(photo.User.Username); // URLs Assert.IsNotNull(photo.Urls); Assert.IsTrue(Uri.IsWellFormedUriString(photo.Urls.Thumbnail, UriKind.Absolute)); Assert.IsTrue(Uri.IsWellFormedUriString(photo.Urls.Small, UriKind.Absolute)); Assert.IsTrue(Uri.IsWellFormedUriString(photo.Urls.Regular, UriKind.Absolute)); Assert.IsTrue(Uri.IsWellFormedUriString(photo.Urls.Full, UriKind.Absolute)); Assert.IsTrue(Uri.IsWellFormedUriString(photo.Urls.Raw, UriKind.Absolute)); // Timestamps Assert.DoesNotThrow(() => DateTime.Parse(photo.CreatedAt)); Assert.DoesNotThrow(() => DateTime.Parse(photo.UpdatedAt)); _logger.LogInformation(\"Successfully validated photo structure for {PhotoId}\", photo.Id); } [Test] public async Task SearchPhotos_WithValidQuery_ReturnsRelevantResults() { // Arrange var query = \"nature\"; var expectedMinResults = 5; // Act var photos = await _client.SearchPhotosAsync(query, perPage: 10); // Assert Assert.IsNotNull(photos); Assert.GreaterOrEqual(photos.Count, expectedMinResults); Assert.Greater(_client.LastPhotosSearchTotalResults, 0); Assert.Greater(_client.LastPhotosSearchTotalPages, 0); // Validate each photo foreach (var photo in photos) { Assert.IsNotEmpty(photo.Id); Assert.IsNotNull(photo.User); Assert.IsNotNull(photo.Urls); // Check if description or tags might contain the search term var searchRelevant = photo.Description?.ToLowerInvariant().Contains(query.ToLowerInvariant()) == true || photo.Categories.Any(c => c.Title.ToLowerInvariant().Contains(query.ToLowerInvariant())); // Note: Not all results may contain the exact term due to Unsplash's search algorithm _logger.LogDebug(\"Photo {PhotoId}: {Description} - Search relevant: {Relevant}\", photo.Id, photo.Description, searchRelevant); } } [Test] public async Task GetPhoto_WithInvalidId_ThrowsNotFoundException() { // Arrange var invalidId = \"definitely-not-a-real-photo-id-12345\"; // Act & Assert var ex = await Assert.ThrowsAsync<UnsplasharpNotFoundException>( () => _client.GetPhotoAsync(invalidId)); Assert.AreEqual(invalidId, ex.ResourceId); Assert.AreEqual(\"Photo\", ex.ResourceType); Assert.IsNotNull(ex.Context); Assert.IsNotEmpty(ex.Context.CorrelationId); _logger.LogInformation(\"Correctly handled not found exception for {PhotoId}\", invalidId); } Rate Limit Testing [Test] [Explicit(\"Only run when testing rate limits\")] public async Task RateLimit_ExceedsLimit_HandlesGracefully() { var successCount = 0; var rateLimitCount = 0; var tasks = new List<Task>(); // Create many concurrent requests to trigger rate limiting for (int i = 0; i < 100; i++) { tasks.Add(Task.Run(async () => { try { await _client.GetRandomPhotoAsync(); Interlocked.Increment(ref successCount); } catch (UnsplasharpRateLimitException ex) { Interlocked.Increment(ref rateLimitCount); _logger.LogWarning(\"Rate limited: {Remaining}/{Total}, Reset: {Reset}\", ex.RateLimitRemaining, ex.RateLimit, ex.RateLimitReset); } })); } await Task.WhenAll(tasks); _logger.LogInformation(\"Rate limit test completed: {Success} successful, {RateLimited} rate limited\", successCount, rateLimitCount); Assert.Greater(successCount, 0, \"At least some requests should succeed\"); Assert.Greater(rateLimitCount, 0, \"Should hit rate limits with 100 concurrent requests\"); } [Test] public async Task RateLimit_CheckHeaders_UpdatesClientState() { // Act await _client.GetRandomPhotoAsync(); // Assert Assert.Greater(_client.MaxRateLimit, 0); Assert.GreaterOrEqual(_client.RateLimitRemaining, 0); Assert.LessOrEqual(_client.RateLimitRemaining, _client.MaxRateLimit); _logger.LogInformation(\"Rate limit status: {Remaining}/{Max}\", _client.RateLimitRemaining, _client.MaxRateLimit); } Performance Testing Load Testing [TestFixture] [Category(\"Performance\")] public class PerformanceTests { private UnsplasharpClient _client; private ILogger<PerformanceTests> _logger; [SetUp] public void Setup() { var loggerFactory = LoggerFactory.Create(builder => builder.AddConsole().SetMinimumLevel(LogLevel.Information)); _logger = loggerFactory.CreateLogger<PerformanceTests>(); _client = new UnsplasharpClient(Environment.GetEnvironmentVariable(\"UNSPLASH_TEST_APP_ID\")); } [Test] [Explicit(\"Performance test - run manually\")] public async Task Performance_ConcurrentRequests_MeasuresThroughput() { const int concurrentRequests = 10; const int requestsPerWorker = 5; var stopwatch = Stopwatch.StartNew(); var successCount = 0; var errorCount = 0; var tasks = Enumerable.Range(0, concurrentRequests).Select(async workerId => { for (int i = 0; i < requestsPerWorker; i++) { try { await _client.GetRandomPhotoAsync(); Interlocked.Increment(ref successCount); } catch (UnsplasharpRateLimitException) { // Expected under load Interlocked.Increment(ref errorCount); } catch (Exception ex) { _logger.LogError(ex, \"Unexpected error in worker {WorkerId}, request {RequestId}\", workerId, i); Interlocked.Increment(ref errorCount); } // Small delay to avoid overwhelming the API await Task.Delay(100); } }); await Task.WhenAll(tasks); stopwatch.Stop(); var totalRequests = successCount + errorCount; var throughput = totalRequests / stopwatch.Elapsed.TotalSeconds; _logger.LogInformation(\"Performance test completed:\"); _logger.LogInformation(\" Total requests: {Total}\", totalRequests); _logger.LogInformation(\" Successful: {Success}\", successCount); _logger.LogInformation(\" Errors: {Errors}\", errorCount); _logger.LogInformation(\" Duration: {Duration:F2}s\", stopwatch.Elapsed.TotalSeconds); _logger.LogInformation(\" Throughput: {Throughput:F2} req/s\", throughput); Assert.Greater(successCount, 0); Assert.Greater(throughput, 0.5); // At least 0.5 requests per second } [Test] public async Task Performance_ResponseTime_WithinAcceptableLimits() { const int iterations = 10; var responseTimes = new List<TimeSpan>(); for (int i = 0; i < iterations; i++) { var stopwatch = Stopwatch.StartNew(); try { await _client.GetRandomPhotoAsync(); stopwatch.Stop(); responseTimes.Add(stopwatch.Elapsed); } catch (UnsplasharpRateLimitException) { // Skip rate limited requests continue; } // Small delay between requests await Task.Delay(200); } if (responseTimes.Count == 0) { Assert.Inconclusive(\"All requests were rate limited\"); } var averageResponseTime = TimeSpan.FromMilliseconds(responseTimes.Average(t => t.TotalMilliseconds)); var maxResponseTime = responseTimes.Max(); _logger.LogInformation(\"Response time analysis:\"); _logger.LogInformation(\" Average: {Average:F0}ms\", averageResponseTime.TotalMilliseconds); _logger.LogInformation(\" Maximum: {Max:F0}ms\", maxResponseTime.TotalMilliseconds); _logger.LogInformation(\" Samples: {Count}\", responseTimes.Count); Assert.Less(averageResponseTime.TotalSeconds, 5.0, \"Average response time should be under 5 seconds\"); Assert.Less(maxResponseTime.TotalSeconds, 10.0, \"Maximum response time should be under 10 seconds\"); } } Memory Usage Testing [Test] [Explicit(\"Memory test - run manually\")] public async Task Memory_MultipleRequests_NoMemoryLeaks() { const int iterations = 100; // Force garbage collection before test GC.Collect(); GC.WaitForPendingFinalizers(); GC.Collect(); var initialMemory = GC.GetTotalMemory(false); for (int i = 0; i < iterations; i++) { try { var photo = await _client.GetRandomPhotoAsync(); // Process the photo to ensure it's not optimized away var info = $\"{photo.Id}:{photo.Width}x{photo.Height}\"; if (i % 10 == 0) { var currentMemory = GC.GetTotalMemory(false); _logger.LogDebug(\"Iteration {Iteration}: Memory usage {Memory:N0} bytes\", i, currentMemory); } } catch (UnsplasharpRateLimitException) { // Wait and continue await Task.Delay(1000); } } // Force garbage collection after test GC.Collect(); GC.WaitForPendingFinalizers(); GC.Collect(); var finalMemory = GC.GetTotalMemory(false); var memoryIncrease = finalMemory - initialMemory; _logger.LogInformation(\"Memory usage analysis:\"); _logger.LogInformation(\" Initial: {Initial:N0} bytes\", initialMemory); _logger.LogInformation(\" Final: {Final:N0} bytes\", finalMemory); _logger.LogInformation(\" Increase: {Increase:N0} bytes\", memoryIncrease); // Allow for some memory increase, but not excessive var maxAllowedIncrease = 10 * 1024 * 1024; // 10MB Assert.Less(memoryIncrease, maxAllowedIncrease, $\"Memory increase should be less than {maxAllowedIncrease:N0} bytes\"); } Best Practices 1. Error Handling Best Practices // ✅ Good: Specific exception handling public async Task<Photo?> GetPhotoSafely(string photoId) { try { return await _client.GetPhotoAsync(photoId); } catch (UnsplasharpNotFoundException) { _logger.LogWarning(\"Photo {PhotoId} not found\", photoId); return null; } catch (UnsplasharpRateLimitException ex) { _logger.LogWarning(\"Rate limited for photo {PhotoId}. Reset: {Reset}\", photoId, ex.RateLimitReset); throw; // Re-throw to let caller handle rate limiting } catch (UnsplasharpAuthenticationException ex) { _logger.LogError(ex, \"Authentication failed - check API key\"); throw; // Critical error - should not continue } catch (UnsplasharpNetworkException ex) when (ex.IsRetryable) { _logger.LogWarning(\"Retryable network error for photo {PhotoId}: {Message}\", photoId, ex.Message); throw; // Let retry logic handle this } catch (UnsplasharpException ex) { _logger.LogError(ex, \"Unexpected Unsplash error for photo {PhotoId}\", photoId); throw; } } // ❌ Bad: Generic exception handling public async Task<Photo?> GetPhotoBadly(string photoId) { try { return await _client.GetPhotoAsync(photoId); } catch (Exception ex) { _logger.LogError(ex, \"Error getting photo\"); return null; // Loses important error information } } 2. Caching Best Practices // ✅ Good: Intelligent caching with appropriate TTL public class PhotoCacheService { private readonly IMemoryCache _cache; private readonly UnsplasharpClient _client; public async Task<Photo?> GetPhotoAsync(string photoId) { var cacheKey = $\"photo:{photoId}\"; if (_cache.TryGetValue(cacheKey, out Photo cachedPhoto)) { return cachedPhoto; } try { var photo = await _client.GetPhotoAsync(photoId); // Cache popular photos longer var cacheDuration = photo.Likes > 1000 ? TimeSpan.FromHours(2) : TimeSpan.FromMinutes(30); _cache.Set(cacheKey, photo, cacheDuration); return photo; } catch (UnsplasharpNotFoundException) { // Cache negative results for shorter time _cache.Set(cacheKey, (Photo?)null, TimeSpan.FromMinutes(5)); return null; } } } // ❌ Bad: No caching or inappropriate caching public class BadPhotoService { public async Task<Photo?> GetPhotoAsync(string photoId) { // Always hits API - no caching return await _client.GetPhotoAsync(photoId); } // Or caching everything for the same duration public async Task<Photo?> GetPhotoCachedBadly(string photoId) { var cacheKey = $\"photo:{photoId}\"; if (_cache.TryGetValue(cacheKey, out Photo cachedPhoto)) return cachedPhoto; var photo = await _client.GetPhotoAsync(photoId); // Bad: Same cache duration for all photos _cache.Set(cacheKey, photo, TimeSpan.FromDays(1)); // Too long! return photo; } } 3. Rate Limiting Best Practices // ✅ Good: Proactive rate limit monitoring public class RateLimitAwareService { private readonly UnsplasharpClient _client; private readonly ILogger<RateLimitAwareService> _logger; public async Task<List<Photo>> GetMultiplePhotosAsync(IEnumerable<string> photoIds) { var photos = new List<Photo>(); foreach (var photoId in photoIds) { // Check rate limit before making request if (_client.RateLimitRemaining < 10) { _logger.LogWarning(\"Rate limit running low: {Remaining}/{Max}. Pausing requests.\", _client.RateLimitRemaining, _client.MaxRateLimit); await Task.Delay(TimeSpan.FromSeconds(30)); } try { var photo = await _client.GetPhotoAsync(photoId); photos.Add(photo); } catch (UnsplasharpRateLimitException ex) { _logger.LogWarning(\"Rate limited. Waiting until {Reset}\", ex.RateLimitReset); if (ex.TimeUntilReset.HasValue) { await Task.Delay(ex.TimeUntilReset.Value); // Retry the request var photo = await _client.GetPhotoAsync(photoId); photos.Add(photo); } break; // Stop processing if rate limited } } return photos; } } // ❌ Bad: Ignoring rate limits public class BadRateLimitService { public async Task<List<Photo>> GetMultiplePhotosBadly(IEnumerable<string> photoIds) { var tasks = photoIds.Select(id => _client.GetPhotoAsync(id)); try { var photos = await Task.WhenAll(tasks); return photos.ToList(); } catch (UnsplasharpRateLimitException) { // Bad: Just give up on rate limit return new List<Photo>(); } } } 4. Dependency Injection Best Practices // ✅ Good: Proper DI setup public void ConfigureServices(IServiceCollection services) { // Configure Unsplasharp with proper lifetime services.AddUnsplasharp(options => { options.ApplicationId = Configuration[\"Unsplash:ApplicationId\"]; options.ConfigureHttpClient = client => { client.Timeout = TimeSpan.FromSeconds(30); }; }); // Register services with appropriate lifetimes services.AddScoped<IPhotoService, PhotoService>(); services.AddSingleton<IPhotoCache, PhotoCacheService>(); services.AddMemoryCache(); } // ❌ Bad: Manual instantiation in services public class BadPhotoService { private readonly UnsplasharpClient _client; public BadPhotoService() { // Bad: Creates new client instance, no DI _client = new UnsplasharpClient(\"hardcoded-app-id\"); } } Common Pitfalls 1. Not Handling Rate Limits // ❌ Common mistake: Ignoring rate limits public async Task<List<Photo>> SearchManyQueries(string[] queries) { var allPhotos = new List<Photo>(); foreach (var query in queries) { // This will likely hit rate limits var photos = await _client.SearchPhotosAsync(query, perPage: 30); allPhotos.AddRange(photos); } return allPhotos; } // ✅ Better approach: Rate limit aware public async Task<List<Photo>> SearchManyQueriesSafely(string[] queries) { var allPhotos = new List<Photo>(); foreach (var query in queries) { try { var photos = await _client.SearchPhotosAsync(query, perPage: 30); allPhotos.AddRange(photos); // Courtesy delay between requests await Task.Delay(100); } catch (UnsplasharpRateLimitException ex) { _logger.LogWarning(\"Rate limited, waiting {Delay}ms\", ex.TimeUntilReset?.TotalMilliseconds); if (ex.TimeUntilReset.HasValue) { await Task.Delay(ex.TimeUntilReset.Value); } // Optionally retry the failed query } } return allPhotos; } 2. Improper HttpClient Usage // ❌ Bad: Creating HttpClient instances manually public class BadDownloadService { public async Task DownloadPhoto(string photoUrl, string filePath) { // Bad: Creates new HttpClient for each download using var httpClient = new HttpClient(); var imageBytes = await httpClient.GetByteArrayAsync(photoUrl); await File.WriteAllBytesAsync(filePath, imageBytes); } } // ✅ Good: Using IHttpClientFactory public class GoodDownloadService { private readonly IHttpClientFactory _httpClientFactory; public GoodDownloadService(IHttpClientFactory httpClientFactory) { _httpClientFactory = httpClientFactory; } public async Task DownloadPhoto(string photoUrl, string filePath) { using var httpClient = _httpClientFactory.CreateClient(); var imageBytes = await httpClient.GetByteArrayAsync(photoUrl); await File.WriteAllBytesAsync(filePath, imageBytes); } } 3. Not Using Cancellation Tokens // ❌ Bad: No cancellation support public async Task<List<Photo>> SearchPhotosSlowly(string query) { var photos = new List<Photo>(); for (int page = 1; page <= 10; page++) { // No way to cancel this long-running operation var pagePhotos = await _client.SearchPhotosAsync(query, page: page); photos.AddRange(pagePhotos); await Task.Delay(1000); // Simulate slow processing } return photos; } // ✅ Good: Cancellation token support public async Task<List<Photo>> SearchPhotosWithCancellation(string query, CancellationToken cancellationToken) { var photos = new List<Photo>(); for (int page = 1; page <= 10; page++) { cancellationToken.ThrowIfCancellationRequested(); var pagePhotos = await _client.SearchPhotosAsync(query, page: page, cancellationToken: cancellationToken); photos.AddRange(pagePhotos); await Task.Delay(1000, cancellationToken); } return photos; } Security Considerations 1. API Key Management // ✅ Good: Secure API key management public void ConfigureServices(IServiceCollection services) { // Use configuration system var unsplashConfig = Configuration.GetSection(\"Unsplash\"); var applicationId = unsplashConfig[\"ApplicationId\"] ?? throw new InvalidOperationException(\"Unsplash ApplicationId not configured\"); services.AddUnsplasharp(applicationId); } // appsettings.json (for development) { \"Unsplash\": { \"ApplicationId\": \"your-dev-app-id\" } } // Use Azure Key Vault, AWS Secrets Manager, or similar for production // ❌ Bad: Hardcoded API keys public class BadService { private readonly UnsplasharpClient _client = new(\"hardcoded-api-key-123\"); } 2. Input Validation // ✅ Good: Input validation public async Task<List<Photo>> SearchPhotosSecurely(string query, int page = 1, int perPage = 20) { // Validate inputs if (string.IsNullOrWhiteSpace(query)) throw new ArgumentException(\"Query cannot be empty\", nameof(query)); if (query.Length > 100) throw new ArgumentException(\"Query too long\", nameof(query)); if (page < 1 || page > 1000) throw new ArgumentOutOfRangeException(nameof(page), \"Page must be between 1 and 1000\"); if (perPage < 1 || perPage > 30) throw new ArgumentOutOfRangeException(nameof(perPage), \"PerPage must be between 1 and 30\"); // Sanitize query to prevent injection attacks (if logging to external systems) var sanitizedQuery = query.Replace('\\n', ' ').Replace('\\r', ' '); return await _client.SearchPhotosAsync(sanitizedQuery, page: page, perPage: perPage); } 3. Rate Limiting for User-Facing Applications // ✅ Good: Implement client-side rate limiting public class UserRateLimitedPhotoService { private readonly Dictionary<string, DateTime> _userLastRequest = new(); private readonly TimeSpan _minRequestInterval = TimeSpan.FromSeconds(1); public async Task<List<Photo>> SearchPhotosForUser(string userId, string query) { // Implement per-user rate limiting if (_userLastRequest.TryGetValue(userId, out var lastRequest)) { var timeSinceLastRequest = DateTime.UtcNow - lastRequest; if (timeSinceLastRequest < _minRequestInterval) { var waitTime = _minRequestInterval - timeSinceLastRequest; await Task.Delay(waitTime); } } _userLastRequest[userId] = DateTime.UtcNow; return await _client.SearchPhotosAsync(query); } } Production Deployment 1. Configuration Management // Production-ready configuration public class UnsplashConfiguration { public string ApplicationId { get; set; } = string.Empty; public string? Secret { get; set; } public TimeSpan DefaultTimeout { get; set; } = TimeSpan.FromSeconds(30); public int MaxRetries { get; set; } = 3; public bool EnableCaching { get; set; } = true; public TimeSpan CacheDuration { get; set; } = TimeSpan.FromHours(1); public int MaxConcurrentRequests { get; set; } = 5; } // Startup configuration public void ConfigureServices(IServiceCollection services) { var unsplashConfig = Configuration.GetSection(\"Unsplash\").Get<UnsplashConfiguration>(); // Validate configuration if (string.IsNullOrEmpty(unsplashConfig?.ApplicationId)) { throw new InvalidOperationException(\"Unsplash ApplicationId is required\"); } services.AddSingleton(unsplashConfig); services.AddUnsplasharp(options => { options.ApplicationId = unsplashConfig.ApplicationId; options.Secret = unsplashConfig.Secret; options.ConfigureHttpClient = client => { client.Timeout = unsplashConfig.DefaultTimeout; }; }); // Add health checks services.AddHealthChecks() .AddCheck<UnsplashHealthCheck>(\"unsplash\"); } 2. Health Checks public class UnsplashHealthCheck : IHealthCheck { private readonly UnsplasharpClient _client; private readonly ILogger<UnsplashHealthCheck> _logger; public UnsplashHealthCheck(UnsplasharpClient client, ILogger<UnsplashHealthCheck> logger) { _client = client; _logger = logger; } public async Task<HealthCheckResult> CheckHealthAsync( HealthCheckContext context, CancellationToken cancellationToken = default) { try { // Simple health check - get total stats var stats = await _client.GetTotalStatsAsync(cancellationToken); if (stats == null) { return HealthCheckResult.Unhealthy(\"Unable to retrieve Unsplash statistics\"); } // Check rate limit status var rateLimitStatus = _client.RateLimitRemaining > 10 ? \"Healthy\" : \"Low\"; var data = new Dictionary<string, object> { [\"rate_limit_remaining\"] = _client.RateLimitRemaining, [\"rate_limit_total\"] = _client.MaxRateLimit, [\"rate_limit_status\"] = rateLimitStatus, [\"total_photos\"] = stats.Photos, [\"last_check\"] = DateTime.UtcNow }; return _client.RateLimitRemaining > 0 ? HealthCheckResult.Healthy(\"Unsplash API is accessible\", data) : HealthCheckResult.Degraded(\"Rate limit exhausted\", data); } catch (UnsplasharpRateLimitException ex) { _logger.LogWarning(\"Health check rate limited: {Message}\", ex.Message); return HealthCheckResult.Degraded(\"Rate limited\", new Dictionary<string, object> { [\"rate_limit_reset\"] = ex.RateLimitReset, [\"error\"] = ex.Message }); } catch (UnsplasharpAuthenticationException ex) { _logger.LogError(ex, \"Authentication failed during health check\"); return HealthCheckResult.Unhealthy(\"Authentication failed\", new Dictionary<string, object> { [\"error\"] = ex.Message, [\"check_api_key\"] = true }); } catch (Exception ex) { _logger.LogError(ex, \"Health check failed\"); return HealthCheckResult.Unhealthy(\"Health check failed\", new Dictionary<string, object> { [\"error\"] = ex.Message, [\"exception_type\"] = ex.GetType().Name }); } } } 3. Graceful Degradation public class ResilientPhotoService { private readonly UnsplasharpClient _client; private readonly IMemoryCache _cache; private readonly ILogger<ResilientPhotoService> _logger; private readonly CircuitBreakerPolicy _circuitBreaker; public ResilientPhotoService( UnsplasharpClient client, IMemoryCache cache, ILogger<ResilientPhotoService> logger) { _client = client; _cache = cache; _logger = logger; // Configure circuit breaker _circuitBreaker = Policy .Handle<UnsplasharpException>() .CircuitBreakerAsync( handledEventsAllowedBeforeBreaking: 5, durationOfBreak: TimeSpan.FromMinutes(1), onBreak: (ex, duration) => _logger.LogWarning(\"Circuit breaker opened for {Duration}\", duration), onReset: () => _logger.LogInformation(\"Circuit breaker reset\")); } public async Task<Photo?> GetPhotoWithFallback(string photoId) { try { return await _circuitBreaker.ExecuteAsync(async () => { return await _client.GetPhotoAsync(photoId); }); } catch (CircuitBreakerOpenException) { _logger.LogWarning(\"Circuit breaker open, using cached fallback for photo {PhotoId}\", photoId); // Try to return cached version if (_cache.TryGetValue($\"photo:{photoId}\", out Photo cachedPhoto)) { return cachedPhoto; } // Return placeholder or null return CreatePlaceholderPhoto(photoId); } catch (UnsplasharpRateLimitException ex) { _logger.LogWarning(\"Rate limited, using cached fallback for photo {PhotoId}\", photoId); if (_cache.TryGetValue($\"photo:{photoId}\", out Photo cachedPhoto)) { return cachedPhoto; } return null; } } private Photo CreatePlaceholderPhoto(string photoId) { return new Photo { Id = photoId, Description = \"Photo temporarily unavailable\", Width = 800, Height = 600, Color = \"#CCCCCC\", User = new User { Name = \"Placeholder\", Username = \"placeholder\" }, Urls = new Urls { Regular = \"https://via.placeholder.com/800x600?text=Photo+Unavailable\", Small = \"https://via.placeholder.com/400x300?text=Photo+Unavailable\", Thumbnail = \"https://via.placeholder.com/200x150?text=Photo+Unavailable\" } }; } } Monitoring and Observability 1. Structured Logging public class ObservablePhotoService { private readonly UnsplasharpClient _client; private readonly ILogger<ObservablePhotoService> _logger; private readonly IMetrics _metrics; public ObservablePhotoService( UnsplasharpClient client, ILogger<ObservablePhotoService> logger, IMetrics metrics) { _client = client; _logger = logger; _metrics = metrics; } public async Task<Photo?> GetPhotoAsync(string photoId) { using var activity = Activity.StartActivity(\"GetPhoto\"); activity?.SetTag(\"photo.id\", photoId); var stopwatch = Stopwatch.StartNew(); try { _logger.LogInformation(\"Fetching photo {PhotoId}\", photoId); var photo = await _client.GetPhotoAsync(photoId); stopwatch.Stop(); _logger.LogInformation(\"Successfully fetched photo {PhotoId} in {Duration}ms\", photoId, stopwatch.ElapsedMilliseconds); // Record metrics _metrics.Increment(\"unsplash.photo.requests\", new[] { \"status:success\" }); _metrics.Histogram(\"unsplash.photo.duration\", stopwatch.ElapsedMilliseconds); activity?.SetTag(\"photo.width\", photo.Width); activity?.SetTag(\"photo.height\", photo.Height); activity?.SetTag(\"photo.likes\", photo.Likes); return photo; } catch (UnsplasharpNotFoundException ex) { stopwatch.Stop(); _logger.LogWarning(\"Photo {PhotoId} not found\", photoId); _metrics.Increment(\"unsplash.photo.requests\", new[] { \"status:not_found\" }); activity?.SetStatus(ActivityStatusCode.Error, \"Photo not found\"); return null; } catch (UnsplasharpRateLimitException ex) { stopwatch.Stop(); _logger.LogWarning(\"Rate limited fetching photo {PhotoId}. Remaining: {Remaining}/{Total}, Reset: {Reset}\", photoId, ex.RateLimitRemaining, ex.RateLimit, ex.RateLimitReset); _metrics.Increment(\"unsplash.photo.requests\", new[] { \"status:rate_limited\" }); _metrics.Gauge(\"unsplash.rate_limit.remaining\", ex.RateLimitRemaining ?? 0); activity?.SetStatus(ActivityStatusCode.Error, \"Rate limited\"); throw; } catch (UnsplasharpException ex) { stopwatch.Stop(); _logger.LogError(ex, \"Error fetching photo {PhotoId}: {ErrorMessage}\", photoId, ex.Message); _metrics.Increment(\"unsplash.photo.requests\", new[] { \"status:error\" }); activity?.SetStatus(ActivityStatusCode.Error, ex.Message); throw; } } } 2. Custom Metrics public class UnsplashMetricsService { private readonly IMetrics _metrics; private readonly Timer _metricsTimer; public UnsplashMetricsService(IMetrics metrics, UnsplasharpClient client) { _metrics = metrics; // Periodically report rate limit status _metricsTimer = new Timer(async _ => { _metrics.Gauge(\"unsplash.rate_limit.remaining\", client.RateLimitRemaining); _metrics.Gauge(\"unsplash.rate_limit.total\", client.MaxRateLimit); var utilizationPercent = client.MaxRateLimit > 0 ? (double)(client.MaxRateLimit - client.RateLimitRemaining) / client.MaxRateLimit * 100 : 0; _metrics.Gauge(\"unsplash.rate_limit.utilization_percent\", utilizationPercent); }, null, TimeSpan.Zero, TimeSpan.FromMinutes(1)); } public void RecordSearchMetrics(string query, int resultCount, TimeSpan duration) { _metrics.Increment(\"unsplash.search.requests\"); _metrics.Histogram(\"unsplash.search.duration\", duration.TotalMilliseconds); _metrics.Histogram(\"unsplash.search.result_count\", resultCount); // Tag by query type var queryType = DetermineQueryType(query); _metrics.Increment(\"unsplash.search.by_type\", new[] { $\"type:{queryType}\" }); } private string DetermineQueryType(string query) { if (query.Contains(\" \")) return \"multi_word\"; if (query.Length > 20) return \"long\"; if (query.All(char.IsLetter)) return \"text_only\"; return \"simple\"; } public void Dispose() { _metricsTimer?.Dispose(); } } 3. Application Insights Integration public class ApplicationInsightsPhotoService { private readonly UnsplasharpClient _client; private readonly TelemetryClient _telemetryClient; public ApplicationInsightsPhotoService(UnsplasharpClient client, TelemetryClient telemetryClient) { _client = client; _telemetryClient = telemetryClient; } public async Task<List<Photo>> SearchPhotosWithTelemetry(string query, int perPage = 20) { var stopwatch = Stopwatch.StartNew(); var properties = new Dictionary<string, string> { [\"query\"] = query, [\"per_page\"] = perPage.ToString() }; try { var photos = await _client.SearchPhotosAsync(query, perPage: perPage); stopwatch.Stop(); var metrics = new Dictionary<string, double> { [\"duration_ms\"] = stopwatch.ElapsedMilliseconds, [\"result_count\"] = photos.Count, [\"rate_limit_remaining\"] = _client.RateLimitRemaining, [\"total_results\"] = _client.LastPhotosSearchTotalResults }; _telemetryClient.TrackEvent(\"UnsplashSearchSuccess\", properties, metrics); return photos; } catch (UnsplasharpRateLimitException ex) { stopwatch.Stop(); properties[\"error_type\"] = \"rate_limit\"; properties[\"rate_limit_reset\"] = ex.RateLimitReset?.ToString() ?? \"unknown\"; var metrics = new Dictionary<string, double> { [\"duration_ms\"] = stopwatch.ElapsedMilliseconds, [\"rate_limit_remaining\"] = ex.RateLimitRemaining ?? 0, [\"rate_limit_total\"] = ex.RateLimit ?? 0 }; _telemetryClient.TrackEvent(\"UnsplashSearchRateLimited\", properties, metrics); throw; } catch (UnsplasharpException ex) { stopwatch.Stop(); properties[\"error_type\"] = ex.GetType().Name; properties[\"error_message\"] = ex.Message; var metrics = new Dictionary<string, double> { [\"duration_ms\"] = stopwatch.ElapsedMilliseconds }; _telemetryClient.TrackEvent(\"UnsplashSearchError\", properties, metrics); _telemetryClient.TrackException(ex); throw; } } } Summary This comprehensive testing and best practices guide provides: Testing Strategy Unit Tests: Focus on business logic and error handling Integration Tests: Validate API contracts and error scenarios Performance Tests: Ensure acceptable response times and throughput Best Practices Error Handling: Use specific exception types and appropriate logging Caching: Implement intelligent caching with appropriate TTL Rate Limiting: Proactive monitoring and graceful handling Security: Secure API key management and input validation Production Readiness Configuration: Environment-specific settings and validation Health Checks: Monitor API availability and rate limits Resilience: Circuit breakers and graceful degradation Observability: Structured logging, metrics, and distributed tracing Key Takeaways Always test error scenarios, not just happy paths Implement comprehensive monitoring and alerting Use dependency injection for better testability Handle rate limits proactively, not reactively Cache intelligently based on content characteristics Validate inputs and secure API keys properly Plan for graceful degradation when the API is unavailable Following these practices will help you build robust, maintainable, and production-ready applications with Unsplasharp."
  }
}